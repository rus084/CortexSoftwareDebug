###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         02/Mar/2020  19:27:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\win10\f7dbg\git\EWARM\dbgC.c
#    Command line =  
#        -f C:\Users\rus08\AppData\Local\Temp\EW6A18.tmp
#        (D:\win10\f7dbg\git\EWARM\dbgC.c -D USE_HAL_DRIVER -D STM32F723xx -lC
#        D:\win10\f7dbg\git\EWARM\dbgTST\List -lA
#        D:\win10\f7dbg\git\EWARM\dbgTST\List -o
#        D:\win10\f7dbg\git\EWARM\dbgTST\Obj --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc\c\DLib_Config_Full.h"
#        -I D:\win10\f7dbg\git\EWARM/../Inc\ -I
#        D:\win10\f7dbg\git\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\ -I
#        D:\win10\f7dbg\git\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\win10\f7dbg\git\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I D:\win10\f7dbg\git\EWARM/../Drivers/CMSIS/Include\ -Ohz)
#    Locale       =  C
#    List file    =  D:\win10\f7dbg\git\EWARM\dbgTST\List\dbgC.lst
#    Object file  =  D:\win10\f7dbg\git\EWARM\dbgTST\Obj\dbgC.o
#
###############################################################################

D:\win10\f7dbg\git\EWARM\dbgC.c
      1          #include "stdint.h"
      2          #include "stm32f7xx.h"
      3          
      4          #define DBG_ADDR 0x20001000
      5          
      6          #define DHCSR (*(uint32_t*)0xE000EDF0)
      7          #define DCRSR (*(uint32_t*)0xE000EDF4)
      8          #define DCRDR (*(uint32_t*)0xE000EDF8)
      9          #define DEMCR (*(uint32_t*)0xE000EDFC)
     10          
     11          #define NUMOFBKPTS 8
     12          
     13          typedef struct {
     14            uint32_t FP_CTRL;
     15            uint32_t FP_REMAP;
     16            uint32_t FP_COMP[NUMOFBKPTS];
     17          } fp_t;
     18          
     19          #define FP ((fp_t*)0xE0002000)
     20          
     21          typedef struct
     22          {
     23          //  ; R4,   R5,     R6,     R7,
     24          //  ; R8,   R9,     R10,    R11,
     25          //  ; DMY,  R0,     R1,     R2
     26          //  ; R3,   R12,    LR,     PC
     27          //  ; xPSR        
     28            uint32_t R4;
     29            uint32_t R5;
     30            uint32_t R6;
     31            uint32_t R7;
     32            uint32_t R8;
     33            uint32_t R9;
     34            uint32_t R10;
     35            uint32_t R11;
     36            uint32_t reserved;
     37            uint32_t R0;
     38            uint32_t R1;
     39            uint32_t R2;
     40            uint32_t R3;
     41            uint32_t R12;
     42            uint32_t LR;
     43            uint32_t PC;
     44            uint32_t xPSR;
     45          } exceptionFrame_t;
     46          
     47          typedef struct 
     48          {    
     49            // disable receive data
     50            unsigned tx:1;
     51            // program stopped
     52            unsigned StopProgramm:1;
     53            union {
     54              enum rx_state_e 
     55              {
     56                rxWaitS = 0, // wait Esc symbol
     57                rxWaitC = 1, // wait Start of frame
     58                rxReceive = 2, // receiving
     59                rxEsc = 3, // Esc received
     60              } rx_state;
     61              enum tx_state_e {
     62                txSendS = 0, // send first byte of Start of frame
     63                txSendC = 1, // send second byte
     64                txSendN = 2, // send byte of data
     65                txEsc = 3,   // send escaped byte of data
     66                txEnd = 4,   // send End of frame
     67                txSendS2 = 5,// send first byte of Interrupt
     68                txBrk = 6,   // send second byte
     69              } tx_state;
     70            };
     71            uint8_t pos; // receive/send position
     72            uint8_t buf[128];
     73            uint8_t txCnt; // size of send data
     74            uint32_t NVICISER[3];
     75          } dbg_t;
     76          
     77          #define dbgG ((dbg_t*)DBG_ADDR)
     78          

   \                                 In section .text, align 2, keep-with-next
     79          int memcpySafe(uint8_t* to,uint8_t* from, int len)
     80          {
   \                     memcpySafe: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
     81              /* Cortex-M3, Cortex-M4, Cortex-M4F, Cortex-M7 are supported */
     82              static const uint32_t BFARVALID_MASK = (0x80 << SCB_CFSR_BUSFAULTSR_Pos);
     83              int cnt = 0;
     84          
     85              /* Clear BFARVALID flag by writing 1 to it */
     86              SCB->CFSR |= BFARVALID_MASK;
   \        0x2   0x....             LDR.N    R4,??DataTable2  ;; 0xe000ed14
   \        0x4   0x4603             MOV      R3,R0
   \        0x6   0x6965             LDR      R5,[R4, #+20]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xF445 0x4500      ORR      R5,R5,#0x8000
   \        0xE   0x6165             STR      R5,[R4, #+20]
     87          
     88              /* Ignore BusFault by enabling BFHFNMIGN and disabling interrupts */
     89              uint32_t mask = __get_FAULTMASK();
   \       0x10   0xF3EF 0x8513      MRS      R5,FAULTMASK
     90              __disable_fault_irq();
   \       0x14   0xB671             CPSID    F
     91              SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   \       0x16   0x6826             LDR      R6,[R4, #+0]
   \       0x18   0xF446 0x7680      ORR      R6,R6,#0x100
   \       0x1C   0x6026             STR      R6,[R4, #+0]
   \       0x1E   0xE004             B.N      ??memcpySafe_0
     92          
     93              while ((cnt<len))
     94              {
     95                *(to++) = *(from++);
   \                     ??memcpySafe_1: (+1)
   \       0x20   0xF811 0x7B01      LDRB     R7,[R1], #+1
     96                cnt++;
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \       0x26   0xF803 0x7B01      STRB     R7,[R3], #+1
     97              }
   \                     ??memcpySafe_0: (+1)
   \       0x2A   0x4290             CMP      R0,R2
   \       0x2C   0xDBF8             BLT.N    ??memcpySafe_1
     98          
     99              /* Reenable BusFault by clearing  BFHFNMIGN */
    100              SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0xF421 0x7180      BIC      R1,R1,#0x100
   \       0x34   0x6021             STR      R1,[R4, #+0]
    101              __set_FAULTMASK(mask);
   \       0x36   0xF385 0x8813      MSR      FAULTMASK,R5
    102          
    103              return cnt;
   \       0x3A   0xBDF0             POP      {R4-R7,PC}       ;; return
    104          }
    105          

   \                                 In section .text, align 4, keep-with-next
    106          void parseAnswer(exceptionFrame_t* regList)
    107          {
   \                     parseAnswer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    108            dbg_t* dbg = dbgG;
    109            uint32_t addr;
    110            uint32_t tmp;
    111            switch (dbg->buf[0])
   \        0x2   0x....             LDR.N    R5,??DataTable2_1  ;; 0x20001000
   \        0x4   0x....             LDR.N    R4,??DataTable2_2  ;; 0x20001083
   \        0x6   0x78EE             LDRB     R6,[R5, #+3]
   \        0x8   0x....             LDR.N    R1,??DataTable2_3  ;; 0x20001008
   \        0xA   0x....             LDR.N    R2,??DataTable2_4  ;; 0xe0002008
   \        0xC   0x....             LDR.N    R3,??DataTable2_5  ;; 0x20001003
   \        0xE   0x1EB6             SUBS     R6,R6,#+2
   \       0x10   0x2E08             CMP      R6,#+8
   \       0x12   0xD806             BHI.N    ??parseAnswer_3
   \       0x14   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??parseAnswer_0:
   \       0x18   0x0A 0x14          DC8      0xA,0x14,0x1F,0x2C
   \              0x1F 0x2C    
   \       0x1C   0x33 0x67          DC8      0x33,0x67,0x82,0x94
   \              0x82 0x94    
   \       0x20   0xAE 0x00          DC8      0xAE,0x0
    112            {
    113            case 1:
    114            default:
    115              dbg->pos = 1;
   \                     ??parseAnswer_3: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
    116              dbg->buf[0] = 0x33;
   \       0x24   0x2133             MOVS     R1,#+51
   \       0x26   0x70A8             STRB     R0,[R5, #+2]
   \       0x28   0x7019             STRB     R1,[R3, #+0]
    117              break;
   \                     ??parseAnswer_4: (+1)
   \       0x2A   0xE0D2             B.N      ??parseAnswer_5
    118            case 2:
    119              if (dbg->pos>4)
   \                     ??parseAnswer_6: (+1)
   \       0x2C   0x78AE             LDRB     R6,[R5, #+2]
   \       0x2E   0x2E04             CMP      R6,#+4
   \       0x30   0xDDFB             BLE.N    ??parseAnswer_4
    120              { // readMem
    121                addr = *(uint32_t*)(&dbg->buf[1]);
    122                uint8_t len = dbg->buf[5];
    123                dbg->pos = memcpySafe(dbg->buf,(uint8_t*) addr, len);
   \       0x32   0x780A             LDRB     R2,[R1, #+0]
   \       0x34   0xF8D3 0x1001      LDR      R1,[R3, #+1]
   \       0x38   0x4618             MOV      R0,R3
   \       0x3A   0x.... 0x....      BL       memcpySafe
   \       0x3E   0xE050             B.N      ??parseAnswer_7
    124              }
    125              break;
    126            case 3:
    127              if (dbg->pos>5)
   \                     ??parseAnswer_8: (+1)
   \       0x40   0x78A8             LDRB     R0,[R5, #+2]
   \       0x42   0x2805             CMP      R0,#+5
   \       0x44   0xDDF1             BLE.N    ??parseAnswer_4
    128              { // writeMem
    129                addr = *(uint32_t*)(&dbg->buf[1]);
    130                uint8_t len = dbg->pos-5;
    131                memcpySafe((uint8_t*)addr,&dbg->buf[5],len);
   \       0x46   0x1F42             SUBS     R2,R0,#+5
   \       0x48   0xF8D3 0x0001      LDR      R0,[R3, #+1]
   \       0x4C   0xB2D2             UXTB     R2,R2
   \       0x4E   0x.... 0x....      BL       memcpySafe
    132                dbg->pos = 1;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE045             B.N      ??parseAnswer_7
    133              }
    134              break;
    135            case 4: // stop target
    136              dbg->pos = 0;
   \                     ??parseAnswer_9: (+1)
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x70A9             STRB     R1,[R5, #+2]
    137              if (dbg->StopProgramm)
   \       0x5A   0x682A             LDR      R2,[R5, #+0]
   \       0x5C   0xF3C2 0x0140      UBFX     R1,R2,#+1,#+1
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD10B             BNE.N    ??parseAnswer_10
    138                break;
    139              addr = regList->PC;
    140              FP->FP_COMP[5] = (addr&0xFFFFFFFE) | 1;
   \       0x64   0x6BC0             LDR      R0,[R0, #+60]
   \       0x66   0x....             LDR.N    R1,??DataTable2_6  ;; 0xe000201c
   \       0x68   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x6C   0x6008             STR      R0,[R1, #+0]
    141              dbg->pos = 0;
   \       0x6E   0xE07E             B.N      ??parseAnswer_11
    142              break;
    143            case 5: // continue execution
    144              /*
    145              addr = regList->PC | 1;
    146              
    147              for (tmp=0;tmp<NUMOFBKPTS;tmp++)
    148              {
    149                if (FP->FP_COMP[tmp]==addr)
    150                {
    151                  dbg->SetBkpt = addr;
    152                  dbg->BkptNum = tmp;
    153                  FP->FP_COMP[tmp] = 0;
    154                  
    155                  DEMCR|=1<<18; // step the core
    156                  __disable_irq(); // because step exception occured in interrupt
    157                  break;
    158                }
    159              }
    160              */
    161              dbg->StopProgramm = 0;
   \                     ??parseAnswer_12: (+1)
   \       0x70   0x6828             LDR      R0,[R5, #+0]
    162              dbg->pos = 0;
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0xF020 0x0002      BIC      R0,R0,#0x2
   \       0x78   0x6028             STR      R0,[R5, #+0]
   \       0x7A   0x70A9             STRB     R1,[R5, #+2]
    163              break;
   \                     ??parseAnswer_10: (+1)
   \       0x7C   0xE0A9             B.N      ??parseAnswer_5
    164            case 6: // read regs
    165              switch (dbg->buf[1])
   \                     ??parseAnswer_13: (+1)
   \       0x7E   0x785A             LDRB     R2,[R3, #+1]
   \       0x80   0x2A10             CMP      R2,#+16
   \       0x82   0xD82A             BHI.N    ??parseAnswer_14
   \       0x84   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??parseAnswer_1:
   \       0x88   0x09 0x0B          DC8      0x9,0xB,0xD,0xF
   \              0x0D 0x0F    
   \       0x8C   0x11 0x13          DC8      0x11,0x13,0x15,0x17
   \              0x15 0x17    
   \       0x90   0x19 0x1B          DC8      0x19,0x1B,0x1D,0x1F
   \              0x1D 0x1F    
   \       0x94   0x21 0x2A          DC8      0x21,0x2A,0x23,0x25
   \              0x23 0x25    
   \       0x98   0x27 0x00          DC8      0x27,0x0
    166              {
    167              case 0x00:
    168                addr = regList->R0;
   \                     ??parseAnswer_15: (+1)
   \       0x9A   0x6A40             LDR      R0,[R0, #+36]
    169                break;
   \       0x9C   0xE01E             B.N      ??parseAnswer_16
    170              case 0x01:
    171                addr = regList->R1;
   \                     ??parseAnswer_17: (+1)
   \       0x9E   0x6A80             LDR      R0,[R0, #+40]
    172                break;
   \       0xA0   0xE01C             B.N      ??parseAnswer_16
    173              case 0x02:
    174                addr = regList->R2;
   \                     ??parseAnswer_18: (+1)
   \       0xA2   0x6AC0             LDR      R0,[R0, #+44]
    175                break;
   \       0xA4   0xE01A             B.N      ??parseAnswer_16
    176              case 0x03:
    177                addr = regList->R3;
   \                     ??parseAnswer_19: (+1)
   \       0xA6   0x6B00             LDR      R0,[R0, #+48]
    178                break;
   \       0xA8   0xE018             B.N      ??parseAnswer_16
    179              case 0x04:
    180                addr = regList->R4;
   \                     ??parseAnswer_20: (+1)
   \       0xAA   0x6800             LDR      R0,[R0, #+0]
    181                break;
   \       0xAC   0xE016             B.N      ??parseAnswer_16
    182              case 0x05:
    183                addr = regList->R5;
   \                     ??parseAnswer_21: (+1)
   \       0xAE   0x6840             LDR      R0,[R0, #+4]
    184                break;
   \       0xB0   0xE014             B.N      ??parseAnswer_16
    185              case 0x06:
    186                addr = regList->R6;
   \                     ??parseAnswer_22: (+1)
   \       0xB2   0x6880             LDR      R0,[R0, #+8]
    187                break;
   \       0xB4   0xE012             B.N      ??parseAnswer_16
    188              case 0x07:
    189                addr = regList->R7;
   \                     ??parseAnswer_23: (+1)
   \       0xB6   0x68C0             LDR      R0,[R0, #+12]
    190                break;
   \       0xB8   0xE010             B.N      ??parseAnswer_16
    191              case 0x08:
    192                addr = regList->R8;
   \                     ??parseAnswer_24: (+1)
   \       0xBA   0x6900             LDR      R0,[R0, #+16]
    193                break;
   \       0xBC   0xE00E             B.N      ??parseAnswer_16
    194              case 0x09:
    195                addr = regList->R9;
   \                     ??parseAnswer_25: (+1)
   \       0xBE   0x6940             LDR      R0,[R0, #+20]
    196                break;
   \       0xC0   0xE00C             B.N      ??parseAnswer_16
    197              case 0x0A:
    198                addr = regList->R10;
   \                     ??parseAnswer_26: (+1)
   \       0xC2   0x6980             LDR      R0,[R0, #+24]
    199                break;
   \       0xC4   0xE00A             B.N      ??parseAnswer_16
    200              case 0x0B:
    201                addr = regList->R11;
   \                     ??parseAnswer_27: (+1)
   \       0xC6   0x69C0             LDR      R0,[R0, #+28]
    202                break;
   \       0xC8   0xE008             B.N      ??parseAnswer_16
    203              case 0x0C:
    204                addr = regList->R12;
   \                     ??parseAnswer_28: (+1)
   \       0xCA   0x6B40             LDR      R0,[R0, #+52]
    205                break;
   \       0xCC   0xE006             B.N      ??parseAnswer_16
    206              case 0x0D:
    207                addr = (uint32_t)regList; // sp
    208                break;
    209              case 0x0E:
    210                addr = regList->LR;
   \                     ??parseAnswer_29: (+1)
   \       0xCE   0x6B80             LDR      R0,[R0, #+56]
    211                break;
   \       0xD0   0xE004             B.N      ??parseAnswer_16
    212              case 0x0F:
    213                addr = regList->PC;
   \                     ??parseAnswer_30: (+1)
   \       0xD2   0x6BC0             LDR      R0,[R0, #+60]
    214                break;
   \       0xD4   0xE002             B.N      ??parseAnswer_16
    215              case 0x10:
    216                addr = regList->xPSR;
   \                     ??parseAnswer_31: (+1)
   \       0xD6   0x6C00             LDR      R0,[R0, #+64]
    217                break;
   \       0xD8   0xE000             B.N      ??parseAnswer_16
    218              default:
    219                addr = 0xDEADFACE;
   \                     ??parseAnswer_14: (+1)
   \       0xDA   0x....             LDR.N    R0,??DataTable2_7  ;; 0xdeadface
    220                break;
    221              }
    222              *(uint32_t*)(dbg->buf) = addr;
   \                     ??parseAnswer_16: (+1)
   \       0xDC   0xF8C5 0x0003      STR      R0,[R5, #+3]
    223              dbg->pos = 4;
   \       0xE0   0x2004             MOVS     R0,#+4
   \                     ??parseAnswer_7: (+1)
   \       0xE2   0x70A8             STRB     R0,[R5, #+2]
    224              break;
   \       0xE4   0xE075             B.N      ??parseAnswer_5
    225            case 7: // set bkpt
    226              dbg->pos = 0;
   \                     ??parseAnswer_32: (+1)
   \       0xE6   0x2100             MOVS     R1,#+0
    227              addr = ((*(uint32_t*)(&dbg->buf[1])))|1;
    228              for (tmp = 0;tmp<8;tmp++)
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0x70A9             STRB     R1,[R5, #+2]
   \       0xEC   0xF8D3 0x1001      LDR      R1,[R3, #+1]
   \       0xF0   0xF041 0x0101      ORR      R1,R1,#0x1
    229                if (FP->FP_COMP[tmp] == addr)
   \                     ??parseAnswer_33: (+1)
   \       0xF4   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \       0xF8   0x428B             CMP      R3,R1
   \       0xFA   0xD002             BEQ.N    ??parseAnswer_34
   \       0xFC   0x1C40             ADDS     R0,R0,#+1
   \       0xFE   0x2808             CMP      R0,#+8
   \      0x100   0xD3F8             BCC.N    ??parseAnswer_33
    230                  break;
    231              
    232              if (tmp!=8)
   \                     ??parseAnswer_34: (+1)
   \      0x102   0x2808             CMP      R0,#+8
   \      0x104   0xD165             BNE.N    ??parseAnswer_5
    233                break;
    234              
    235              for (tmp=0;tmp<NUMOFBKPTS;tmp++)
   \      0x106   0x2300             MOVS     R3,#+0
    236                if (FP->FP_COMP[tmp]==0)
   \                     ??parseAnswer_35: (+1)
   \      0x108   0xF852 0x0023      LDR      R0,[R2, R3, LSL #+2]
   \      0x10C   0xB118             CBZ.N    R0,??parseAnswer_36
   \      0x10E   0x1C5B             ADDS     R3,R3,#+1
   \      0x110   0x2B08             CMP      R3,#+8
   \      0x112   0xD3F9             BCC.N    ??parseAnswer_35
   \      0x114   0xE05D             B.N      ??parseAnswer_5
    237                {
    238                  FP->FP_COMP[tmp] = addr;
   \                     ??parseAnswer_36: (+1)
   \      0x116   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
    239                  break;
   \      0x11A   0xE05A             B.N      ??parseAnswer_5
    240                }
    241              break;
    242            case 8: // clear bkpt
    243              dbg->pos = 0;
   \                     ??parseAnswer_37: (+1)
   \      0x11C   0x2000             MOVS     R0,#+0
    244              addr = ((*(uint32_t*)(&dbg->buf[1]))&0xFFFFFFFE)|1;
    245              for (tmp = 0; tmp<NUMOFBKPTS;tmp++)
   \      0x11E   0x2100             MOVS     R1,#+0
   \      0x120   0x70A8             STRB     R0,[R5, #+2]
   \      0x122   0xF8D3 0x0001      LDR      R0,[R3, #+1]
   \      0x126   0x2600             MOVS     R6,#+0
   \      0x128   0xF040 0x0001      ORR      R0,R0,#0x1
    246              {
    247                if (FP->FP_COMP[tmp]==addr)
   \                     ??parseAnswer_38: (+1)
   \      0x12C   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \      0x130   0x4283             CMP      R3,R0
   \      0x132   0xBF08             IT       EQ 
   \      0x134   0xF842 0x6021      STREQ    R6,[R2, R1, LSL #+2]
    248                  FP->FP_COMP[tmp] = 0;
    249              }
   \      0x138   0x1C49             ADDS     R1,R1,#+1
   \      0x13A   0x2908             CMP      R1,#+8
   \      0x13C   0xD3F6             BCC.N    ??parseAnswer_38
   \      0x13E   0xE048             B.N      ??parseAnswer_5
    250              break;
    251            case 9: // step
    252              dbg->NVICISER[0] = NVIC->ISER[0];
   \                     ??parseAnswer_39: (+1)
   \      0x140   0x....             LDR.N    R0,??DataTable2_8  ;; 0xe000e100
    253              NVIC->ICER[0] = dbg->NVICISER[0];
   \      0x142   0x....             LDR.N    R2,??DataTable2_9  ;; 0xe000e180
   \      0x144   0x6801             LDR      R1,[R0, #+0]
   \      0x146   0xF8C4 0x1001      STR      R1,[R4, #+1]
   \      0x14A   0x6011             STR      R1,[R2, #+0]
    254              dbg->NVICISER[1] = NVIC->ISER[1];
   \      0x14C   0x6841             LDR      R1,[R0, #+4]
   \      0x14E   0xF8C4 0x1005      STR      R1,[R4, #+5]
    255              NVIC->ICER[1] = dbg->NVICISER[1];
   \      0x152   0x6051             STR      R1,[R2, #+4]
    256              dbg->NVICISER[2] = NVIC->ISER[2];
   \      0x154   0x6880             LDR      R0,[R0, #+8]
   \      0x156   0xF8C4 0x0009      STR      R0,[R4, #+9]
    257              NVIC->ICER[2] = dbg->NVICISER[2];
   \      0x15A   0x6090             STR      R0,[R2, #+8]
    258              
    259              DEMCR|=1<<18; // step the core
   \      0x15C   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000edfc
   \      0x15E   0x6801             LDR      R1,[R0, #+0]
   \      0x160   0xF441 0x2180      ORR      R1,R1,#0x40000
   \      0x164   0x6001             STR      R1,[R0, #+0]
    260              //__disable_irq(); // because step exception occured in interrupt
    261              dbg->StopProgramm = 0;
   \      0x166   0x6828             LDR      R0,[R5, #+0]
   \      0x168   0xF020 0x0002      BIC      R0,R0,#0x2
   \      0x16C   0x6028             STR      R0,[R5, #+0]
    262              dbg->pos = 0;
   \                     ??parseAnswer_11: (+1)
   \      0x16E   0x2200             MOVS     R2,#+0
   \      0x170   0x70AA             STRB     R2,[R5, #+2]
    263              break;
   \      0x172   0xE02E             B.N      ??parseAnswer_5
    264            case 10: // write reg
    265              addr = ((*(uint32_t*)(&dbg->buf[2])));
    266              switch (dbg->buf[1])
   \                     ??parseAnswer_40: (+1)
   \      0x174   0x785A             LDRB     R2,[R3, #+1]
   \      0x176   0xF8D3 0x1002      LDR      R1,[R3, #+2]
   \      0x17A   0x2A10             CMP      R2,#+16
   \      0x17C   0xD829             BHI.N    ??parseAnswer_5
   \      0x17E   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??parseAnswer_2:
   \      0x182   0x09 0x0B          DC8      0x9,0xB,0xD,0xF
   \              0x0D 0x0F    
   \      0x186   0x11 0x13          DC8      0x11,0x13,0x15,0x17
   \              0x15 0x17    
   \      0x18A   0x19 0x1B          DC8      0x19,0x1B,0x1D,0x1F
   \              0x1D 0x1F    
   \      0x18E   0x21 0x28          DC8      0x21,0x28,0x23,0x25
   \              0x23 0x25    
   \      0x192   0x27 0x00          DC8      0x27,0x0
    267              {
    268              case 0x00:
    269                regList->R0 = addr;
   \                     ??parseAnswer_41: (+1)
   \      0x194   0x6241             STR      R1,[R0, #+36]
    270                break;
   \      0x196   0xE01C             B.N      ??parseAnswer_5
    271              case 0x01:
    272                regList->R1 = addr;
   \                     ??parseAnswer_42: (+1)
   \      0x198   0x6281             STR      R1,[R0, #+40]
    273                break;
   \      0x19A   0xE01A             B.N      ??parseAnswer_5
    274              case 0x02:
    275                regList->R2 = addr;
   \                     ??parseAnswer_43: (+1)
   \      0x19C   0x62C1             STR      R1,[R0, #+44]
    276                break;
   \      0x19E   0xE018             B.N      ??parseAnswer_5
    277              case 0x03:
    278                regList->R3 = addr;
   \                     ??parseAnswer_44: (+1)
   \      0x1A0   0x6301             STR      R1,[R0, #+48]
    279                break;
   \      0x1A2   0xE016             B.N      ??parseAnswer_5
    280              case 0x04:
    281                regList->R4 = addr;
   \                     ??parseAnswer_45: (+1)
   \      0x1A4   0x6001             STR      R1,[R0, #+0]
    282                break;
   \      0x1A6   0xE014             B.N      ??parseAnswer_5
    283              case 0x05:
    284                regList->R5 = addr;
   \                     ??parseAnswer_46: (+1)
   \      0x1A8   0x6041             STR      R1,[R0, #+4]
    285                break;
   \      0x1AA   0xE012             B.N      ??parseAnswer_5
    286              case 0x06:
    287                regList->R6 = addr;
   \                     ??parseAnswer_47: (+1)
   \      0x1AC   0x6081             STR      R1,[R0, #+8]
    288                break;
   \      0x1AE   0xE010             B.N      ??parseAnswer_5
    289              case 0x07:
    290                regList->R7 = addr;
   \                     ??parseAnswer_48: (+1)
   \      0x1B0   0x60C1             STR      R1,[R0, #+12]
    291                break;
   \      0x1B2   0xE00E             B.N      ??parseAnswer_5
    292              case 0x08:
    293                regList->R8 = addr;
   \                     ??parseAnswer_49: (+1)
   \      0x1B4   0x6101             STR      R1,[R0, #+16]
    294                break;
   \      0x1B6   0xE00C             B.N      ??parseAnswer_5
    295              case 0x09:
    296                regList->R9 = addr;
   \                     ??parseAnswer_50: (+1)
   \      0x1B8   0x6141             STR      R1,[R0, #+20]
    297                break;
   \      0x1BA   0xE00A             B.N      ??parseAnswer_5
    298              case 0x0A:
    299                regList->R10 = addr;
   \                     ??parseAnswer_51: (+1)
   \      0x1BC   0x6181             STR      R1,[R0, #+24]
    300                break;
   \      0x1BE   0xE008             B.N      ??parseAnswer_5
    301              case 0x0B:
    302                regList->R11 = addr;
   \                     ??parseAnswer_52: (+1)
   \      0x1C0   0x61C1             STR      R1,[R0, #+28]
    303                break;
   \      0x1C2   0xE006             B.N      ??parseAnswer_5
    304              case 0x0C:
    305                regList->R12 = addr;
   \                     ??parseAnswer_53: (+1)
   \      0x1C4   0x6341             STR      R1,[R0, #+52]
    306                break;
   \      0x1C6   0xE004             B.N      ??parseAnswer_5
    307              case 0x0D:
    308                //(uint32_t)regList; // sp
    309                break;
    310              case 0x0E:
    311                regList->LR = addr;
   \                     ??parseAnswer_54: (+1)
   \      0x1C8   0x6381             STR      R1,[R0, #+56]
    312                break;
   \      0x1CA   0xE002             B.N      ??parseAnswer_5
    313              case 0x0F:
    314                regList->PC = addr;
   \                     ??parseAnswer_55: (+1)
   \      0x1CC   0x63C1             STR      R1,[R0, #+60]
    315                break;
   \      0x1CE   0xE000             B.N      ??parseAnswer_5
    316              case 0x10:
    317                regList->xPSR = addr;
   \                     ??parseAnswer_56: (+1)
   \      0x1D0   0x6401             STR      R1,[R0, #+64]
    318                break;
    319              }
    320              break;
    321            }
    322            dbg->txCnt = 0;
    323            dbg->tx = 1;
   \                     ??parseAnswer_5: (+1)
   \      0x1D2   0x6829             LDR      R1,[R5, #+0]
   \      0x1D4   0x2000             MOVS     R0,#+0
   \      0x1D6   0x7020             STRB     R0,[R4, #+0]
   \      0x1D8   0xF041 0x0101      ORR      R1,R1,#0x1
   \      0x1DC   0x6029             STR      R1,[R5, #+0]
    324            dbg->tx_state = txSendS;
   \      0x1DE   0x7068             STRB     R0,[R5, #+1]
    325            SET_BIT(USART6->CR1, USART_CR1_TXEIE);
   \      0x1E0   0x....             LDR.N    R0,??DataTable2_11  ;; 0x40011400
   \      0x1E2   0x6803             LDR      R3,[R0, #+0]
   \      0x1E4   0xF043 0x0380      ORR      R3,R3,#0x80
   \      0x1E8   0x6003             STR      R3,[R0, #+0]
    326          }
   \      0x1EA   0xBD70             POP      {R4-R6,PC}       ;; return
    327          
    328          #define FP_LAR_UNLOCK_KEY 0xc5acce55
    329          #define FP_LAR_PTR ((unsigned int*) 0xe0002fb0)
    330          

   \                                 In section .text, align 2, keep-with-next
    331          void initDbg()
    332          {
   \                     initDbg: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    333            *FP_LAR_PTR = FP_LAR_UNLOCK_KEY;
   \        0x2   0x....             LDR.N    R0,??DataTable2_12  ;; 0xc5acce55
   \        0x4   0x....             LDR.N    R1,??DataTable2_13  ;; 0xe0002fb0
    334            DEMCR   = 0x00010000; // enable debug mon
    335            FP->FP_CTRL = 0x00000003; // enable flash patch
   \        0x6   0x2403             MOVS     R4,#+3
   \        0x8   0x....             LDR.N    R5,??DataTable2_14  ;; 0xe0002000
   \        0xA   0x6008             STR      R0,[R1, #+0]
   \        0xC   0xF44F 0x3280      MOV      R2,#+65536
   \       0x10   0x....             LDR.N    R3,??DataTable2_10  ;; 0xe000edfc
   \       0x12   0x602C             STR      R4,[R5, #+0]
   \       0x14   0x601A             STR      R2,[R3, #+0]
    336            //FP->FP_COMP[0] = 0x080017CC | 1; // set breakpoint in main loop
    337          
    338            for (int i=0;i<sizeof(dbg_t);i+=4)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x....             LDR.N    R1,??DataTable2_1  ;; 0x20001000
   \       0x1A   0x2400             MOVS     R4,#+0
    339              (((uint32_t*)dbgG)[i/4])=0;
   \                     ??initDbg_0: (+1)
   \       0x1C   0x1042             ASRS     R2,R0,#+1
   \       0x1E   0xEB00 0x7392      ADD      R3,R0,R2, LSR #+30
   \       0x22   0x1D00             ADDS     R0,R0,#+4
   \       0x24   0x109B             ASRS     R3,R3,#+2
   \       0x26   0x2890             CMP      R0,#+144
   \       0x28   0xF841 0x4023      STR      R4,[R1, R3, LSL #+2]
   \       0x2C   0xD3F6             BCC.N    ??initDbg_0
    340          }
   \       0x2E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xE000'ED14        DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x2000'1000        DC32     0x20001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x2000'1083        DC32     0x20001083

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x2000'1008        DC32     0x20001008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0xE000'2008        DC32     0xe0002008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x2000'1003        DC32     0x20001003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0xE000'201C        DC32     0xe000201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0xDEAD'FACE        DC32     0xdeadface

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \        0x0   0xE000'EDFC        DC32     0xe000edfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \        0x0   0xC5AC'CE55        DC32     0xc5acce55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \        0x0   0xE000'2FB0        DC32     0xe0002fb0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \        0x0   0xE000'2000        DC32     0xe0002000
    341          
    342          
    343          /*
    344          void rxCb(uint8_t byte)
    345          {
    346            dbg_t* dbg = dbgG; // debug vars pointer
    347            
    348            if (dbg->tx) // use half duplex mode
    349              return;
    350            
    351            switch(dbg->rx_state)
    352            {
    353            default:
    354            case rxWaitS:
    355              if (byte==0xAA)
    356                dbg->rx_state = rxWaitC;
    357              break;
    358            case rxWaitC:
    359              if (byte == 0xFF)
    360                dbg->rx_state = rxReceive;
    361              else
    362                dbg->rx_state = rxWaitS;
    363              dbg->pos = 0;
    364              break;
    365            case rxReceive:
    366              if (byte == 0xAA)
    367                dbg->rx_state = rxEsc;
    368              else
    369                dbg->buf[dbg->pos++] = byte;
    370              break;
    371            case rxEsc:
    372              if (byte == 0xAA)
    373              {
    374                dbg->buf[dbg->pos++] = byte;
    375                dbg->rx_state  = rxReceive;
    376              }
    377              else if (byte == 0x00)
    378              {
    379                parseAnswer();
    380              }
    381              else
    382                dbg->rx_state = rxWaitS;
    383            }
    384          }
    385          
    386          void txCb()
    387          {
    388            dbg_t* dbg = dbgG;
    389            switch (dbg->tx_state)
    390            {
    391            case txSendS:
    392              USART6->TDR = 0xAA;
    393              dbg->tx_state = txSendC;
    394              break;
    395            case txSendC:
    396              USART6->TDR = 0xFF;
    397              dbg->tx_state = txSendN;
    398              break;
    399            case txSendN:
    400              if (dbg->txCnt>=dbg->pos)
    401              {
    402                USART6->TDR = 0xAA;
    403                dbg->tx_state = txEnd;
    404                break;
    405              }
    406              if (dbg->buf[dbg->txCnt]==0xAA)
    407              {
    408                USART6->TDR = 0xAA;
    409                dbg->tx_state = txEsc;
    410                break;
    411              }
    412              USART6->TDR = dbg->buf[dbg->txCnt++];
    413              break;
    414            case txEsc:
    415              USART6->TDR = 0xAA;
    416              dbg->txCnt++;
    417              dbg->tx_state = txSendN;
    418              break;
    419            case txEnd:
    420              USART6->TDR = 0x00;
    421              dbg->rx_state = rxWaitS;
    422              dbg->tx = 0;
    423              CLEAR_BIT(USART6->CR1, USART_CR1_TXEIE);
    424              break;
    425            case txSendS2:
    426              USART6->TDR = 0xAA;
    427              dbg->tx_state = txBrk;
    428              break;
    429            case txBrk:
    430              USART6->TDR = 0xA5;
    431              dbg->rx_state = rxWaitS;
    432              dbg->tx = 0;
    433              CLEAR_BIT(USART6->CR1, USART_CR1_TXEIE);
    434              break;
    435            }
    436          }
    437          
    438          void DebugMon_HandlerO(void)
    439          {
    440            //HAL_NVIC_DisableIRQ(USART6_IRQn);
    441            dbgG->StopProgramm = 1;
    442            
    443            for (int i=0;i<8;i++)
    444              FP->FP_COMP[i] = 0;
    445            
    446            while (USART6->CR1 & USART_CR1_TXEIE)
    447            {
    448              if ((USART6->ISR & USART_ISR_TXE) != 0U)
    449              {
    450                txCb();
    451              }
    452            }
    453            
    454            dbgG->tx_state = txSendS2;
    455            dbgG->tx = 1;
    456            SET_BIT(USART6->CR1, USART_CR1_TXEIE);
    457            while (dbgG->StopProgramm)
    458            {
    459              if (((USART6->ISR & USART_ISR_RXNE) != 0U)
    460                  && ((USART6->CR1 & USART_CR1_RXNEIE) != 0U))
    461              {
    462                rxCb(USART6->RDR);
    463              }
    464          
    465              if (((USART6->ISR & USART_ISR_TXE) != 0U)
    466                  && ((USART6->CR1 & USART_CR1_TXEIE) != 0U))
    467              {
    468                txCb();
    469              }
    470              
    471            }
    472          }
    473          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   initDbg
      20   memcpySafe
      16   parseAnswer
        16   -> memcpySafe


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      48  initDbg
      60  memcpySafe
     492  parseAnswer

 
 660 bytes in section .text
 
 660 bytes of CODE memory

Errors: none
Warnings: none
