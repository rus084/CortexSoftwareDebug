###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Feb/2020  21:42:18
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
#    Command line =  
#        -f C:\Users\rus08\AppData\Local\Temp\EW7026.tmp
#        (D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32F723xx -lC
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -lA
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -o
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc\c\DLib_Config_Full.h"
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Include\ -Ohz)
#    Locale       =  C
#    List file    =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List\stm32f7xx_hal_gpio.lst
#    Object file  =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj\stm32f7xx_hal_gpio.o
#
###############################################################################

D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..] 
     16            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     17            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     18            in several modes:
     19            (+) Input mode 
     20            (+) Analog mode
     21            (+) Output mode
     22            (+) Alternate function mode
     23            (+) External interrupt/event lines
     24          
     25            [..]  
     26            During and just after reset, the alternate functions and external interrupt  
     27            lines are not active and the I/O ports are configured in input floating mode.
     28            
     29            [..]   
     30            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     31            activated or not.
     32          
     33            [..]
     34            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     35            type and the IO speed can be selected depending on the VDD value.
     36          
     37            [..]  
     38            All ports have external interrupt/event capability. To use external interrupt 
     39            lines, the port must be configured in input mode. All available GPIO pins are 
     40            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41            
     42            [..]
     43            The external interrupt/event controller consists of up to 23 edge detectors 
     44            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     45            input line can be independently configured to select the type (interrupt or event) 
     46            and the corresponding trigger event (rising or falling or both). Each line can 
     47            also be masked independently. 
     48          
     49                               ##### How to use this driver #####
     50            ==============================================================================  
     51            [..]
     52              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     53          
     54              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     55                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     56                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     57                       structure.
     58                  (++) In case of Output or alternate function mode selection: the speed is 
     59                       configured through "Speed" member from GPIO_InitTypeDef structure.
     60                  (++) In alternate mode is selection, the alternate function connected to the IO
     61                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     62                  (++) Analog mode is required when a pin is to be used as ADC channel 
     63                       or DAC output.
     64                  (++) In case of external interrupt/event selection the "Mode" member from 
     65                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     66                       the corresponding trigger event (rising or falling or both).
     67          
     68              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     69                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     70                  HAL_NVIC_EnableIRQ().
     71                   
     72              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     73                      
     74              (#) To set/reset the level of a pin configured in output mode use 
     75                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     76              
     77              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     78          
     79                           
     80              (#) During and just after reset, the alternate functions are not 
     81                  active and the GPIO pins are configured in input floating mode (except JTAG
     82                  pins).
     83            
     84              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     85                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     86                  priority over the GPIO function.
     87            
     88              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     89                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     90                  The HSE has priority over the GPIO function.
     91            
     92            @endverbatim
     93            ******************************************************************************
     94            * @attention
     95            *
     96            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     97            * All rights reserved.</center></h2>
     98            *
     99            * This software component is licensed by ST under BSD 3-Clause license,
    100            * the "License"; You may not use this file except in compliance with the
    101            * License. You may obtain a copy of the License at:
    102            *                        opensource.org/licenses/BSD-3-Clause
    103            *
    104            ******************************************************************************
    105            */ 
    106          
    107          /* Includes ------------------------------------------------------------------*/
    108          #include "stm32f7xx_hal.h"
    109          
    110          /** @addtogroup STM32F7xx_HAL_Driver
    111            * @{
    112            */
    113          
    114          /** @defgroup GPIO GPIO
    115            * @brief GPIO HAL module driver
    116            * @{
    117            */
    118          
    119          #ifdef HAL_GPIO_MODULE_ENABLED
    120          
    121          /* Private typedef -----------------------------------------------------------*/
    122          /* Private define ------------------------------------------------------------*/
    123          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    124            * @{
    125            */
    126          #define GPIO_MODE             ((uint32_t)0x00000003U)
    127          #define EXTI_MODE             ((uint32_t)0x10000000U)
    128          #define GPIO_MODE_IT          ((uint32_t)0x00010000U)
    129          #define GPIO_MODE_EVT         ((uint32_t)0x00020000U)
    130          #define RISING_EDGE           ((uint32_t)0x00100000U)
    131          #define FALLING_EDGE          ((uint32_t)0x00200000U)
    132          #define GPIO_OUTPUT_TYPE      ((uint32_t)0x00000010U)
    133          
    134          #define GPIO_NUMBER           ((uint32_t)16U)
    135          /**
    136            * @}
    137            */
    138          /* Private macro -------------------------------------------------------------*/
    139          /* Private variables ---------------------------------------------------------*/
    140          /* Private function prototypes -----------------------------------------------*/
    141          /* Private functions ---------------------------------------------------------*/
    142          /* Exported functions --------------------------------------------------------*/
    143          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    144            * @{
    145            */
    146          
    147          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    148           *  @brief    Initialization and Configuration functions
    149           *
    150          @verbatim
    151           ===============================================================================
    152                        ##### Initialization and de-initialization functions #####
    153           ===============================================================================
    154            [..]
    155              This section provides functions allowing to initialize and de-initialize the GPIOs
    156              to be ready for use.
    157           
    158          @endverbatim
    159            * @{
    160            */
    161          
    162          /**
    163            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    164            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
    165            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    166            *         the configuration information for the specified GPIO peripheral.
    167            * @retval None
    168            */

   \                                 In section .text, align 2, keep-with-next
    169          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    170          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0x4602             MOV      R2,R0
   \        0x6   0x460B             MOV      R3,R1
    171            uint32_t position = 0x00;
   \        0x8   0x2400             MOVS     R4,#+0
    172            uint32_t ioposition = 0x00;
    173            uint32_t iocurrent = 0x00;
    174            uint32_t temp = 0x00;
    175          
    176            /* Check the parameters */
    177            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    178            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    179            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    180            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    181          
    182            /* Configure the port pins */
    183            for(position = 0; position < GPIO_NUMBER; position++)
   \        0xA   0x....             LDR.N    R0,??DataTable2  ;; 0x40023844
   \        0xC   0x210F             MOVS     R1,#+15
    184            {
    185              /* Get the IO position */
    186              ioposition = ((uint32_t)0x01) << position;
    187              /* Get the current IO position */
    188              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
   \                     ??HAL_GPIO_Init_0: (+1)
   \        0xE   0x681D             LDR      R5,[R3, #+0]
   \       0x10   0x2701             MOVS     R7,#+1
   \       0x12   0x40A7             LSLS     R7,R7,R4
   \       0x14   0xEA07 0x0805      AND      R8,R7,R5
    189          
    190              if(iocurrent == ioposition)
   \       0x18   0x45B8             CMP      R8,R7
   \       0x1A   0xF040 0x80BC      BNE.W    ??HAL_GPIO_Init_1
    191              {
    192                /*--------------------- GPIO Mode Configuration ------------------------*/
    193                /* In case of Alternate function mode selection */
    194                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \       0x1E   0x685D             LDR      R5,[R3, #+4]
   \       0x20   0xEA4F 0x0984      LSL      R9,R4,#+2
   \       0x24   0x2D02             CMP      R5,#+2
   \       0x26   0xBF18             IT       NE 
   \       0x28   0x2D12             CMPNE    R5,#+18
   \       0x2A   0xD111             BNE.N    ??HAL_GPIO_Init_2
    195                {
    196                  /* Check the Alternate function parameter */
    197                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    198                  
    199                  /* Configure Alternate function mapped with the current IO */
    200                  temp = GPIOx->AFR[position >> 3];
   \       0x2C   0x08E5             LSRS     R5,R4,#+3
   \       0x2E   0xEB02 0x0C85      ADD      R12,R2,R5, LSL #+2
    201                  temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
    202                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
    203                  GPIOx->AFR[position >> 3] = temp;
   \       0x32   0xF009 0x051C      AND      R5,R9,#0x1C
   \       0x36   0xFA01 0xF605      LSL      R6,R1,R5
   \       0x3A   0xF8DC 0xE020      LDR      LR,[R12, #+32]
   \       0x3E   0xF8D3 0xA010      LDR      R10,[R3, #+16]
   \       0x42   0xEA2E 0x0606      BIC      R6,LR,R6
   \       0x46   0xFA0A 0xF505      LSL      R5,R10,R5
   \       0x4A   0x4335             ORRS     R5,R5,R6
   \       0x4C   0xF8CC 0x5020      STR      R5,[R12, #+32]
    204                }
    205          
    206                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    207                temp = GPIOx->MODER;
   \                     ??HAL_GPIO_Init_2: (+1)
   \       0x50   0x6815             LDR      R5,[R2, #+0]
    208                temp &= ~(GPIO_MODER_MODER0 << (position * 2));
    209                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
    210                GPIOx->MODER = temp;
   \       0x52   0xEA4F 0x0C44      LSL      R12,R4,#+1
   \       0x56   0x2603             MOVS     R6,#+3
   \       0x58   0xFA06 0xF60C      LSL      R6,R6,R12
   \       0x5C   0xEA6F 0x0E06      MVN      LR,R6
   \       0x60   0x791E             LDRB     R6,[R3, #+4]
   \       0x62   0xEA0E 0x0505      AND      R5,LR,R5
   \       0x66   0xF006 0x0603      AND      R6,R6,#0x3
   \       0x6A   0xFA06 0xF60C      LSL      R6,R6,R12
   \       0x6E   0x4335             ORRS     R5,R6,R5
   \       0x70   0x6015             STR      R5,[R2, #+0]
    211          
    212                /* In case of Output or Alternate function mode selection */
    213                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    214                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \       0x72   0x685D             LDR      R5,[R3, #+4]
   \       0x74   0x2D01             CMP      R5,#+1
   \       0x76   0xBF18             IT       NE 
   \       0x78   0x2D02             CMPNE    R5,#+2
   \       0x7A   0xD003             BEQ.N    ??HAL_GPIO_Init_3
   \       0x7C   0x2D11             CMP      R5,#+17
   \       0x7E   0xBF18             IT       NE 
   \       0x80   0x2D12             CMPNE    R5,#+18
   \       0x82   0xD110             BNE.N    ??HAL_GPIO_Init_4
    215                {
    216                  /* Check the Speed parameter */
    217                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    218                  /* Configure the IO Speed */
    219                  temp = GPIOx->OSPEEDR; 
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x84   0x6895             LDR      R5,[R2, #+8]
    220                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
    221                  temp |= (GPIO_Init->Speed << (position * 2));
    222                  GPIOx->OSPEEDR = temp;
   \       0x86   0x68DE             LDR      R6,[R3, #+12]
   \       0x88   0xEA0E 0x0505      AND      R5,LR,R5
   \       0x8C   0xFA06 0xF60C      LSL      R6,R6,R12
   \       0x90   0x4335             ORRS     R5,R6,R5
   \       0x92   0x6095             STR      R5,[R2, #+8]
    223          
    224                  /* Configure the IO Output Type */
    225                  temp = GPIOx->OTYPER;
   \       0x94   0x6855             LDR      R5,[R2, #+4]
    226                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    227                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
    228                  GPIOx->OTYPER = temp;
   \       0x96   0xEA25 0x0707      BIC      R7,R5,R7
   \       0x9A   0x685D             LDR      R5,[R3, #+4]
   \       0x9C   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \       0xA0   0x40A5             LSLS     R5,R5,R4
   \       0xA2   0x432F             ORRS     R7,R5,R7
   \       0xA4   0x6057             STR      R7,[R2, #+4]
    229                }
    230          
    231                /* Activate the Pull-up or Pull down resistor for the current IO */
    232                temp = GPIOx->PUPDR;
   \                     ??HAL_GPIO_Init_4: (+1)
   \       0xA6   0x68D7             LDR      R7,[R2, #+12]
    233                temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
    234                temp |= ((GPIO_Init->Pull) << (position * 2));
    235                GPIOx->PUPDR = temp;
   \       0xA8   0xEA0E 0x0507      AND      R5,LR,R7
   \       0xAC   0x689F             LDR      R7,[R3, #+8]
   \       0xAE   0xFA07 0xF60C      LSL      R6,R7,R12
   \       0xB2   0x4335             ORRS     R5,R6,R5
   \       0xB4   0x60D5             STR      R5,[R2, #+12]
    236          
    237                /*--------------------- EXTI Mode Configuration ------------------------*/
    238                /* Configure the External Interrupt or event for the current IO */
    239                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
   \       0xB6   0x685D             LDR      R5,[R3, #+4]
   \       0xB8   0x00ED             LSLS     R5,R5,#+3
   \       0xBA   0xD56C             BPL.N    ??HAL_GPIO_Init_1
    240                {
    241                  /* Enable SYSCFG Clock */
    242                  __HAL_RCC_SYSCFG_CLK_ENABLE();
   \       0xBC   0x6807             LDR      R7,[R0, #+0]
    243          
    244                  temp = SYSCFG->EXTICR[position >> 2];
   \       0xBE   0x.... 0x....      LDR.W    R12,??DataTable2_1  ;; 0x40013808
    245                  temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
   \       0xC2   0xF009 0x090C      AND      R9,R9,#0xC
   \       0xC6   0xFA01 0xF609      LSL      R6,R1,R9
   \       0xCA   0xF447 0x4780      ORR      R7,R7,#0x4000
   \       0xCE   0x6007             STR      R7,[R0, #+0]
   \       0xD0   0x6805             LDR      R5,[R0, #+0]
   \       0xD2   0xF405 0x4580      AND      R5,R5,#0x4000
   \       0xD6   0x9500             STR      R5,[SP, #+0]
   \       0xD8   0x9F00             LDR      R7,[SP, #+0]
   \       0xDA   0x08A7             LSRS     R7,R4,#+2
   \       0xDC   0xF85C 0x5027      LDR      R5,[R12, R7, LSL #+2]
   \       0xE0   0xEA25 0x0E06      BIC      LR,R5,R6
    246                  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
   \       0xE4   0x....             LDR.N    R5,??DataTable2_2  ;; 0x40020000
   \       0xE6   0x42AA             CMP      R2,R5
   \       0xE8   0xBF08             IT       EQ 
   \       0xEA   0x2500             MOVEQ    R5,#+0
   \       0xEC   0xD022             BEQ.N    ??HAL_GPIO_Init_5
   \       0xEE   0x....             LDR.N    R6,??DataTable2_3  ;; 0x40020400
   \       0xF0   0x42B2             CMP      R2,R6
   \       0xF2   0xBF08             IT       EQ 
   \       0xF4   0x2501             MOVEQ    R5,#+1
   \       0xF6   0xD01D             BEQ.N    ??HAL_GPIO_Init_5
   \       0xF8   0x....             LDR.N    R5,??DataTable2_4  ;; 0x40020800
   \       0xFA   0x42AA             CMP      R2,R5
   \       0xFC   0xBF08             IT       EQ 
   \       0xFE   0x2502             MOVEQ    R5,#+2
   \      0x100   0xD018             BEQ.N    ??HAL_GPIO_Init_5
   \      0x102   0x....             LDR.N    R6,??DataTable2_5  ;; 0x40020c00
   \      0x104   0x42B2             CMP      R2,R6
   \      0x106   0xBF08             IT       EQ 
   \      0x108   0x2503             MOVEQ    R5,#+3
   \      0x10A   0xD013             BEQ.N    ??HAL_GPIO_Init_5
   \      0x10C   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40021000
   \      0x10E   0x42AA             CMP      R2,R5
   \      0x110   0xBF08             IT       EQ 
   \      0x112   0x2504             MOVEQ    R5,#+4
   \      0x114   0xD00E             BEQ.N    ??HAL_GPIO_Init_5
   \      0x116   0x....             LDR.N    R6,??DataTable2_7  ;; 0x40021400
   \      0x118   0x42B2             CMP      R2,R6
   \      0x11A   0xBF08             IT       EQ 
   \      0x11C   0x2505             MOVEQ    R5,#+5
   \      0x11E   0xD009             BEQ.N    ??HAL_GPIO_Init_5
   \      0x120   0x....             LDR.N    R5,??DataTable2_8  ;; 0x40021800
   \      0x122   0x42AA             CMP      R2,R5
   \      0x124   0xBF08             IT       EQ 
   \      0x126   0x2506             MOVEQ    R5,#+6
   \      0x128   0xD004             BEQ.N    ??HAL_GPIO_Init_5
   \      0x12A   0x....             LDR.N    R6,??DataTable2_9  ;; 0x40021c00
   \      0x12C   0x42B2             CMP      R2,R6
   \      0x12E   0xBF0C             ITE      EQ 
   \      0x130   0x2507             MOVEQ    R5,#+7
   \      0x132   0x2508             MOVNE    R5,#+8
    247                  SYSCFG->EXTICR[position >> 2] = temp;
   \                     ??HAL_GPIO_Init_5: (+1)
   \      0x134   0xFA05 0xF509      LSL      R5,R5,R9
   \      0x138   0xEA45 0x050E      ORR      R5,R5,LR
   \      0x13C   0xF84C 0x5027      STR      R5,[R12, R7, LSL #+2]
    248          
    249                  /* Clear EXTI line configuration */
    250                  temp = EXTI->IMR;
   \      0x140   0x....             LDR.N    R6,??DataTable2_10  ;; 0x40013c00
   \      0x142   0x6835             LDR      R5,[R6, #+0]
    251                  temp &= ~((uint32_t)iocurrent);
   \      0x144   0xEA6F 0x0708      MVN      R7,R8
   \      0x148   0xEA07 0x0C05      AND      R12,R7,R5
    252                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \      0x14C   0x685D             LDR      R5,[R3, #+4]
   \      0x14E   0x03ED             LSLS     R5,R5,#+15
   \      0x150   0xBF48             IT       MI 
   \      0x152   0xEA48 0x0C0C      ORRMI    R12,R8,R12
    253                  {
    254                    temp |= iocurrent;
    255                  }
    256                  EXTI->IMR = temp;
   \      0x156   0xF8C6 0xC000      STR      R12,[R6, #+0]
    257          
    258                  temp = EXTI->EMR;
   \      0x15A   0x6875             LDR      R5,[R6, #+4]
    259                  temp &= ~((uint32_t)iocurrent);
   \      0x15C   0xEA07 0x0C05      AND      R12,R7,R5
    260                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \      0x160   0x685D             LDR      R5,[R3, #+4]
   \      0x162   0x03AD             LSLS     R5,R5,#+14
   \      0x164   0xBF48             IT       MI 
   \      0x166   0xEA48 0x0C0C      ORRMI    R12,R8,R12
    261                  {
    262                    temp |= iocurrent;
    263                  }
    264                  EXTI->EMR = temp;
   \      0x16A   0xF8C6 0xC004      STR      R12,[R6, #+4]
    265          
    266                  /* Clear Rising Falling edge configuration */
    267                  temp = EXTI->RTSR;
   \      0x16E   0x68B5             LDR      R5,[R6, #+8]
    268                  temp &= ~((uint32_t)iocurrent);
   \      0x170   0xEA07 0x0C05      AND      R12,R7,R5
    269                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \      0x174   0x685D             LDR      R5,[R3, #+4]
   \      0x176   0x02ED             LSLS     R5,R5,#+11
   \      0x178   0xBF48             IT       MI 
   \      0x17A   0xEA48 0x0C0C      ORRMI    R12,R8,R12
    270                  {
    271                    temp |= iocurrent;
    272                  }
    273                  EXTI->RTSR = temp;
   \      0x17E   0xF8C6 0xC008      STR      R12,[R6, #+8]
    274          
    275                  temp = EXTI->FTSR;
   \      0x182   0x68F5             LDR      R5,[R6, #+12]
    276                  temp &= ~((uint32_t)iocurrent);
   \      0x184   0xEA07 0x0C05      AND      R12,R7,R5
    277                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \      0x188   0x685F             LDR      R7,[R3, #+4]
   \      0x18A   0x02BD             LSLS     R5,R7,#+10
   \      0x18C   0xBF48             IT       MI 
   \      0x18E   0xEA48 0x0C0C      ORRMI    R12,R8,R12
    278                  {
    279                    temp |= iocurrent;
    280                  }
    281                  EXTI->FTSR = temp;
   \      0x192   0xF8C6 0xC00C      STR      R12,[R6, #+12]
    282                }
    283              }
    284            }
   \                     ??HAL_GPIO_Init_1: (+1)
   \      0x196   0x1C64             ADDS     R4,R4,#+1
   \      0x198   0x2C0F             CMP      R4,#+15
   \      0x19A   0xF67F 0xAF38      BLS.W    ??HAL_GPIO_Init_0
    285          }
   \      0x19E   0xE8BD 0x87F1      POP      {R0,R4-R10,PC}   ;; return
    286          
    287          /**
    288            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    289            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
    290            * @param  GPIO_Pin specifies the port bit to be written.
    291            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    292            * @retval None
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    295          {
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4602             MOV      R2,R0
   \        0x6   0x468A             MOV      R10,R1
    296            uint32_t position;
    297            uint32_t ioposition = 0x00;
    298            uint32_t iocurrent = 0x00;
    299            uint32_t tmp = 0x00;
    300          
    301            /* Check the parameters */
    302            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    303            
    304            /* Configure the port pins */
    305            for(position = 0; position < GPIO_NUMBER; position++)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable2_10  ;; 0x40013c00
   \        0xC   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40013808
    306            {
    307              /* Get the IO position */
    308              ioposition = ((uint32_t)0x01) << position;
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \        0xE   0x2401             MOVS     R4,#+1
   \       0x10   0x409C             LSLS     R4,R4,R3
    309              /* Get the current IO position */
    310              iocurrent = (GPIO_Pin) & ioposition;
   \       0x12   0xEA04 0x090A      AND      R9,R4,R10
    311          
    312              if(iocurrent == ioposition)
   \       0x16   0x45A1             CMP      R9,R4
   \       0x18   0xD169             BNE.N    ??HAL_GPIO_DeInit_1
    313              {
    314                /*------------------------- EXTI Mode Configuration --------------------*/
    315                tmp = SYSCFG->EXTICR[position >> 2];
   \       0x1A   0x089F             LSRS     R7,R3,#+2
    316                tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
   \       0x1C   0x009D             LSLS     R5,R3,#+2
   \       0x1E   0xF851 0x6027      LDR      R6,[R1, R7, LSL #+2]
   \       0x22   0xF005 0x0C0C      AND      R12,R5,#0xC
   \       0x26   0xF04F 0x0B0F      MOV      R11,#+15
   \       0x2A   0xFA0B 0xFE0C      LSL      LR,R11,R12
   \       0x2E   0xEA0E 0x0806      AND      R8,LR,R6
    317                if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
   \       0x32   0x....             LDR.N    R6,??DataTable2_2  ;; 0x40020000
   \       0x34   0x42B2             CMP      R2,R6
   \       0x36   0xBF08             IT       EQ 
   \       0x38   0x2600             MOVEQ    R6,#+0
   \       0x3A   0xD022             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x3C   0x....             LDR.N    R6,??DataTable2_3  ;; 0x40020400
   \       0x3E   0x42B2             CMP      R2,R6
   \       0x40   0xBF08             IT       EQ 
   \       0x42   0x2601             MOVEQ    R6,#+1
   \       0x44   0xD01D             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x46   0x....             LDR.N    R6,??DataTable2_4  ;; 0x40020800
   \       0x48   0x42B2             CMP      R2,R6
   \       0x4A   0xBF08             IT       EQ 
   \       0x4C   0x2602             MOVEQ    R6,#+2
   \       0x4E   0xD018             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x50   0x....             LDR.N    R6,??DataTable2_5  ;; 0x40020c00
   \       0x52   0x42B2             CMP      R2,R6
   \       0x54   0xBF08             IT       EQ 
   \       0x56   0x2603             MOVEQ    R6,#+3
   \       0x58   0xD013             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x5A   0x....             LDR.N    R6,??DataTable2_6  ;; 0x40021000
   \       0x5C   0x42B2             CMP      R2,R6
   \       0x5E   0xBF08             IT       EQ 
   \       0x60   0x2604             MOVEQ    R6,#+4
   \       0x62   0xD00E             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x64   0x....             LDR.N    R6,??DataTable2_7  ;; 0x40021400
   \       0x66   0x42B2             CMP      R2,R6
   \       0x68   0xBF08             IT       EQ 
   \       0x6A   0x2605             MOVEQ    R6,#+5
   \       0x6C   0xD009             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x6E   0x....             LDR.N    R6,??DataTable2_8  ;; 0x40021800
   \       0x70   0x42B2             CMP      R2,R6
   \       0x72   0xBF08             IT       EQ 
   \       0x74   0x2606             MOVEQ    R6,#+6
   \       0x76   0xD004             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0x78   0x....             LDR.N    R6,??DataTable2_9  ;; 0x40021c00
   \       0x7A   0x42B2             CMP      R2,R6
   \       0x7C   0xBF0C             ITE      EQ 
   \       0x7E   0x2607             MOVEQ    R6,#+7
   \       0x80   0x2608             MOVNE    R6,#+8
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \       0x82   0xFA06 0xF60C      LSL      R6,R6,R12
   \       0x86   0x45B0             CMP      R8,R6
   \       0x88   0xD113             BNE.N    ??HAL_GPIO_DeInit_3
    318                {
    319                  /* Configure the External Interrupt or event for the current IO */
    320                  tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
    321                  SYSCFG->EXTICR[position >> 2] &= ~tmp;
   \       0x8A   0xF851 0x6027      LDR      R6,[R1, R7, LSL #+2]
   \       0x8E   0xEA26 0x060E      BIC      R6,R6,LR
   \       0x92   0xF841 0x6027      STR      R6,[R1, R7, LSL #+2]
    322          
    323                  /* Clear EXTI line configuration */
    324                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \       0x96   0x6807             LDR      R7,[R0, #+0]
   \       0x98   0xEA6F 0x0609      MVN      R6,R9
   \       0x9C   0x4037             ANDS     R7,R6,R7
   \       0x9E   0x6007             STR      R7,[R0, #+0]
    325                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \       0xA0   0x6847             LDR      R7,[R0, #+4]
   \       0xA2   0x4037             ANDS     R7,R6,R7
   \       0xA4   0x6047             STR      R7,[R0, #+4]
    326          
    327                  /* Clear Rising Falling edge configuration */
    328                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \       0xA6   0x6887             LDR      R7,[R0, #+8]
   \       0xA8   0x4037             ANDS     R7,R6,R7
   \       0xAA   0x6087             STR      R7,[R0, #+8]
    329                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \       0xAC   0x68C7             LDR      R7,[R0, #+12]
   \       0xAE   0x403E             ANDS     R6,R6,R7
   \       0xB0   0x60C6             STR      R6,[R0, #+12]
    330                }
    331                /*------------------------- GPIO Mode Configuration --------------------*/
    332                /* Configure IO Direction in Input Floating Mode */
    333                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0xB2   0x2603             MOVS     R6,#+3
   \       0xB4   0x005F             LSLS     R7,R3,#+1
   \       0xB6   0xFA06 0xF707      LSL      R7,R6,R7
   \       0xBA   0x6816             LDR      R6,[R2, #+0]
   \       0xBC   0x43FF             MVNS     R7,R7
    334          
    335                /* Configure the default Alternate Function in current IO */
    336                GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
   \       0xBE   0xF005 0x051C      AND      R5,R5,#0x1C
   \       0xC2   0xFA0B 0xF505      LSL      R5,R11,R5
   \       0xC6   0x403E             ANDS     R6,R7,R6
   \       0xC8   0x6016             STR      R6,[R2, #+0]
   \       0xCA   0x08DE             LSRS     R6,R3,#+3
   \       0xCC   0xEB02 0x0686      ADD      R6,R2,R6, LSL #+2
   \       0xD0   0xF8D6 0x9020      LDR      R9,[R6, #+32]
   \       0xD4   0xEA29 0x0505      BIC      R5,R9,R5
   \       0xD8   0x6235             STR      R5,[R6, #+32]
    337          
    338                /* Configure the default value for IO Speed */
    339                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
   \       0xDA   0x6895             LDR      R5,[R2, #+8]
   \       0xDC   0x403D             ANDS     R5,R7,R5
   \       0xDE   0x6095             STR      R5,[R2, #+8]
    340          
    341                /* Configure the default value IO Output Type */
    342                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
   \       0xE0   0x6855             LDR      R5,[R2, #+4]
   \       0xE2   0xEA25 0x0404      BIC      R4,R5,R4
   \       0xE6   0x6054             STR      R4,[R2, #+4]
    343          
    344                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    345                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
   \       0xE8   0x68D4             LDR      R4,[R2, #+12]
   \       0xEA   0x4027             ANDS     R7,R7,R4
   \       0xEC   0x60D7             STR      R7,[R2, #+12]
    346              }
    347            }
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \       0xEE   0x1C5B             ADDS     R3,R3,#+1
   \       0xF0   0x2B0F             CMP      R3,#+15
   \       0xF2   0xD98C             BLS.N    ??HAL_GPIO_DeInit_0
    348          }
   \       0xF4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    349          
    350          /**
    351            * @}
    352            */
    353          
    354          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    355           *  @brief   GPIO Read and Write
    356           *
    357          @verbatim
    358           ===============================================================================
    359                                 ##### IO operation functions #####
    360           ===============================================================================
    361          
    362          @endverbatim
    363            * @{
    364            */
    365          
    366          /**
    367            * @brief  Reads the specified input port pin.
    368            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
    369            * @param  GPIO_Pin specifies the port bit to read.
    370            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    371            * @retval The input port pin value.
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    374          {
    375            GPIO_PinState bitstatus;
    376          
    377            /* Check the parameters */
    378            assert_param(IS_GPIO_PIN(GPIO_Pin));
    379          
    380            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x4008             ANDS     R0,R1,R0
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2001             MOVNE    R0,#+1
    381            {
    382              bitstatus = GPIO_PIN_SET;
    383            }
    384            else
    385            {
    386              bitstatus = GPIO_PIN_RESET;
    387            }
    388            return bitstatus;
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /**
    392            * @brief  Sets or clears the selected data port bit.
    393            *
    394            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    395            *         accesses. In this way, there is no risk of an IRQ occurring between
    396            *         the read and the modify access.
    397            *
    398            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
    399            * @param  GPIO_Pin specifies the port bit to be written.
    400            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    401            * @param  PinState specifies the value to be written to the selected bit.
    402            *          This parameter can be one of the GPIO_PinState enum values:
    403            *            @arg GPIO_PIN_RESET: to clear the port pin
    404            *            @arg GPIO_PIN_SET: to set the port pin
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    408          {
    409            /* Check the parameters */
    410            assert_param(IS_GPIO_PIN(GPIO_Pin));
    411            assert_param(IS_GPIO_PIN_ACTION(PinState));
    412          
    413            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0xB902             CBNZ.N   R2,??HAL_GPIO_WritePin_0
    414            {
    415              GPIOx->BSRR = GPIO_Pin;
    416            }
    417            else
    418            {
    419              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
   \        0x2   0x0409             LSLS     R1,R1,#+16
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \        0x4   0x6181             STR      R1,[R0, #+24]
    420            }
    421          }
   \        0x6   0x4770             BX       LR               ;; return
    422          
    423          /**
    424            * @brief  Toggles the specified GPIO pins.
    425            * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
    426            * @param  GPIO_Pin Specifies the pins to be toggled.
    427            * @retval None
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    430          {
    431            /* Check the parameters */
    432            assert_param(IS_GPIO_PIN(GPIO_Pin));
    433          
    434            if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x400A             ANDS     R2,R1,R2
   \        0x4   0x428A             CMP      R2,R1
   \        0x6   0xBF08             IT       EQ 
   \        0x8   0x0409             LSLEQ    R1,R1,#+16
    435            {
    436              GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    437            }
    438            else
    439            {
    440              GPIOx->BSRR = GPIO_Pin;
   \        0xA   0x6181             STR      R1,[R0, #+24]
    441            }
    442          }
   \        0xC   0x4770             BX       LR               ;; return
    443          
    444          /**
    445            * @brief  Locks GPIO Pins configuration registers.
    446            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    447            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    448            * @note   The configuration of the locked GPIO pins can no longer be modified
    449            *         until the next reset.
    450            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F7 family
    451            * @param  GPIO_Pin specifies the port bit to be locked.
    452            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    453            * @retval None
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    456          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
    457            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x2   0xF44F 0x3380      MOV      R3,#+65536
   \        0x6   0x9300             STR      R3,[SP, #+0]
    458          
    459            /* Check the parameters */
    460            assert_param(IS_GPIO_PIN(GPIO_Pin));
    461          
    462            /* Apply lock key write sequence */
    463            tmp |= GPIO_Pin;
   \        0x8   0x9C00             LDR      R4,[SP, #+0]
   \        0xA   0x430C             ORRS     R4,R1,R4
   \        0xC   0x9400             STR      R4,[SP, #+0]
    464            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    465            GPIOx->LCKR = tmp;
   \        0xE   0x9B00             LDR      R3,[SP, #+0]
   \       0x10   0x61C3             STR      R3,[R0, #+28]
    466            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    467            GPIOx->LCKR = GPIO_Pin;
   \       0x12   0x61C1             STR      R1,[R0, #+28]
    468            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    469            GPIOx->LCKR = tmp;
   \       0x14   0x9900             LDR      R1,[SP, #+0]
   \       0x16   0x61C1             STR      R1,[R0, #+28]
    470            /* Read LCKK bit*/
    471            tmp = GPIOx->LCKR;
   \       0x18   0x69C2             LDR      R2,[R0, #+28]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
    472          
    473           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \       0x1C   0x69C0             LDR      R0,[R0, #+28]
   \       0x1E   0xF400 0x3080      AND      R0,R0,#0x10000
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x4180             SBCS     R0,R0,R0
   \       0x26   0x0FC0             LSRS     R0,R0,#+31
    474            {
    475              return HAL_OK;
    476            }
    477            else
    478            {
    479              return HAL_ERROR;
   \       0x28   0xBD12             POP      {R1,R4,PC}       ;; return
    480            }
    481          }
    482          
    483          /**
    484            * @brief  This function handles EXTI interrupt request.
    485            * @param  GPIO_Pin Specifies the pins connected EXTI line
    486            * @retval None
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    489          {
    490            /* EXTI line interrupt detected */
    491            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable2_11  ;; 0x40013c14
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0x4203             TST      R3,R0
   \        0x6   0xBF1C             ITT      NE 
    492            {
    493              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0x8   0x6010             STRNE    R0,[R2, #+0]
    494              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \        0xA   0x.... 0x....      BNE.W    HAL_GPIO_EXTI_Callback
    495            }
    496          }
   \        0xE   0x4770             BX       LR               ;; return
    497          
    498          /**
    499            * @brief  EXTI line detection callbacks.
    500            * @param  GPIO_Pin Specifies the pins connected EXTI line
    501            * @retval None
    502            */

   \                                 In section .text, align 2
    503          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    504          {
    505            /* Prevent unused argument(s) compilation warning */
    506            UNUSED(GPIO_Pin);
    507            
    508            /* NOTE: This function Should not be modified, when the callback is needed,
    509                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    510             */
    511          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4002'3844        DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4001'3808        DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4002'0400        DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4002'0800        DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x4002'0C00        DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x4002'1400        DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x4002'1800        DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x4002'1C00        DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \        0x0   0x4001'3C00        DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \        0x0   0x4001'3C14        DC32     0x40013c14
    512          
    513          /**
    514            * @}
    515            */
    516          
    517          
    518          /**
    519            * @}
    520            */
    521          
    522          #endif /* HAL_GPIO_MODULE_ENABLED */
    523          /**
    524            * @}
    525            */
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      36   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       0   HAL_GPIO_EXTI_IRQHandler
         0   -> HAL_GPIO_EXTI_Callback
      36   HAL_GPIO_Init
      12   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     248  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      16  HAL_GPIO_EXTI_IRQHandler
     418  HAL_GPIO_Init
      42  HAL_GPIO_LockPin
      12  HAL_GPIO_ReadPin
      14  HAL_GPIO_TogglePin
       8  HAL_GPIO_WritePin

 
 808 bytes in section .text
 
 806 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
