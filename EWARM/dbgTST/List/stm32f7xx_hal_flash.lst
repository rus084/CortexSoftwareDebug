###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Feb/2020  21:42:17
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#    Command line =  
#        -f C:\Users\rus08\AppData\Local\Temp\EW6A96.tmp
#        (D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F723xx -lC
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -lA
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -o
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc\c\DLib_Config_Full.h"
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Include\ -Ohz)
#    Locale       =  C
#    List file    =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List\stm32f7xx_hal_flash.lst
#    Object file  =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj\stm32f7xx_hal_flash.o
#
###############################################################################

D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral Errors functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16                     
     17            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     18                 to the Flash memory. It implements the erase and program Flash memory operations 
     19                 and the read and write protection mechanisms.
     20                
     21            [..] The Flash memory interface accelerates code execution with a system of instruction
     22                 prefetch and cache lines. 
     23          
     24            [..] The FLASH main features are:
     25                (+) Flash memory read operations
     26                (+) Flash memory program/erase operations
     27                (+) Read / write protections
     28                (+) Prefetch on I-Code
     29                (+) 64 cache lines of 128 bits on I-Code
     30                (+) 8 cache lines of 128 bits on D-Code
     31                
     32                               ##### How to use this driver #####
     33            ==============================================================================
     34              [..]                             
     35                This driver provides functions and macros to configure and program the FLASH 
     36                memory of all STM32F7xx devices.
     37              
     38                (#) FLASH Memory IO Programming functions: 
     39                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     40                          HAL_FLASH_Lock() functions
     41                     (++) Program functions: byte, half word, word and double word
     42                     (++) There Two modes of programming :
     43                      (+++) Polling mode using HAL_FLASH_Program() function
     44                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     45              
     46                (#) Interrupts and flags management functions : 
     47                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     48                     (++) Wait for last FLASH operation according to its status
     49                     (++) Get error flag status by calling HAL_SetErrorCode()          
     50              [..] 
     51                In addition to these functions, this driver includes a set of macros allowing
     52                to handle the following operations:
     53                 (+) Set the latency
     54                 (+) Enable/Disable the prefetch buffer
     55                 (+) Enable/Disable the Instruction cache and the Data cache
     56                 (+) Reset the Instruction cache and the Data cache
     57                 (+) Enable/Disable the FLASH interrupts
     58                 (+) Monitor the FLASH flags status
     59              [..]	   
     60          	(@) For any Flash memory program operation (erase or program), the CPU clock frequency
     61                  (HCLK) must be at least 1MHz. 
     62          	(@) The contents of the Flash memory are not guaranteed if a device reset occurs during 
     63          	    a Flash memory operation.
     64              (@) Any attempt to read the Flash memory while it is being written or erased, causes the 
     65          	    bus to stall. Read operations are processed correctly once the program operation has 
     66          		completed. This means that code or data fetches cannot be performed while a write/erase 
     67          		operation is ongoing.
     68                    
     69            @endverbatim
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     74            * All rights reserved.</center></h2>
     75            *
     76            * This software component is licensed by ST under BSD 3-Clause license,
     77            * the "License"; You may not use this file except in compliance with the
     78            * License. You may obtain a copy of the License at:
     79            *                        opensource.org/licenses/BSD-3-Clause
     80            *
     81            ******************************************************************************
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f7xx_hal.h"
     86          
     87          /** @addtogroup STM32F7xx_HAL_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup FLASH FLASH
     92            * @brief FLASH HAL module driver
     93            * @{
     94            */
     95          
     96          #ifdef HAL_FLASH_MODULE_ENABLED
     97          
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /** @addtogroup FLASH_Private_Constants
    101            * @{
    102            */
    103          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07U)
    104          #define FLASH_TIMEOUT_VALUE       ((uint32_t)50000U)/* 50 s */
    105          /**
    106            * @}
    107            */         
    108          /* Private macro -------------------------------------------------------------*/
    109          /* Private variables ---------------------------------------------------------*/
    110          /** @addtogroup FLASH_Private_Variables
    111            * @{
    112            */
    113          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    114          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \        0x0                      DS8 28
    115          /**
    116            * @}
    117            */
    118          
    119          /* Private function prototypes -----------------------------------------------*/
    120          /** @addtogroup FLASH_Private_Functions
    121            * @{
    122            */
    123          /* Program operations */
    124          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    125          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    126          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    127          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    128          static void   FLASH_SetErrorCode(void);
    129          
    130          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    131          /**
    132            * @}
    133            */
    134          
    135          /* Exported functions --------------------------------------------------------*/
    136          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    137            * @{
    138            */
    139            
    140          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    141           *  @brief   Programming operation functions 
    142           *
    143          @verbatim   
    144           ===============================================================================
    145                            ##### Programming operation functions #####
    146           ===============================================================================  
    147              [..]
    148              This subsection provides a set of functions allowing to manage the FLASH 
    149              program operations.
    150          
    151          @endverbatim
    152            * @{
    153            */
    154          
    155          /**
    156            * @brief  Program byte, halfword, word or double word at a specified address
    157            * @param  TypeProgram  Indicate the way to program at a specified address.
    158            *                           This parameter can be a value of @ref FLASH_Type_Program
    159            * @param  Address  specifies the address to be programmed.
    160            * @param  Data specifies the data to be programmed
    161            * 
    162            * @retval HAL_StatusTypeDef HAL Status
    163            */

   \                                 In section .text, align 4, keep-with-next
    164          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    165          {
   \                     HAL_FLASH_Program: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
    166            HAL_StatusTypeDef status = HAL_ERROR;
    167            
    168            /* Process Locked */
    169            __HAL_LOCK(&pFlash);
   \        0x6   0x.... 0x....      LDR.W    R7,??DataTable12
   \        0xA   0x7D38             LDRB     R0,[R7, #+20]
   \        0xC   0x4689             MOV      R9,R1
   \        0xE   0x4614             MOV      R4,R2
   \       0x10   0x461D             MOV      R5,R3
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xBF08             IT       EQ 
   \       0x16   0x2002             MOVEQ    R0,#+2
   \       0x18   0xD029             BEQ.N    ??HAL_FLASH_Program_1
   \       0x1A   0x2101             MOVS     R1,#+1
    170          
    171            /* Check the parameters */
    172            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    173          
    174            /* Wait for last operation to be completed */
    175            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \       0x1C   0xF24C 0x3850      MOVW     R8,#+50000
   \       0x20   0x7539             STRB     R1,[R7, #+20]
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x.... 0x....      BL       FLASH_WaitForLastOperation
    176            
    177            if(status == HAL_OK)
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0xD11E             BNE.N    ??HAL_FLASH_Program_2
    178            {
    179              switch(TypeProgram)
   \       0x2C   0x2E03             CMP      R6,#+3
   \       0x2E   0x4648             MOV      R0,R9
   \       0x30   0x4622             MOV      R2,R4
   \       0x32   0x462B             MOV      R3,R5
   \       0x34   0xD811             BHI.N    ??HAL_FLASH_Program_3
   \       0x36   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??HAL_FLASH_Program_0:
   \       0x3A   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
    180              {
    181                case FLASH_TYPEPROGRAM_BYTE :
    182                {
    183                  /*Program byte (8-bit) at a specified address.*/
    184                  FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_4: (+1)
   \       0x3E   0xB2D1             UXTB     R1,R2
   \       0x40   0x.... 0x....      BL       FLASH_Program_Byte
    185                  break;
   \       0x44   0xE009             B.N      ??HAL_FLASH_Program_3
    186                }
    187                
    188                case FLASH_TYPEPROGRAM_HALFWORD :
    189                {
    190                  /*Program halfword (16-bit) at a specified address.*/
    191                  FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_5: (+1)
   \       0x46   0xB291             UXTH     R1,R2
   \       0x48   0x.... 0x....      BL       FLASH_Program_HalfWord
    192                  break;
   \       0x4C   0xE005             B.N      ??HAL_FLASH_Program_3
    193                }
    194                
    195                case FLASH_TYPEPROGRAM_WORD :
    196                {
    197                  /*Program word (32-bit) at a specified address.*/
    198                  FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_6: (+1)
   \       0x4E   0x4611             MOV      R1,R2
   \       0x50   0x.... 0x....      BL       FLASH_Program_Word
    199                  break;
   \       0x54   0xE001             B.N      ??HAL_FLASH_Program_3
    200                }
    201                
    202                case FLASH_TYPEPROGRAM_DOUBLEWORD :
    203                {
    204                  /*Program double word (64-bit) at a specified address.*/
    205                  FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_7: (+1)
   \       0x56   0x.... 0x....      BL       FLASH_Program_DoubleWord
    206                  break;
    207                }
    208                default :
    209                  break;
    210              }
    211              /* Wait for last operation to be completed */
    212              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_3: (+1)
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x.... 0x....      BL       FLASH_WaitForLastOperation
    213              
    214              /* If the program operation is completed, disable the PG Bit */
    215              FLASH->CR &= (~FLASH_CR_PG);
   \       0x60   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023c10
   \       0x62   0x680A             LDR      R2,[R1, #+0]
   \       0x64   0x0852             LSRS     R2,R2,#+1
   \       0x66   0x0052             LSLS     R2,R2,#+1
   \       0x68   0x600A             STR      R2,[R1, #+0]
    216            }
    217          
    218            /* Process Unlocked */
    219            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0x7539             STRB     R1,[R7, #+20]
    220          
    221            return status;
   \                     ??HAL_FLASH_Program_1: (+1)
   \       0x6E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    222          }
    223          
    224          /**
    225            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    226            * @param  TypeProgram  Indicate the way to program at a specified address.
    227            *                           This parameter can be a value of @ref FLASH_Type_Program
    228            * @param  Address  specifies the address to be programmed.
    229            * @param  Data specifies the data to be programmed
    230            * 
    231            * @retval HAL Status
    232            */

   \                                 In section .text, align 4, keep-with-next
    233          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    234          {
   \                     HAL_FLASH_Program_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
    235            HAL_StatusTypeDef status = HAL_OK;
    236            
    237            /* Process Locked */
    238            __HAL_LOCK(&pFlash);
   \        0x6   0x....             LDR.N    R1,??DataTable12
   \        0x8   0x7D0D             LDRB     R5,[R1, #+20]
   \        0xA   0x2D01             CMP      R5,#+1
   \        0xC   0xD101             BNE.N    ??HAL_FLASH_Program_IT_1
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \       0x12   0x2601             MOVS     R6,#+1
    239          
    240            /* Check the parameters */
    241            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    242          
    243            /* Enable End of FLASH Operation interrupt */
    244            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \       0x14   0x....             LDR.N    R5,??DataTable12_2  ;; 0x40023c0c
   \       0x16   0x750E             STRB     R6,[R1, #+20]
   \       0x18   0x686F             LDR      R7,[R5, #+4]
   \       0x1A   0xF047 0x7780      ORR      R7,R7,#0x1000000
   \       0x1E   0x606F             STR      R7,[R5, #+4]
    245            
    246            /* Enable Error source interrupt */
    247            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \       0x20   0x686E             LDR      R6,[R5, #+4]
    248            
    249            /* Clear pending flags (if any) */  
    250            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
    251                                   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
   \       0x22   0x27F3             MOVS     R7,#+243
   \       0x24   0xF046 0x7600      ORR      R6,R6,#0x2000000
   \       0x28   0x606E             STR      R6,[R5, #+4]
   \       0x2A   0x602F             STR      R7,[R5, #+0]
    252          
    253            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \       0x2C   0x2503             MOVS     R5,#+3
    254            pFlash.Address = Address;
    255            
    256            switch(TypeProgram)
   \       0x2E   0x2C03             CMP      R4,#+3
   \       0x30   0x700D             STRB     R5,[R1, #+0]
   \       0x32   0x6108             STR      R0,[R1, #+16]
   \       0x34   0xD811             BHI.N    ??HAL_FLASH_Program_IT_2
   \       0x36   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??HAL_FLASH_Program_IT_0:
   \       0x3A   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
    257            {
    258              case FLASH_TYPEPROGRAM_BYTE :
    259              {
    260                /*Program byte (8-bit) at a specified address.*/
    261                FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \       0x3E   0xB2D1             UXTB     R1,R2
   \       0x40   0x.... 0x....      BL       FLASH_Program_Byte
    262                break;
   \       0x44   0xE009             B.N      ??HAL_FLASH_Program_IT_2
    263              }
    264              
    265              case FLASH_TYPEPROGRAM_HALFWORD :
    266              {
    267                /*Program halfword (16-bit) at a specified address.*/
    268                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \       0x46   0xB291             UXTH     R1,R2
   \       0x48   0x.... 0x....      BL       FLASH_Program_HalfWord
    269                break;
   \       0x4C   0xE005             B.N      ??HAL_FLASH_Program_IT_2
    270              }
    271              
    272              case FLASH_TYPEPROGRAM_WORD :
    273              {
    274                /*Program word (32-bit) at a specified address.*/
    275                FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \       0x4E   0x4611             MOV      R1,R2
   \       0x50   0x.... 0x....      BL       FLASH_Program_Word
    276                break;
   \       0x54   0xE001             B.N      ??HAL_FLASH_Program_IT_2
    277              }
    278              
    279              case FLASH_TYPEPROGRAM_DOUBLEWORD :
    280              {
    281                /*Program double word (64-bit) at a specified address.*/
    282                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_6: (+1)
   \       0x56   0x.... 0x....      BL       FLASH_Program_DoubleWord
    283                break;
    284              }
    285              default :
    286                break;
    287            }
    288            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    289          }
    290          
    291          /**
    292            * @brief This function handles FLASH interrupt request.
    293            * @retval None
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          void HAL_FLASH_IRQHandler(void)
    296          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    297            uint32_t temp = 0;
    298            
    299            /* If the program operation is completed, disable the PG Bit */
    300            FLASH->CR &= (~FLASH_CR_PG);
   \        0x2   0x....             LDR.N    R4,??DataTable12_2  ;; 0x40023c0c
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x6860             LDR      R0,[R4, #+4]
    301          
    302            /* If the erase operation is completed, disable the SER Bit */
    303            FLASH->CR &= (~FLASH_CR_SER);
    304            FLASH->CR &= SECTOR_MASK; 
    305          
    306            /* if the erase operation is completed, disable the MER Bit */
    307            FLASH->CR &= (~FLASH_MER_BIT);
    308          
    309            /* Check FLASH End of Operation flag  */
    310            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \        0x8   0xF04F 0x37FF      MOV      R7,#-1
   \        0xC   0x....             LDR.N    R6,??DataTable12
   \        0xE   0x0840             LSRS     R0,R0,#+1
   \       0x10   0x0040             LSLS     R0,R0,#+1
   \       0x12   0x6060             STR      R0,[R4, #+4]
   \       0x14   0x6861             LDR      R1,[R4, #+4]
   \       0x16   0xF021 0x0102      BIC      R1,R1,#0x2
   \       0x1A   0x6061             STR      R1,[R4, #+4]
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0xF020 0x00F8      BIC      R0,R0,#0xF8
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0x6861             LDR      R1,[R4, #+4]
   \       0x26   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x2A   0x6061             STR      R1,[R4, #+4]
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x07C1             LSLS     R1,R0,#+31
   \       0x30   0xD527             BPL.N    ??HAL_FLASH_IRQHandler_0
    311            {
    312              /* Clear FLASH End of Operation pending bit */
    313              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x32   0x2201             MOVS     R2,#+1
   \       0x34   0x6022             STR      R2,[R4, #+0]
    314              
    315              switch (pFlash.ProcedureOnGoing)
   \       0x36   0x7833             LDRB     R3,[R6, #+0]
   \       0x38   0x2B01             CMP      R3,#+1
   \       0x3A   0xD004             BEQ.N    ??HAL_FLASH_IRQHandler_1
   \       0x3C   0xD321             BCC.N    ??HAL_FLASH_IRQHandler_0
   \       0x3E   0x2B03             CMP      R3,#+3
   \       0x40   0xD01B             BEQ.N    ??HAL_FLASH_IRQHandler_2
   \       0x42   0xD318             BCC.N    ??HAL_FLASH_IRQHandler_3
   \       0x44   0xE01D             B.N      ??HAL_FLASH_IRQHandler_0
    316              {
    317                case FLASH_PROC_SECTERASE :
    318                {
    319                  /* Nb of sector to erased can be decreased */
    320                  pFlash.NbSectorsToErase--;
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \       0x46   0x6871             LDR      R1,[R6, #+4]
   \       0x48   0x1E49             SUBS     R1,R1,#+1
   \       0x4A   0x6071             STR      R1,[R6, #+4]
    321          
    322                  /* Check if there are still sectors to erase */
    323                  if(pFlash.NbSectorsToErase != 0)
   \       0x4C   0x6870             LDR      R0,[R6, #+4]
   \       0x4E   0xB150             CBZ.N    R0,??HAL_FLASH_IRQHandler_4
    324                  {
    325                    temp = pFlash.Sector;
   \       0x50   0x68F0             LDR      R0,[R6, #+12]
    326                    /* Indicate user which sector has been erased */
    327                    HAL_FLASH_EndOfOperationCallback(temp);
   \       0x52   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    328          
    329                    /* Increment sector number */
    330                    temp = ++pFlash.Sector;
   \       0x56   0x68F5             LDR      R5,[R6, #+12]
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
    331                    FLASH_Erase_Sector(temp, pFlash.VoltageForErase);
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x60F5             STR      R5,[R6, #+12]
   \       0x5E   0x7A31             LDRB     R1,[R6, #+8]
   \       0x60   0x.... 0x....      BL       FLASH_Erase_Sector
   \       0x64   0xE00D             B.N      ??HAL_FLASH_IRQHandler_0
    332                  }
    333                  else
    334                  {
    335                    /* No more sectors to Erase, user callback can be called.*/
    336                    /* Reset Sector and stop Erase sectors procedure */
    337                    pFlash.Sector = temp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \       0x66   0x463D             MOV      R5,R7
   \       0x68   0x60F7             STR      R7,[R6, #+12]
    338                    /* FLASH EOP interrupt user callback */
    339                    HAL_FLASH_EndOfOperationCallback(temp);
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    340                    /* Sector Erase procedure is completed */
    341                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7030             STRB     R0,[R6, #+0]
   \       0x74   0xE005             B.N      ??HAL_FLASH_IRQHandler_0
    342                  }
    343                  break;
    344                }
    345              
    346                case FLASH_PROC_MASSERASE :
    347                {
    348                  /* MassErase ended. Return the selected bank : in this product we don't have Banks */
    349                  /* FLASH EOP interrupt user callback */
    350                  HAL_FLASH_EndOfOperationCallback(0);
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE000             B.N      ??HAL_FLASH_IRQHandler_5
    351                  /* MAss Erase procedure is completed */
    352                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    353                  break;
    354                }
    355          
    356                case FLASH_PROC_PROGRAM :
    357                {
    358                  /*Program ended. Return the selected address*/
    359                  /* FLASH EOP interrupt user callback */
    360                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \       0x7A   0x6930             LDR      R0,[R6, #+16]
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \       0x7C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    361                  /* Programming procedure is completed */
    362                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x80   0x7035             STRB     R5,[R6, #+0]
    363                  break;
    364                }
    365                default :
    366                  break;
    367              }
    368            }
    369            
    370            /* Check FLASH operation error flags */
    371            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0xF411 0x7FF9      TST      R1,#0x1F2
   \       0x88   0xD013             BEQ.N    ??HAL_FLASH_IRQHandler_6
    372            {
    373              switch (pFlash.ProcedureOnGoing)
   \       0x8A   0x7830             LDRB     R0,[R6, #+0]
   \       0x8C   0x2801             CMP      R0,#+1
   \       0x8E   0xD005             BEQ.N    ??HAL_FLASH_IRQHandler_7
   \       0x90   0xD308             BCC.N    ??HAL_FLASH_IRQHandler_8
   \       0x92   0x2803             CMP      R0,#+3
   \       0x94   0xD005             BEQ.N    ??HAL_FLASH_IRQHandler_9
   \       0x96   0xBF38             IT       CC 
   \       0x98   0x2500             MOVCC    R5,#+0
    374              {
    375                case FLASH_PROC_SECTERASE :
    376                {
    377                  /* return the faulty sector */
    378                  temp = pFlash.Sector;
    379                  pFlash.Sector = 0xFFFFFFFFU;
    380                  break;
    381                }
    382                case FLASH_PROC_MASSERASE :
    383                {
    384                  /* No return in case of Mass Erase */
    385                  temp = 0;
   \       0x9A   0xE003             B.N      ??HAL_FLASH_IRQHandler_8
    386                  break;
    387                }
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \       0x9C   0x68F5             LDR      R5,[R6, #+12]
   \       0x9E   0x60F7             STR      R7,[R6, #+12]
   \       0xA0   0xE000             B.N      ??HAL_FLASH_IRQHandler_8
    388                case FLASH_PROC_PROGRAM :
    389                {
    390                  /*return the faulty address*/
    391                  temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \       0xA2   0x6935             LDR      R5,[R6, #+16]
    392                  break;
    393                }
    394              default :
    395                break;
    396              }
    397              /*Save the Error code*/
    398              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \       0xA4   0x.... 0x....      BL       FLASH_SetErrorCode
    399          
    400              /* FLASH error interrupt user callback */
    401              HAL_FLASH_OperationErrorCallback(temp);
   \       0xA8   0x4628             MOV      R0,R5
   \       0xAA   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    402          
    403              /*Stop the procedure ongoing */
    404              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0xAE   0x2100             MOVS     R1,#+0
   \       0xB0   0x7031             STRB     R1,[R6, #+0]
    405            }
    406            
    407            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \       0xB2   0x7830             LDRB     R0,[R6, #+0]
   \       0xB4   0xB948             CBNZ.N   R0,??HAL_FLASH_IRQHandler_10
    408            {
    409              /* Disable End of FLASH Operation interrupt */
    410              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \       0xB6   0x6861             LDR      R1,[R4, #+4]
   \       0xB8   0xF021 0x7180      BIC      R1,R1,#0x1000000
   \       0xBC   0x6061             STR      R1,[R4, #+4]
    411          
    412              /* Disable Error source interrupt */
    413              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \       0xBE   0x6860             LDR      R0,[R4, #+4]
    414          
    415              /* Process Unlocked */
    416              __HAL_UNLOCK(&pFlash);
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0xF020 0x7000      BIC      R0,R0,#0x2000000
   \       0xC6   0x6060             STR      R0,[R4, #+4]
   \       0xC8   0x7531             STRB     R1,[R6, #+20]
    417            }
    418            
    419          }
   \                     ??HAL_FLASH_IRQHandler_10: (+1)
   \       0xCA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    420          
    421          /**
    422            * @brief  FLASH end of operation interrupt callback
    423            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    424            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    425            *                                  all the selected sectors have been erased)
    426            *                 - Program      : Address which was selected for data program
    427            *                 - Mass Erase   : No return value expected
    428            * @retval None
    429            */

   \                                 In section .text, align 2
    430          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    431          {
    432            /* Prevent unused argument(s) compilation warning */
    433            UNUSED(ReturnValue);
    434            /* NOTE : This function Should not be modified, when the callback is needed,
    435            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    436            */ 
    437          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    438          
    439          /**
    440            * @brief  FLASH operation error interrupt callback
    441            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    442            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    443            *                                  all the selected sectors have been erased)
    444            *                 - Program      : Address which was selected for data program
    445            *                 - Mass Erase   : No return value expected
    446            * @retval None
    447            */

   \                                 In section .text, align 2
    448          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    449          {
    450            /* Prevent unused argument(s) compilation warning */
    451            UNUSED(ReturnValue);
    452            /* NOTE : This function Should not be modified, when the callback is needed,
    453            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    454             */ 
    455          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    456          
    457          /**
    458            * @}
    459            */
    460          
    461          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    462           *  @brief   management functions 
    463           *
    464          @verbatim   
    465           ===============================================================================
    466                                ##### Peripheral Control functions #####
    467           ===============================================================================  
    468              [..]
    469              This subsection provides a set of functions allowing to control the FLASH 
    470              memory operations.
    471          
    472          @endverbatim
    473            * @{
    474            */
    475          
    476          /**
    477            * @brief  Unlock the FLASH control register access
    478            * @retval HAL Status
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    481          {
   \                     HAL_FLASH_Unlock: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023c04
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x68CA             LDR      R2,[R1, #+12]
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD400             BMI.N    ??HAL_FLASH_Unlock_0
   \        0xA   0x4770             BX       LR
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \        0xC   0xB530             PUSH     {R4,R5,LR}
    482            HAL_StatusTypeDef status = HAL_OK;
    483          
    484            if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
    485            {
    486              /* Authorize the FLASH Registers access */
    487              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
   \        0xE   0x....             LDR.N    R4,??DataTable12_4  ;; 0x45670123
    488              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
   \       0x10   0x....             LDR.N    R5,??DataTable12_5  ;; 0xcdef89ab
   \       0x12   0x600C             STR      R4,[R1, #+0]
   \       0x14   0x600D             STR      R5,[R1, #+0]
    489          
    490              /* Verify Flash is unlocked */
    491              if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \       0x16   0x68C9             LDR      R1,[R1, #+12]
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xBF48             IT       MI 
   \       0x1C   0x2001             MOVMI    R0,#+1
    492              {
    493                status = HAL_ERROR;
    494              }
    495            }
    496          
    497            return status;
   \       0x1E   0xBD30             POP      {R4,R5,PC}       ;; return
    498          }
    499          
    500          /**
    501            * @brief  Locks the FLASH control register access
    502            * @retval HAL Status
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    505          {
    506            /* Set the LOCK Bit to lock the FLASH Registers access */
    507            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40023c10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \        0x8   0x....             B.N      ?Subroutine1
    508            
    509            return HAL_OK;  
    510          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR               ;; return
    511          
    512          /**
    513            * @brief  Unlock the FLASH Option Control Registers access.
    514            * @retval HAL Status
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    517          {
   \                     HAL_FLASH_OB_Unlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    518            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \        0x2   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023c08
   \        0x4   0x68C1             LDR      R1,[R0, #+12]
   \        0x6   0x07CA             LSLS     R2,R1,#+31
   \        0x8   0xD505             BPL.N    ??HAL_FLASH_OB_Unlock_0
    519            {
    520              /* Authorizes the Option Byte register programming */
    521              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \        0xA   0x....             LDR.N    R3,??DataTable12_7  ;; 0x8192a3b
    522              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \        0xC   0x....             LDR.N    R4,??DataTable12_8  ;; 0x4c5d6e7f
   \        0xE   0x6003             STR      R3,[R0, #+0]
   \       0x10   0x6004             STR      R4,[R0, #+0]
    523            }
    524            else
    525            {
    526              return HAL_ERROR;
    527            }  
    528            
    529            return HAL_OK;  
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD10             POP      {R4,PC}
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    530          }
    531          
    532          /**
    533            * @brief  Lock the FLASH Option Control Registers access.
    534            * @retval HAL Status 
    535            */

   \                                 In section .text, align 2, keep-with-next
    536          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    537          {
    538            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    539            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40023c14
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x8                      REQUIRE ?Subroutine1
   \        0x8                      ;; // Fall through to label ?Subroutine1
    540            
    541            return HAL_OK;  
    542          }
    543          
    544          /**
    545            * @brief  Launch the option byte loading.
    546            * @retval HAL Status
    547            */

   \                                 In section .text, align 2, keep-with-next
    548          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    549          {
    550            /* Set the OPTSTRT bit in OPTCR register */
    551            FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;
   \                     HAL_FLASH_OB_Launch: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40023c14
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    552          
    553            /* Wait for last operation to be completed */
    554            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \        0xA   0xF24C 0x3050      MOVW     R0,#+50000
   \        0xE   0x....             B.N      FLASH_WaitForLastOperation
    555          }
    556          
    557          /**
    558            * @}
    559            */
    560          
    561          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    562           *  @brief   Peripheral Errors functions 
    563           *
    564          @verbatim   
    565           ===============================================================================
    566                          ##### Peripheral Errors functions #####
    567           ===============================================================================  
    568              [..]
    569              This subsection permits to get in run-time Errors of the FLASH peripheral.
    570          
    571          @endverbatim
    572            * @{
    573            */
    574          
    575          /**
    576            * @brief  Get the specific FLASH error flag.
    577            * @retval FLASH_ErrorCode: The returned value can be:
    578            *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag 
    579            *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    580            *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    581            *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
    582            *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
    583            */

   \                                 In section .text, align 2, keep-with-next
    584          uint32_t HAL_FLASH_GetError(void)
    585          { 
    586             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   \        0x4   0x4770             BX       LR               ;; return
    587          }  
    588            
    589          /**
    590            * @}
    591            */    
    592          
    593          /**
    594            * @brief  Wait for a FLASH operation to complete.
    595            * @param  Timeout maximum flash operationtimeout
    596            * @retval HAL Status
    597            */

   \                                 In section .text, align 2, keep-with-next
    598          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    599          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    600            uint32_t tickstart = 0;
    601            
    602            /* Clear Error Code */
    603            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR.N    R1,??DataTable12
   \        0x8   0x....             LDR.N    R5,??DataTable12_2  ;; 0x40023c0c
   \        0xA   0x6188             STR      R0,[R1, #+24]
    604            
    605            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    606               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    607               flag will be set */
    608            /* Get tick */
    609            tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4606             MOV      R6,R0
    610          
    611            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x03C1             LSLS     R1,R0,#+15
   \       0x16   0xD511             BPL.N    ??FLASH_WaitForLastOperation_1
    612            { 
    613              if(Timeout != HAL_MAX_DELAY)
   \       0x18   0xF114 0x0F01      CMN      R4,#+1
   \       0x1C   0xD0F9             BEQ.N    ??FLASH_WaitForLastOperation_0
    614              {
    615                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \       0x1E   0xB124             CBZ.N    R4,??FLASH_WaitForLastOperation_2
   \       0x20   0x.... 0x....      BL       HAL_GetTick
   \       0x24   0x1B80             SUBS     R0,R0,R6
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD2F3             BCS.N    ??FLASH_WaitForLastOperation_0
    616                {
    617                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0xBD70             POP      {R4-R6,PC}
    618                }
    619              } 
    620            }
    621            
    622            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
    623            {
    624              /*Save the error code*/
    625              FLASH_SetErrorCode();
    626              return HAL_ERROR;
    627            }
    628            
    629            /* Check FLASH End of Operation flag  */
    630            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x07C1             LSLS     R1,R0,#+31
   \       0x32   0xBF44             ITT      MI 
   \       0x34   0x2201             MOVMI    R2,#+1
   \       0x36   0x602A             STRMI    R2,[R5, #+0]
    631            {
    632              /* Clear FLASH End of Operation pending bit */
    633              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    634            }
    635          
    636            /* If there is an error flag set */
    637            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0xF410 0x7FF9      TST      R0,#0x1F2
   \       0x42   0xD0F4             BEQ.N    ??FLASH_WaitForLastOperation_3
   \       0x44   0x.... 0x....      BL       FLASH_SetErrorCode
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xBD70             POP      {R4-R6,PC}
    638            
    639          }  
    640          
    641          /**
    642            * @brief  Program a double word (64-bit) at a specified address.
    643            * @note   This function must be used when the device voltage range is from
    644            *         2.7V to 3.6V and an External Vpp is present.
    645            *
    646            * @note   If an erase and a program operations are requested simultaneously,    
    647            *         the erase operation is performed before the program one.
    648            *  
    649            * @param  Address specifies the address to be programmed.
    650            * @param  Data specifies the data to be programmed.
    651            * @retval None
    652            */

   \                                 In section .text, align 2, keep-with-next
    653          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    654          {
   \                     FLASH_Program_DoubleWord: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    655            /* Check the parameters */
    656            assert_param(IS_FLASH_ADDRESS(Address));
    657            
    658            /* If the previous operation is completed, proceed to program the new data */
    659            FLASH->CR &= CR_PSIZE_MASK;
   \        0x2   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023c10
   \        0x4   0x680C             LDR      R4,[R1, #+0]
   \        0x6   0xF424 0x7440      BIC      R4,R4,#0x300
   \        0xA   0x600C             STR      R4,[R1, #+0]
    660            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \        0xC   0x680D             LDR      R5,[R1, #+0]
   \        0xE   0xF445 0x7540      ORR      R5,R5,#0x300
   \       0x12   0x600D             STR      R5,[R1, #+0]
    661            FLASH->CR |= FLASH_CR_PG;
   \       0x14   0x680E             LDR      R6,[R1, #+0]
   \       0x16   0xF046 0x0601      ORR      R6,R6,#0x1
   \       0x1A   0x600E             STR      R6,[R1, #+0]
    662          
    663            /* Program the double-word */
    664            *(__IO uint32_t*)Address = (uint32_t)Data;
   \       0x1C   0xF840 0x2B04      STR      R2,[R0], #+4
    665            *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
   \       0x20   0x6003             STR      R3,[R0, #+0]
    666          
    667            /* Data synchronous Barrier (DSB) Just after the write operation
    668               This will force the CPU to respect the sequence of instruction (no optimization).*/
    669            __DSB();
   \       0x22   0xF3BF 0x8F4F      DSB      SY
    670          }
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    671          
    672          
    673          /**
    674            * @brief  Program word (32-bit) at a specified address.
    675            * @note   This function must be used when the device voltage range is from
    676            *         2.7V to 3.6V.
    677            *
    678            * @note   If an erase and a program operations are requested simultaneously,    
    679            *         the erase operation is performed before the program one.
    680            *  
    681            * @param  Address specifies the address to be programmed.
    682            * @param  Data specifies the data to be programmed.
    683            * @retval None
    684            */

   \                                 In section .text, align 2, keep-with-next
    685          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    686          {
   \                     FLASH_Program_Word: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    687            /* Check the parameters */
    688            assert_param(IS_FLASH_ADDRESS(Address));
    689            
    690            /* If the previous operation is completed, proceed to program the new data */
    691            FLASH->CR &= CR_PSIZE_MASK;
   \        0x2   0x.... 0x....      BL       ?Subroutine2
    692            FLASH->CR |= FLASH_PSIZE_WORD;
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0xF444 0x7400      ORR      R4,R4,#0x200
   \        0xA   0x.... 0x....      BL       ?Subroutine3
    693            FLASH->CR |= FLASH_CR_PG;
    694          
    695            *(__IO uint32_t*)Address = Data;
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0x6001             STR      R1,[R0, #+0]
    696            
    697            /* Data synchronous Barrier (DSB) Just after the write operation
    698               This will force the CPU to respect the sequence of instruction (no optimization).*/
    699            __DSB();
   \       0x10   0x....             B.N      ?Subroutine0
    700          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF3BF 0x8F4F      DSB      SY
   \        0x4   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6014             STR      R4,[R2, #+0]
   \        0x2   0x6815             LDR      R5,[R2, #+0]
   \        0x4   0xF045 0x0501      ORR      R5,R5,#0x1
   \        0x8   0x6015             STR      R5,[R2, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023c10
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xF423 0x7340      BIC      R3,R3,#0x300
   \        0x8   0x6013             STR      R3,[R2, #+0]
   \        0xA   0x6814             LDR      R4,[R2, #+0]
   \        0xC   0x4770             BX       LR
    701          
    702          /**
    703            * @brief  Program a half-word (16-bit) at a specified address.
    704            * @note   This function must be used when the device voltage range is from
    705            *         2.7V to 3.6V.
    706            *
    707            * @note   If an erase and a program operations are requested simultaneously,    
    708            *         the erase operation is performed before the program one.
    709            *  
    710            * @param  Address specifies the address to be programmed.
    711            * @param  Data specifies the data to be programmed.
    712            * @retval None
    713            */

   \                                 In section .text, align 2, keep-with-next
    714          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    715          {
   \                     FLASH_Program_HalfWord: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    716            /* Check the parameters */
    717            assert_param(IS_FLASH_ADDRESS(Address));
    718            
    719            /* If the previous operation is completed, proceed to program the new data */
    720            FLASH->CR &= CR_PSIZE_MASK;
   \        0x2   0x.... 0x....      BL       ?Subroutine2
    721            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xF444 0x7480      ORR      R4,R4,#0x100
   \        0xA   0x.... 0x....      BL       ?Subroutine3
    722            FLASH->CR |= FLASH_CR_PG;
    723          
    724            *(__IO uint16_t*)Address = Data;
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xE   0x8001             STRH     R1,[R0, #+0]
    725          
    726            /* Data synchronous Barrier (DSB) Just after the write operation
    727               This will force the CPU to respect the sequence of instruction (no optimization).*/
    728            __DSB();
   \       0x10                      REQUIRE ?Subroutine0
   \       0x10                      ;; // Fall through to label ?Subroutine0
    729            
    730          }
    731          
    732          /**
    733            * @brief  Program byte (8-bit) at a specified address.
    734            * @note   This function must be used when the device voltage range is from
    735            *         2.7V to 3.6V.
    736            *
    737            * @note   If an erase and a program operations are requested simultaneously,    
    738            *         the erase operation is performed before the program one.
    739            *  
    740            * @param  Address specifies the address to be programmed.
    741            * @param  Data specifies the data to be programmed.
    742            * @retval None
    743            */

   \                                 In section .text, align 2, keep-with-next
    744          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    745          {
   \                     FLASH_Program_Byte: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    746            /* Check the parameters */
    747            assert_param(IS_FLASH_ADDRESS(Address));
    748            
    749            /* If the previous operation is completed, proceed to program the new data */
    750            FLASH->CR &= CR_PSIZE_MASK;
   \        0x2   0x.... 0x....      BL       ?Subroutine2
    751            FLASH->CR |= FLASH_PSIZE_BYTE;
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x6   0x.... 0x....      BL       ?Subroutine3
    752            FLASH->CR |= FLASH_CR_PG;
    753          
    754            *(__IO uint8_t*)Address = Data;
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xA   0x7001             STRB     R1,[R0, #+0]
    755          
    756            /* Data synchronous Barrier (DSB) Just after the write operation
    757               This will force the CPU to respect the sequence of instruction (no optimization).*/
    758            __DSB();
   \        0xC   0x....             B.N      ?Subroutine0
    759          }
    760          
    761          /**
    762            * @brief  Set the specific FLASH error flag.
    763            * @retval None
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          static void FLASH_SetErrorCode(void)
    766          {
   \                     FLASH_SetErrorCode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    767            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023c0c
   \        0x4   0x....             LDR.N    R0,??DataTable12
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x0793             LSLS     R3,R2,#+30
   \        0xA   0xD503             BPL.N    ??FLASH_SetErrorCode_0
    768            {
    769              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \        0xC   0x6984             LDR      R4,[R0, #+24]
   \        0xE   0xF044 0x0420      ORR      R4,R4,#0x20
   \       0x12   0x6184             STR      R4,[R0, #+24]
    770            }
    771            
    772            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x06D3             LSLS     R3,R2,#+27
   \       0x18   0xD503             BPL.N    ??FLASH_SetErrorCode_1
    773            {
    774             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \       0x1A   0x6984             LDR      R4,[R0, #+24]
   \       0x1C   0xF044 0x0410      ORR      R4,R4,#0x10
   \       0x20   0x6184             STR      R4,[R0, #+24]
    775            }
    776            
    777            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \       0x22   0x680A             LDR      R2,[R1, #+0]
   \       0x24   0x0693             LSLS     R3,R2,#+26
   \       0x26   0xD503             BPL.N    ??FLASH_SetErrorCode_2
    778            {
    779             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \       0x28   0x6984             LDR      R4,[R0, #+24]
   \       0x2A   0xF044 0x0408      ORR      R4,R4,#0x8
   \       0x2E   0x6184             STR      R4,[R0, #+24]
    780            }
    781            
    782            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \       0x30   0x680A             LDR      R2,[R1, #+0]
   \       0x32   0x0653             LSLS     R3,R2,#+25
   \       0x34   0xD503             BPL.N    ??FLASH_SetErrorCode_3
    783            {
    784              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \       0x36   0x6984             LDR      R4,[R0, #+24]
   \       0x38   0xF044 0x0404      ORR      R4,R4,#0x4
   \       0x3C   0x6184             STR      R4,[R0, #+24]
    785            }
    786            
    787            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \       0x3E   0x680A             LDR      R2,[R1, #+0]
   \       0x40   0x0613             LSLS     R3,R2,#+24
   \       0x42   0xD503             BPL.N    ??FLASH_SetErrorCode_4
    788            {
    789              pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
   \       0x44   0x6984             LDR      R4,[R0, #+24]
   \       0x46   0xF044 0x0402      ORR      R4,R4,#0x2
   \       0x4A   0x6184             STR      R4,[R0, #+24]
    790            }
    791            
    792          #if defined (FLASH_OPTCR2_PCROP)
    793            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
   \                     ??FLASH_SetErrorCode_4: (+1)
   \       0x4C   0x680A             LDR      R2,[R1, #+0]
   \       0x4E   0x05D3             LSLS     R3,R2,#+23
   \       0x50   0xD503             BPL.N    ??FLASH_SetErrorCode_5
    794            { 
    795             pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
   \       0x52   0x6984             LDR      R4,[R0, #+24]
   \       0x54   0xF044 0x0440      ORR      R4,R4,#0x40
   \       0x58   0x6184             STR      R4,[R0, #+24]
    796            }  
    797          #endif /* FLASH_OPTCR2_PCROP */
    798            
    799            /* Clear error programming flags */
    800            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
   \                     ??FLASH_SetErrorCode_5: (+1)
   \       0x5A   0xF44F 0x70F9      MOV      R0,#+498
   \       0x5E   0x6008             STR      R0,[R1, #+0]
    801          }
   \       0x60   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4002'3C10        DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x4002'3C0C        DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x4002'3C04        DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x4002'3C08        DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x0819'2A3B        DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x4C5D'6E7F        DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x4002'3C14        DC32     0x40023c14
    802          
    803          /**
    804            * @}
    805            */
    806          
    807          #endif /* HAL_FLASH_MODULE_ENABLED */
    808          
    809          /**
    810            * @}
    811            */
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   FLASH_Program_Byte
      16   FLASH_Program_DoubleWord
      12   FLASH_Program_HalfWord
      12   FLASH_Program_Word
       8   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      24   HAL_FLASH_IRQHandler
        24   -> FLASH_Erase_Sector
        24   -> FLASH_SetErrorCode
        24   -> HAL_FLASH_EndOfOperationCallback
        24   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       0   HAL_FLASH_OB_Launch
         0   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       8   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      32   HAL_FLASH_Program
        32   -> FLASH_Program_Byte
        32   -> FLASH_Program_DoubleWord
        32   -> FLASH_Program_HalfWord
        32   -> FLASH_Program_Word
        32   -> FLASH_WaitForLastOperation
      24   HAL_FLASH_Program_IT
        24   -> FLASH_Program_Byte
        24   -> FLASH_Program_DoubleWord
        24   -> FLASH_Program_HalfWord
        24   -> FLASH_Program_Word
      12   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       6  ?Subroutine0
       6  ?Subroutine1
      14  ?Subroutine2
      12  ?Subroutine3
      14  FLASH_Program_Byte
      40  FLASH_Program_DoubleWord
      16  FLASH_Program_HalfWord
      18  FLASH_Program_Word
      98  FLASH_SetErrorCode
      76  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     204  HAL_FLASH_IRQHandler
      10  HAL_FLASH_Lock
      16  HAL_FLASH_OB_Launch
       8  HAL_FLASH_OB_Lock
      26  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     114  HAL_FLASH_Program
      94  HAL_FLASH_Program_IT
      32  HAL_FLASH_Unlock
      28  pFlash

 
  28 bytes in section .bss
 854 bytes in section .text
 
 850 bytes of CODE memory (+ 4 bytes shared)
  28 bytes of DATA memory

Errors: none
Warnings: none
