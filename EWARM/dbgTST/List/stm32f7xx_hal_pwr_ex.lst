###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Feb/2020  21:42:23
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#    Command line =  
#        -f C:\Users\rus08\AppData\Local\Temp\EW82F7.tmp
#        (D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#        -D USE_HAL_DRIVER -D STM32F723xx -lC
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -lA
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -o
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc\c\DLib_Config_Full.h"
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Include\ -Ohz)
#    Locale       =  C
#    List file    =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List\stm32f7xx_hal_pwr_ex.lst
#    Object file  =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj\stm32f7xx_hal_pwr_ex.o
#
###############################################################################

D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pwr_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended PWR HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of PWR extension peripheral:           
      8            *           + Peripheral Extended features functions
      9            *         
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     14            * All rights reserved.</center></h2>
     15            *
     16            * This software component is licensed by ST under BSD 3-Clause license,
     17            * the "License"; You may not use this file except in compliance with the
     18            * License. You may obtain a copy of the License at:
     19            *                        opensource.org/licenses/BSD-3-Clause
     20            *
     21            ******************************************************************************
     22            */ 
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "stm32f7xx_hal.h"
     26          
     27          /** @addtogroup STM32F7xx_HAL_Driver
     28            * @{
     29            */
     30          
     31          /** @defgroup PWREx PWREx
     32            * @brief PWR HAL module driver
     33            * @{
     34            */
     35          
     36          #ifdef HAL_PWR_MODULE_ENABLED
     37          
     38          /* Private typedef -----------------------------------------------------------*/
     39          /* Private define ------------------------------------------------------------*/
     40          /** @addtogroup PWREx_Private_Constants
     41            * @{
     42            */    
     43          #define PWR_OVERDRIVE_TIMEOUT_VALUE  1000
     44          #define PWR_UDERDRIVE_TIMEOUT_VALUE  1000
     45          #define PWR_BKPREG_TIMEOUT_VALUE     1000
     46          #define PWR_VOSRDY_TIMEOUT_VALUE     1000
     47          /**
     48            * @}
     49            */
     50              
     51          /* Private macro -------------------------------------------------------------*/
     52          /* Private variables ---------------------------------------------------------*/
     53          /* Private function prototypes -----------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55          /** @defgroup PWREx_Exported_Functions PWREx Exported Functions
     56            *  @{
     57            */
     58          
     59          /** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
     60            *  @brief Peripheral Extended features functions 
     61            *
     62          @verbatim   
     63          
     64           ===============================================================================
     65                           ##### Peripheral extended features functions #####
     66           ===============================================================================
     67          
     68              *** Main and Backup Regulators configuration ***
     69              ================================================
     70              [..] 
     71                (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
     72                    the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
     73                    retained even in Standby or VBAT mode when the low power backup regulator
     74                    is enabled. It can be considered as an internal EEPROM when VBAT is 
     75                    always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
     76                    enable the low power backup regulator. 
     77          
     78                (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
     79                    the backup SRAM is powered from VDD which replaces the VBAT power supply to 
     80                    save battery life.
     81          
     82                (+) The backup SRAM is not mass erased by a tamper event. It is read 
     83                    protected to prevent confidential data, such as cryptographic private 
     84                    key, from being accessed. The backup SRAM can be erased only through 
     85                    the Flash interface when a protection level change from level 1 to 
     86                    level 0 is requested. 
     87                -@- Refer to the description of Read protection (RDP) in the Flash 
     88                    programming manual.
     89          
     90                (+) The main internal regulator can be configured to have a tradeoff between 
     91                    performance and power consumption when the device does not operate at 
     92                    the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
     93                    macro which configure VOS bit in PWR_CR register
     94                    
     95                  Refer to the product datasheets for more details.
     96          
     97              *** FLASH Power Down configuration ****
     98              =======================================
     99              [..] 
    100                (+) By setting the FPDS bit in the PWR_CR register by using the 
    101                    HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
    102                    down mode when the device enters Stop mode. When the Flash memory 
    103                    is in power down mode, an additional startup delay is incurred when 
    104                    waking up from Stop mode.
    105          
    106              *** Over-Drive and Under-Drive configuration ****
    107              =================================================
    108              [..]         
    109                 (+) In Run mode: the main regulator has 2 operating modes available:
    110                  (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
    111                       voltage scaling (scale 1, scale 2 or scale 3)
    112                  (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
    113                      higher frequency than the normal mode for a given voltage scaling (scale 1,  
    114                      scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
    115                      disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
    116                      the sequence described in Reference manual.
    117                       
    118                 (+) In Stop mode: the main regulator or low power regulator supplies a low power 
    119                     voltage to the 1.2V domain, thus preserving the content of registers 
    120                     and internal SRAM. 2 operating modes are available:
    121                   (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
    122                        available when the main regulator or the low power regulator is used in Scale 3 or 
    123                        low voltage mode.
    124                   (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
    125                        available when the main regulator or the low power regulator is in low voltage mode.
    126          
    127          @endverbatim
    128            * @{
    129            */
    130          
    131          /**
    132            * @brief Enables the Backup Regulator.
    133            * @retval HAL status
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
    136          {
   \                     HAL_PWREx_EnableBkUpReg: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    137            uint32_t tickstart = 0;
    138          
    139            /* Enable Backup regulator */
    140            PWR->CSR1 |= PWR_CSR1_BRE;
   \        0x2   0x....             LDR.N    R4,??DataTable11  ;; 0x40007004
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF440 0x7000      ORR      R0,R0,#0x200
   \        0xA   0x.... 0x....      BL       ?Subroutine1
    141              
    142            /* Workaround for the following hardware bug: */
    143            /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
    144            PWR->CSR1 |= PWR_CSR1_EIWUP;
    145          
    146            /* Get tick */
    147            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0x4605             MOV      R5,R0
    148          
    149            /* Wait till Backup regulator ready flag is set */  
    150            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
   \                     ??HAL_PWREx_EnableBkUpReg_0: (+1)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x0701             LSLS     R1,R0,#+28
   \       0x14   0xD408             BMI.N    ??HAL_PWREx_EnableBkUpReg_1
    151            {
    152              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B40             SUBS     R0,R0,R5
   \       0x1C   0xF240 0x32E9      MOVW     R2,#+1001
   \       0x20   0x4290             CMP      R0,R2
   \       0x22   0xD3F5             BCC.N    ??HAL_PWREx_EnableBkUpReg_0
    153              {
    154                return HAL_TIMEOUT;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    155              } 
    156            }
    157            return HAL_OK;
   \                     ??HAL_PWREx_EnableBkUpReg_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    158          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6020             STR      R0,[R4, #+0]
   \        0x2   0x6821             LDR      R1,[R4, #+0]
   \        0x4   0xF441 0x7180      ORR      R1,R1,#0x100
   \        0x8   0x6021             STR      R1,[R4, #+0]
   \        0xA   0x.... 0x....      B.W      HAL_GetTick
    159          
    160          /**
    161            * @brief Disables the Backup Regulator.
    162            * @retval HAL status
    163            */

   \                                 In section .text, align 2, keep-with-next
    164          HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
    165          {
   \                     HAL_PWREx_DisableBkUpReg: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    166            uint32_t tickstart = 0;
    167            
    168            /* Disable Backup regulator */
    169            PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
   \        0x2   0x....             LDR.N    R4,??DataTable11  ;; 0x40007004
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF420 0x7000      BIC      R0,R0,#0x200
   \        0xA   0x.... 0x....      BL       ?Subroutine1
    170            
    171            /* Workaround for the following hardware bug: */
    172            /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
    173            PWR->CSR1 |= PWR_CSR1_EIWUP;
    174          
    175            /* Get tick */
    176            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0xE   0x4605             MOV      R5,R0
    177          
    178            /* Wait till Backup regulator ready flag is set */  
    179            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
   \                     ??HAL_PWREx_DisableBkUpReg_0: (+1)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x0701             LSLS     R1,R0,#+28
   \       0x14   0xD508             BPL.N    ??HAL_PWREx_DisableBkUpReg_1
    180            {
    181              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B40             SUBS     R0,R0,R5
   \       0x1C   0xF240 0x32E9      MOVW     R2,#+1001
   \       0x20   0x4290             CMP      R0,R2
   \       0x22   0xD3F5             BCC.N    ??HAL_PWREx_DisableBkUpReg_0
    182              {
    183                return HAL_TIMEOUT;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    184              } 
    185            }
    186            return HAL_OK;
   \                     ??HAL_PWREx_DisableBkUpReg_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    187          }
    188          
    189          /**
    190            * @brief Enables the Flash Power Down in Stop mode.
    191            * @retval None
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          void HAL_PWREx_EnableFlashPowerDown(void)
    194          {
    195            /* Enable the Flash Power Down */
    196            PWR->CR1 |= PWR_CR1_FPDS;
   \                     HAL_PWREx_EnableFlashPowerDown: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x6001             STR      R1,[R0, #+0]
    197          }
   \        0xA   0x4770             BX       LR               ;; return
    198          
    199          /**
    200            * @brief Disables the Flash Power Down in Stop mode.
    201            * @retval None
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          void HAL_PWREx_DisableFlashPowerDown(void)
    204          {
    205            /* Disable the Flash Power Down */
    206            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
   \                     HAL_PWREx_DisableFlashPowerDown: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x7100      BIC      R1,R1,#0x200
   \        0x8   0x6001             STR      R1,[R0, #+0]
    207          }
   \        0xA   0x4770             BX       LR               ;; return
    208          
    209          /**
    210            * @brief Enables Main Regulator low voltage mode.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
    214          {
    215            /* Enable Main regulator low voltage */
    216            PWR->CR1 |= PWR_CR1_MRUDS;
   \                     HAL_PWREx_EnableMainRegulatorLowVoltage: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6100      ORR      R1,R1,#0x800
   \        0x8   0x6001             STR      R1,[R0, #+0]
    217          }
   \        0xA   0x4770             BX       LR               ;; return
    218          
    219          /**
    220            * @brief Disables Main Regulator low voltage mode.
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
    224          {  
    225            /* Disable Main regulator low voltage */
    226            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
   \                     HAL_PWREx_DisableMainRegulatorLowVoltage: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6100      BIC      R1,R1,#0x800
   \        0x8   0x6001             STR      R1,[R0, #+0]
    227          }
   \        0xA   0x4770             BX       LR               ;; return
    228          
    229          /**
    230            * @brief Enables Low Power Regulator low voltage mode.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
    234          {
    235            /* Enable low power regulator */
    236            PWR->CR1 |= PWR_CR1_LPUDS;
   \                     HAL_PWREx_EnableLowRegulatorLowVoltage: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
    237          }
   \        0xA   0x4770             BX       LR               ;; return
    238          
    239          /**
    240            * @brief Disables Low Power Regulator low voltage mode.
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
    244          {
    245            /* Disable low power regulator */
    246            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
   \                     HAL_PWREx_DisableLowRegulatorLowVoltage: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
    247          }
   \        0xA   0x4770             BX       LR               ;; return
    248          
    249          /**
    250            * @brief  Activates the Over-Drive mode.
    251            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    252            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
    253            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    254            *         critical tasks and when the system clock source is either HSI or HSE. 
    255            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    256            *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
    257            * @retval HAL status
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
    260          {
   \                     HAL_PWREx_EnableOverDrive: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    261            uint32_t tickstart = 0;
    262          
    263            __HAL_RCC_PWR_CLK_ENABLE();
   \        0x2   0x.... 0x....      BL       ?Subroutine0
    264            
    265            /* Enable the Over-drive to extend the clock frequency to 216 MHz */
    266            __HAL_PWR_OVERDRIVE_ENABLE();
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0xF440 0x3080      ORR      R0,R0,#0x10000
   \        0xA   0x.... 0x....      BL       ?Subroutine2
    267          
    268            /* Get tick */
    269            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0x4606             MOV      R6,R0
    270          
    271            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
   \                     ??HAL_PWREx_EnableOverDrive_0: (+1)
   \       0x10   0x6860             LDR      R0,[R4, #+4]
   \       0x12   0x03C1             LSLS     R1,R0,#+15
   \       0x14   0xD40C             BMI.N    ??HAL_PWREx_EnableOverDrive_1
    272            {
    273              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B80             SUBS     R0,R0,R6
   \       0x1C   0x42A8             CMP      R0,R5
   \       0x1E   0xD3F7             BCC.N    ??HAL_PWREx_EnableOverDrive_0
    274              {
    275                return HAL_TIMEOUT;
    276              }
    277            }
    278            
    279            /* Enable the Over-drive switch */
    280            __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
    281          
    282            /* Get tick */
    283            tickstart = HAL_GetTick();
    284          
    285            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
    286            {
    287              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    288              {
    289                return HAL_TIMEOUT;
   \                     ??HAL_PWREx_EnableOverDrive_2: (+1)
   \       0x20   0x2003             MOVS     R0,#+3
   \       0x22   0xBD76             POP      {R1,R2,R4-R6,PC}
    290              }
   \                     ??HAL_PWREx_EnableOverDrive_3: (+1)
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x1B80             SUBS     R0,R0,R6
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD306             BCC.N    ??HAL_PWREx_EnableOverDrive_4
   \       0x2E   0xE7F7             B.N      ??HAL_PWREx_EnableOverDrive_2
    291            } 
   \                     ??HAL_PWREx_EnableOverDrive_1: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0xF440 0x3000      ORR      R0,R0,#0x20000
   \       0x36   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x3A   0x4606             MOV      R6,R0
   \                     ??HAL_PWREx_EnableOverDrive_4: (+1)
   \       0x3C   0x6861             LDR      R1,[R4, #+4]
   \       0x3E   0x0388             LSLS     R0,R1,#+14
   \       0x40   0xD5F0             BPL.N    ??HAL_PWREx_EnableOverDrive_3
    292            return HAL_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    293          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6020             STR      R0,[R4, #+0]
   \        0x2   0x.... 0x....      B.W      HAL_GetTick

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_2  ;; 0x40023840
   \        0x2   0x....             LDR.N    R4,??DataTable11_1  ;; 0x40007000
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF240 0x35E9      MOVW     R5,#+1001
   \        0xA   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0xF000 0x5080      AND      R0,R0,#0x10000000
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x9900             LDR      R1,[SP, #+0]
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x4770             BX       LR
    294          
    295          /**
    296            * @brief  Deactivates the Over-Drive mode.
    297            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    298            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
    299            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    300            *         critical tasks and when the system clock source is either HSI or HSE. 
    301            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    302            *         The peripheral clocks must be enabled once the Over-drive mode is activated.
    303            * @retval HAL status
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
    306          {
   \                     HAL_PWREx_DisableOverDrive: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    307            uint32_t tickstart = 0;
    308            
    309            __HAL_RCC_PWR_CLK_ENABLE();
   \        0x2   0x.... 0x....      BL       ?Subroutine0
    310              
    311            /* Disable the Over-drive switch */
    312            __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xF420 0x3000      BIC      R0,R0,#0x20000
   \        0xA   0x.... 0x....      BL       ?Subroutine2
    313            
    314            /* Get tick */
    315            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0x4606             MOV      R6,R0
    316           
    317            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
   \                     ??HAL_PWREx_DisableOverDrive_0: (+1)
   \       0x10   0x6860             LDR      R0,[R4, #+4]
   \       0x12   0x0381             LSLS     R1,R0,#+14
   \       0x14   0xD50C             BPL.N    ??HAL_PWREx_DisableOverDrive_1
    318            {
    319              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B80             SUBS     R0,R0,R6
   \       0x1C   0x42A8             CMP      R0,R5
   \       0x1E   0xD3F7             BCC.N    ??HAL_PWREx_DisableOverDrive_0
    320              {
    321                return HAL_TIMEOUT;
    322              }
    323            } 
    324            
    325            /* Disable the Over-drive */
    326            __HAL_PWR_OVERDRIVE_DISABLE();
    327          
    328            /* Get tick */
    329            tickstart = HAL_GetTick();
    330          
    331            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
    332            {
    333              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    334              {
    335                return HAL_TIMEOUT;
   \                     ??HAL_PWREx_DisableOverDrive_2: (+1)
   \       0x20   0x2003             MOVS     R0,#+3
   \       0x22   0xBD76             POP      {R1,R2,R4-R6,PC}
    336              }
   \                     ??HAL_PWREx_DisableOverDrive_3: (+1)
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x1B80             SUBS     R0,R0,R6
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD306             BCC.N    ??HAL_PWREx_DisableOverDrive_4
   \       0x2E   0xE7F7             B.N      ??HAL_PWREx_DisableOverDrive_2
    337            }
   \                     ??HAL_PWREx_DisableOverDrive_1: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0xF420 0x3080      BIC      R0,R0,#0x10000
   \       0x36   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x3A   0x4606             MOV      R6,R0
   \                     ??HAL_PWREx_DisableOverDrive_4: (+1)
   \       0x3C   0x6861             LDR      R1,[R4, #+4]
   \       0x3E   0x03C8             LSLS     R0,R1,#+15
   \       0x40   0xD4F0             BMI.N    ??HAL_PWREx_DisableOverDrive_3
    338            
    339            return HAL_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    340          }
    341          
    342          /**
    343            * @brief  Enters in Under-Drive STOP mode.
    344            * 
    345            * @note    This mode can be selected only when the Under-Drive is already active 
    346            *   
    347            * @note    This mode is enabled only with STOP low power mode.
    348            *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
    349            *          mode is only available when the main regulator or the low power regulator 
    350            *          is in low voltage mode
    351            *        
    352            * @note   If the Under-drive mode was enabled, it is automatically disabled after 
    353            *         exiting Stop mode. 
    354            *         When the voltage regulator operates in Under-drive mode, an additional  
    355            *         startup delay is induced when waking up from Stop mode.
    356            *                    
    357            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    358            *   
    359            * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
    360            *         the HSI RC oscillator is selected as system clock.
    361            *           
    362            * @note   When the voltage regulator operates in low power mode, an additional 
    363            *         startup delay is incurred when waking up from Stop mode. 
    364            *         By keeping the internal regulator ON during Stop mode, the consumption 
    365            *         is higher although the startup time is reduced.
    366            *     
    367            * @param  Regulator specifies the regulator state in STOP mode.
    368            *          This parameter can be one of the following values:
    369            *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
    370            *                 and Flash memory in power-down when the device is in Stop under-drive mode
    371            *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
    372            *                and Flash memory in power-down when the device is in Stop under-drive mode
    373            * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
    374            *          This parameter can be one of the following values:
    375            *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
    376            *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
    377            * @retval None
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    380          {
   \                     HAL_PWREx_EnterUnderDriveSTOPMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    381            uint32_t tempreg = 0;
    382            uint32_t tickstart = 0;
    383            
    384            /* Check the parameters */
    385            assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
    386            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    387            
    388            /* Enable Power ctrl clock */
    389            __HAL_RCC_PWR_CLK_ENABLE();
   \        0x6   0x....             LDR.N    R0,??DataTable11_2  ;; 0x40023840
    390            /* Enable the Under-drive Mode ---------------------------------------------*/
    391            /* Clear Under-drive flag */
    392            __HAL_PWR_CLEAR_ODRUDR_FLAG();
   \        0x8   0x....             LDR.N    R6,??DataTable11_1  ;; 0x40007000
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0xF000 0x5080      AND      R0,R0,#0x10000000
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x6870             LDR      R0,[R6, #+4]
   \       0x1E   0xF440 0x2040      ORR      R0,R0,#0xC0000
   \       0x22   0x6070             STR      R0,[R6, #+4]
    393            
    394            /* Enable the Under-drive */ 
    395            __HAL_PWR_UNDERDRIVE_ENABLE();
   \       0x24   0x6831             LDR      R1,[R6, #+0]
   \       0x26   0xF441 0x2140      ORR      R1,R1,#0xC0000
   \       0x2A   0x6031             STR      R1,[R6, #+0]
    396          
    397            /* Get tick */
    398            tickstart = HAL_GetTick();
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x4607             MOV      R7,R0
    399          
    400            /* Wait for UnderDrive mode is ready */
    401            while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_0: (+1)
   \       0x32   0x6870             LDR      R0,[R6, #+4]
   \       0x34   0xF400 0x2040      AND      R0,R0,#0xC0000
   \       0x38   0xF5B0 0x2F40      CMP      R0,#+786432
   \       0x3C   0xD10E             BNE.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_1
    402            {
    403              if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
   \       0x3E   0x.... 0x....      BL       HAL_GetTick
   \       0x42   0x1BC0             SUBS     R0,R0,R7
   \       0x44   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xD3F2             BCC.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_0
    404              {
    405                return HAL_TIMEOUT;
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}
    406              }
    407            }
    408            
    409            /* Select the regulator state in STOP mode ---------------------------------*/
    410            tempreg = PWR->CR1;
    411            /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
    412            tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
    413            
    414            /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
    415            tempreg |= Regulator;
    416            
    417            /* Store the new value */
    418            PWR->CR1 = tempreg;
    419            
    420            /* Set SLEEPDEEP bit of Cortex System Control Register */
    421            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    422            
    423            /* Select STOP mode entry --------------------------------------------------*/
    424            if(STOPEntry == PWR_SLEEPENTRY_WFI)
    425            {   
    426              /* Request Wait For Interrupt */
    427              __WFI();
    428            }
    429            else
    430            {
    431              /* Request Wait For Event */
    432              __WFE();
    433            }
    434            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    435            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_2: (+1)
   \       0x50   0x6802             LDR      R2,[R0, #+0]
   \       0x52   0xF022 0x0204      BIC      R2,R2,#0x4
   \       0x56   0x6002             STR      R2,[R0, #+0]
    436          
    437            return HAL_OK;  
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_1: (+1)
   \       0x5C   0x6831             LDR      R1,[R6, #+0]
   \       0x5E   0x....             LDR.N    R0,??DataTable11_3  ;; 0xfffff3fc
   \       0x60   0x4001             ANDS     R1,R0,R1
   \       0x62   0x430D             ORRS     R5,R5,R1
   \       0x64   0x6035             STR      R5,[R6, #+0]
   \       0x66   0x....             LDR.N    R0,??DataTable11_4  ;; 0xe000ed10
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x2C01             CMP      R4,#+1
   \       0x6C   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x70   0x6001             STR      R1,[R0, #+0]
   \       0x72   0xBF0C             ITE      EQ 
   \       0x74   0xBF30             WFIEQ    
   \       0x76   0xBF20             WFENE    
   \       0x78   0xE7EA             B.N      ??HAL_PWREx_EnterUnderDriveSTOPMode_2
    438          }
    439          
    440          /**
    441            * @brief Returns Voltage Scaling Range.
    442            * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or 
    443            *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1
    444            */  

   \                                 In section .text, align 2, keep-with-next
    445          uint32_t HAL_PWREx_GetVoltageRange(void)
    446          {
    447            return  (PWR->CR1 & PWR_CR1_VOS);
   \                     HAL_PWREx_GetVoltageRange: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF400 0x4040      AND      R0,R0,#0xC000
   \        0x8   0x4770             BX       LR               ;; return
    448          }
    449          
    450          /**
    451            * @brief Configures the main internal regulator output voltage.
    452            * @param  VoltageScaling specifies the regulator output voltage to achieve
    453            *         a tradeoff between performance and power consumption.
    454            *          This parameter can be one of the following values:
    455            *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
    456            *                                                typical output voltage at 1.4 V,  
    457            *                                                system frequency up to 216 MHz.
    458            *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
    459            *                                                typical output voltage at 1.2 V,                
    460            *                                                system frequency up to 180 MHz.
    461            *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 2 mode,
    462            *                                                typical output voltage at 1.00 V,                
    463            *                                                system frequency up to 151 MHz.
    464            * @note To update the system clock frequency(SYSCLK):
    465            *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
    466            *        - Call the HAL_RCC_OscConfig() to configure the PLL.
    467            *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
    468            *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
    469            * @note The scale can be modified only when the HSI or HSE clock source is selected 
    470            *        as system clock source, otherwise the API returns HAL_ERROR.  
    471            * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
    472            *       value in the PWR_CR1 register are not taken in account.
    473            * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
    474            * @note The new voltage scale is active only when the PLL is ON.  
    475            * @retval HAL Status
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    478          {
   \                     HAL_PWREx_ControlVoltageScaling: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
    479            uint32_t tickstart = 0;
    480          
    481            assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
    482          
    483            /* Enable Power ctrl clock */
    484            __HAL_RCC_PWR_CLK_ENABLE();
   \        0x4   0x....             LDR.N    R5,??DataTable11_5  ;; 0x40023800
   \        0x6   0x6C28             LDR      R0,[R5, #+64]
   \        0x8   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \        0xC   0x6428             STR      R0,[R5, #+64]
   \        0xE   0x6C29             LDR      R1,[R5, #+64]
   \       0x10   0xF001 0x5180      AND      R1,R1,#0x10000000
   \       0x14   0x9100             STR      R1,[SP, #+0]
   \       0x16   0x9800             LDR      R0,[SP, #+0]
    485          
    486            /* Check if the PLL is used as system clock or not */
    487            if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
   \       0x18   0x68A9             LDR      R1,[R5, #+8]
   \       0x1A   0xF001 0x010C      AND      R1,R1,#0xC
   \       0x1E   0x2908             CMP      R1,#+8
   \       0x20   0xD01E             BEQ.N    ??HAL_PWREx_ControlVoltageScaling_0
    488            {
    489              /* Disable the main PLL */
    490              __HAL_RCC_PLL_DISABLE();
   \       0x22   0x6828             LDR      R0,[R5, #+0]
   \       0x24   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \       0x28   0x6028             STR      R0,[R5, #+0]
    491              
    492              /* Get Start Tick */
    493              tickstart = HAL_GetTick();    
   \       0x2A   0x.... 0x....      BL       HAL_GetTick
   \       0x2E   0x4604             MOV      R4,R0
    494              /* Wait till PLL is disabled */  
    495              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_1: (+1)
   \       0x30   0x6829             LDR      R1,[R5, #+0]
   \       0x32   0x0188             LSLS     R0,R1,#+6
   \       0x34   0xD516             BPL.N    ??HAL_PWREx_ControlVoltageScaling_2
    496              {
    497                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \       0x36   0x.... 0x....      BL       HAL_GetTick
   \       0x3A   0x1B00             SUBS     R0,R0,R4
   \       0x3C   0x2803             CMP      R0,#+3
   \       0x3E   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_1
    498                {
    499                  return HAL_TIMEOUT;
    500                }
    501              }
    502              
    503              /* Set Range */
    504              __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
    505              
    506              /* Enable the main PLL */
    507              __HAL_RCC_PLL_ENABLE();
    508              
    509              /* Get Start Tick */
    510              tickstart = HAL_GetTick();
    511              /* Wait till PLL is ready */  
    512              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    513              {
    514                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    515                {
    516                  return HAL_TIMEOUT;
    517                } 
    518              }
    519              
    520              /* Get Start Tick */
    521              tickstart = HAL_GetTick();
    522              while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
    523              {
    524                if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
    525                {
    526                  return HAL_TIMEOUT;
   \                     ??HAL_PWREx_ControlVoltageScaling_3: (+1)
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0xBD76             POP      {R1,R2,R4-R6,PC}
    527                } 
   \                     ??HAL_PWREx_ControlVoltageScaling_4: (+1)
   \       0x44   0x.... 0x....      BL       HAL_GetTick
   \       0x48   0x1B80             SUBS     R0,R0,R6
   \       0x4A   0x2803             CMP      R0,#+3
   \       0x4C   0xD31C             BCC.N    ??HAL_PWREx_ControlVoltageScaling_5
   \       0x4E   0xE7F7             B.N      ??HAL_PWREx_ControlVoltageScaling_3
   \                     ??HAL_PWREx_ControlVoltageScaling_6: (+1)
   \       0x50   0x.... 0x....      BL       HAL_GetTick
   \       0x54   0x1B40             SUBS     R0,R0,R5
   \       0x56   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x5A   0x4288             CMP      R0,R1
   \       0x5C   0xD31A             BCC.N    ??HAL_PWREx_ControlVoltageScaling_7
   \       0x5E   0xE7EF             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    528              }
    529            }
    530            else
    531            {
    532              return HAL_ERROR;
   \                     ??HAL_PWREx_ControlVoltageScaling_0: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    533            }
   \                     ??HAL_PWREx_ControlVoltageScaling_2: (+1)
   \       0x64   0x....             LDR.N    R4,??DataTable11_1  ;; 0x40007000
   \       0x66   0x6822             LDR      R2,[R4, #+0]
   \       0x68   0xF422 0x4240      BIC      R2,R2,#0xC000
   \       0x6C   0x4316             ORRS     R6,R6,R2
   \       0x6E   0x6026             STR      R6,[R4, #+0]
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0xF401 0x4140      AND      R1,R1,#0xC000
   \       0x76   0x9100             STR      R1,[SP, #+0]
   \       0x78   0x9800             LDR      R0,[SP, #+0]
   \       0x7A   0x682A             LDR      R2,[R5, #+0]
   \       0x7C   0xF042 0x7280      ORR      R2,R2,#0x1000000
   \       0x80   0x602A             STR      R2,[R5, #+0]
   \       0x82   0x.... 0x....      BL       HAL_GetTick
   \       0x86   0x4606             MOV      R6,R0
   \                     ??HAL_PWREx_ControlVoltageScaling_5: (+1)
   \       0x88   0x6829             LDR      R1,[R5, #+0]
   \       0x8A   0x0188             LSLS     R0,R1,#+6
   \       0x8C   0xD5DA             BPL.N    ??HAL_PWREx_ControlVoltageScaling_4
   \       0x8E   0x.... 0x....      BL       HAL_GetTick
   \       0x92   0x4605             MOV      R5,R0
   \                     ??HAL_PWREx_ControlVoltageScaling_7: (+1)
   \       0x94   0x6861             LDR      R1,[R4, #+4]
   \       0x96   0x0448             LSLS     R0,R1,#+17
   \       0x98   0xD5DA             BPL.N    ??HAL_PWREx_ControlVoltageScaling_6
    534            return HAL_OK;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xBD76             POP      {R1,R2,R4-R6,PC}
    535          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x4000'7004        DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x4000'7000        DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x4002'3840        DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xFFFF'F3FC        DC32     0xfffff3fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0xE000'ED10        DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x4002'3800        DC32     0x40023800
    536          
    537          /**
    538            * @}
    539            */
    540          
    541          /**
    542            * @}
    543            */
    544          
    545          #endif /* HAL_PWR_MODULE_ENABLED */
    546          /**
    547            * @}
    548            */
    549          
    550          /**
    551            * @}
    552            */
    553          
    554          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   HAL_PWREx_ControlVoltageScaling
        24   -> HAL_GetTick
      16   HAL_PWREx_DisableBkUpReg
        16   -> HAL_GetTick
       0   HAL_PWREx_DisableFlashPowerDown
       0   HAL_PWREx_DisableLowRegulatorLowVoltage
       0   HAL_PWREx_DisableMainRegulatorLowVoltage
      24   HAL_PWREx_DisableOverDrive
        24   -> HAL_GetTick
      16   HAL_PWREx_EnableBkUpReg
        16   -> HAL_GetTick
       0   HAL_PWREx_EnableFlashPowerDown
       0   HAL_PWREx_EnableLowRegulatorLowVoltage
       0   HAL_PWREx_EnableMainRegulatorLowVoltage
      24   HAL_PWREx_EnableOverDrive
        24   -> HAL_GetTick
      24   HAL_PWREx_EnterUnderDriveSTOPMode
        24   -> HAL_GetTick
       0   HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
      30  ?Subroutine0
      14  ?Subroutine1
       6  ?Subroutine2
     158  HAL_PWREx_ControlVoltageScaling
      44  HAL_PWREx_DisableBkUpReg
      12  HAL_PWREx_DisableFlashPowerDown
      12  HAL_PWREx_DisableLowRegulatorLowVoltage
      12  HAL_PWREx_DisableMainRegulatorLowVoltage
      70  HAL_PWREx_DisableOverDrive
      44  HAL_PWREx_EnableBkUpReg
      12  HAL_PWREx_EnableFlashPowerDown
      12  HAL_PWREx_EnableLowRegulatorLowVoltage
      12  HAL_PWREx_EnableMainRegulatorLowVoltage
      70  HAL_PWREx_EnableOverDrive
     122  HAL_PWREx_EnterUnderDriveSTOPMode
      10  HAL_PWREx_GetVoltageRange

 
 664 bytes in section .text
 
 664 bytes of CODE memory

Errors: none
Warnings: none
