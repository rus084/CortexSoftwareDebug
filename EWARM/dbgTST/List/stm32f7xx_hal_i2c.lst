###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Feb/2020  21:42:23
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#    Command line =  
#        -f C:\Users\rus08\AppData\Local\Temp\EW71AE.tmp
#        (D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F723xx -lC
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -lA
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List -o
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc\c\DLib_Config_Full.h"
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\ -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I D:\win10\f7dbg\dbgTST\EWARM/../Drivers/CMSIS/Include\ -Ohz)
#    Locale       =  C
#    List file    =  
#        D:\win10\f7dbg\dbgTST\EWARM\dbgTST\List\stm32f7xx_hal_i2c.lst
#    Object file  =  D:\win10\f7dbg\dbgTST\EWARM\dbgTST\Obj\stm32f7xx_hal_i2c.o
#
###############################################################################

D:\win10\f7dbg\dbgTST\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @brief   I2C HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State and Errors functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16              [..]
     17              The I2C HAL driver can be used as follows:
     18          
     19              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     20                  I2C_HandleTypeDef  hi2c;
     21          
     22              (#)Initialize the I2C low level resources by implementing the @ref HAL_I2C_MspInit() API:
     23                  (##) Enable the I2Cx interface clock
     24                  (##) I2C pins configuration
     25                      (+++) Enable the clock for the I2C GPIOs
     26                      (+++) Configure I2C pins as alternate function open-drain
     27                  (##) NVIC configuration if you need to use interrupt process
     28                      (+++) Configure the I2Cx interrupt priority
     29                      (+++) Enable the NVIC I2C IRQ Channel
     30                  (##) DMA Configuration if you need to use DMA process
     31                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     32                      (+++) Enable the DMAx interface clock using
     33                      (+++) Configure the DMA handle parameters
     34                      (+++) Configure the DMA Tx or Rx stream
     35                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     36                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
     37                            the DMA Tx or Rx stream
     38          
     39              (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,
     40                  Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.
     41          
     42              (#) Initialize the I2C registers by calling the @ref HAL_I2C_Init(), configures also the low level Hardware
     43                  (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_I2C_MspInit(&hi2c) API.
     44          
     45              (#) To check if target device is ready for communication, use the function @ref HAL_I2C_IsDeviceReady()
     46          
     47              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     48          
     49              *** Polling mode IO operation ***
     50              =================================
     51              [..]
     52                (+) Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
     53                (+) Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
     54                (+) Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
     55                (+) Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()
     56          
     57              *** Polling mode IO MEM operation ***
     58              =====================================
     59              [..]
     60                (+) Write an amount of data in blocking mode to a specific memory address using @ref HAL_I2C_Mem_Write()
     61                (+) Read an amount of data in blocking mode from a specific memory address using @ref HAL_I2C_Mem_Read()
     62          
     63          
     64              *** Interrupt mode IO operation ***
     65              ===================================
     66              [..]
     67                (+) Transmit in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Transmit_IT()
     68                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
     69                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
     70                (+) Receive in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Receive_IT()
     71                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
     72                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
     73                (+) Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
     74                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
     75                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
     76                (+) Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
     77                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
     78                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
     79                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
     80                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
     81                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
     82                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
     83                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
     84                (+) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
     85                     This action will inform Master to generate a Stop condition to discard the communication.
     86          
     87          
     88              *** Interrupt mode or DMA mode IO sequential operation ***
     89              ==========================================================
     90              [..]
     91                (@) These interfaces allow to manage a sequential transfer with a repeated start condition
     92                    when a direction change during transfer
     93              [..]
     94                (+) A specific option field manage the different steps of a sequential transfer
     95                (+) Option field values are defined through @ref I2C_XFEROPTIONS and are listed below:
     96                (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode
     97                (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
     98                                      and data to transfer without a final stop condition
     99                (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with start condition, address
    100                                      and data to transfer without a final stop condition, an then permit a call the same master sequential interface
    101                                      several times (like @ref HAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT()
    102                                      or @ref HAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())
    103                (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
    104                                      and with new data to transfer if the direction change or manage only the new data to transfer
    105                                      if no direction change and without a final stop condition in both cases
    106                (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
    107                                      and with new data to transfer if the direction change or manage only the new data to transfer
    108                                      if no direction change and with a final stop condition in both cases
    109                (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition after several call of the same master sequential
    110                                      interface several times (link with option I2C_FIRST_AND_NEXT_FRAME).
    111                                      Usage can, transfer several bytes one by one using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    112                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    113                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    114                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME).
    115                                      Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or Receive sequence permit to call the oposite interface Receive or Transmit
    116                                        without stopping the communication and so generate a restart condition.
    117                (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after each call of the same master sequential
    118                                      interface.
    119                                      Usage can, transfer several bytes one by one with a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    120                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    121                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    122                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME).
    123                                      Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.
    124          
    125                (+) Differents sequential I2C interfaces are listed below:
    126                (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Transmit_IT()
    127                      or using @ref HAL_I2C_Master_Seq_Transmit_DMA()
    128                (+++) At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    129                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    130                (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Receive_IT()
    131                      or using @ref HAL_I2C_Master_Seq_Receive_DMA()
    132                (+++) At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    133                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    134                (++) Abort a master IT or DMA I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    135                (+++) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    136                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    137                (++) Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT() @ref HAL_I2C_DisableListen_IT()
    138                (+++) When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can
    139                     add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
    140                (+++) At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can
    141                     add his own code by customization of function pointer @ref HAL_I2C_ListenCpltCallback()
    142                (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Transmit_IT()
    143                      or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()
    144                (+++) At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    145                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    146                (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Receive_IT()
    147                      or using @ref HAL_I2C_Slave_Seq_Receive_DMA()
    148                (+++) At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    149                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    150                (++) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    151                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    152                (++) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
    153                     This action will inform Master to generate a Stop condition to discard the communication.
    154          
    155              *** Interrupt mode IO MEM operation ***
    156              =======================================
    157              [..]
    158                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
    159                    @ref HAL_I2C_Mem_Write_IT()
    160                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    161                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    162                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
    163                    @ref HAL_I2C_Mem_Read_IT()
    164                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    165                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    166                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    167                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    168          
    169              *** DMA mode IO operation ***
    170              ==============================
    171              [..]
    172                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    173                    @ref HAL_I2C_Master_Transmit_DMA()
    174                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    175                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    176                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    177                    @ref HAL_I2C_Master_Receive_DMA()
    178                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    179                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    180                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    181                    @ref HAL_I2C_Slave_Transmit_DMA()
    182                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    183                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    184                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    185                    @ref HAL_I2C_Slave_Receive_DMA()
    186                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    187                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    188                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    189                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    190                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    191                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    192                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    193                (+) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
    194                     This action will inform Master to generate a Stop condition to discard the communication.
    195          
    196              *** DMA mode IO MEM operation ***
    197              =================================
    198              [..]
    199                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    200                    @ref HAL_I2C_Mem_Write_DMA()
    201                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    202                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    203                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    204                    @ref HAL_I2C_Mem_Read_DMA()
    205                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    206                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    207                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    208                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    209          
    210          
    211               *** I2C HAL driver macros list ***
    212               ==================================
    213               [..]
    214                 Below the list of most used macros in I2C HAL driver.
    215          
    216                (+) @ref __HAL_I2C_ENABLE: Enable the I2C peripheral
    217                (+) @ref __HAL_I2C_DISABLE: Disable the I2C peripheral
    218                (+) @ref __HAL_I2C_GENERATE_NACK: Generate a Non-Acknowledge I2C peripheral in Slave mode
    219                (+) @ref __HAL_I2C_GET_FLAG: Check whether the specified I2C flag is set or not
    220                (+) @ref __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
    221                (+) @ref __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    222                (+) @ref __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    223          
    224               *** Callback registration ***
    225               =============================================
    226          
    227               The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
    228               allows the user to configure dynamically the driver callbacks.
    229               Use Functions @ref HAL_I2C_RegisterCallback() or @ref HAL_I2C_RegisterAddrCallback()
    230               to register an interrupt callback.
    231          
    232               Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
    233                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    234                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    235                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    236                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    237                 (+) ListenCpltCallback   : callback for end of listen mode.
    238                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    239                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    240                 (+) ErrorCallback        : callback for error detection.
    241                 (+) AbortCpltCallback    : callback for abort completion process.
    242                 (+) MspInitCallback      : callback for Msp Init.
    243                 (+) MspDeInitCallback    : callback for Msp DeInit.
    244               This function takes as parameters the HAL peripheral handle, the Callback ID
    245               and a pointer to the user callback function.
    246          
    247               For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().
    248          
    249               Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
    250               weak function.
    251               @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
    252               and the Callback ID.
    253               This function allows to reset following callbacks:
    254                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    255                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    256                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    257                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    258                 (+) ListenCpltCallback   : callback for end of listen mode.
    259                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    260                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    261                 (+) ErrorCallback        : callback for error detection.
    262                 (+) AbortCpltCallback    : callback for abort completion process.
    263                 (+) MspInitCallback      : callback for Msp Init.
    264                 (+) MspDeInitCallback    : callback for Msp DeInit.
    265          
    266               For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().
    267          
    268               By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
    269               all callbacks are set to the corresponding weak functions:
    270               examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
    271               Exception done for MspInit and MspDeInit functions that are
    272               reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
    273               these callbacks are null (not registered beforehand).
    274               If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
    275               keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    276          
    277               Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only.
    278               Exception done MspInit/MspDeInit functions that can be registered/unregistered
    279               in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
    280               thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    281               Then, the user first registers the MspInit/MspDeInit user callbacks
    282               using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
    283               or @ref HAL_I2C_Init() function.
    284          
    285               When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
    286               not defined, the callback registration feature is not available and all callbacks
    287               are set to the corresponding weak functions.
    288          
    289               [..]
    290                 (@) You can refer to the I2C HAL driver header file for more useful macros
    291          
    292            @endverbatim
    293            ******************************************************************************
    294            * @attention
    295            *
    296            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
    297            * All rights reserved.</center></h2>
    298            *
    299            * This software component is licensed by ST under BSD 3-Clause license,
    300            * the "License"; You may not use this file except in compliance with the
    301            * License. You may obtain a copy of the License at:
    302            *                        opensource.org/licenses/BSD-3-Clause
    303            *
    304            ******************************************************************************
    305            */
    306          
    307          /* Includes ------------------------------------------------------------------*/
    308          #include "stm32f7xx_hal.h"
    309          
    310          /** @addtogroup STM32F7xx_HAL_Driver
    311            * @{
    312            */
    313          
    314          /** @defgroup I2C I2C
    315            * @brief I2C HAL module driver
    316            * @{
    317            */
    318          
    319          #ifdef HAL_I2C_MODULE_ENABLED
    320          
    321          /* Private typedef -----------------------------------------------------------*/
    322          /* Private define ------------------------------------------------------------*/
    323          
    324          /** @defgroup I2C_Private_Define I2C Private Define
    325            * @{
    326            */
    327          #define TIMING_CLEAR_MASK   (0xF0FFFFFFU)  /*!< I2C TIMING clear register Mask */
    328          #define I2C_TIMEOUT_ADDR    (10000U)       /*!< 10 s  */
    329          #define I2C_TIMEOUT_BUSY    (25U)          /*!< 25 ms */
    330          #define I2C_TIMEOUT_DIR     (25U)          /*!< 25 ms */
    331          #define I2C_TIMEOUT_RXNE    (25U)          /*!< 25 ms */
    332          #define I2C_TIMEOUT_STOPF   (25U)          /*!< 25 ms */
    333          #define I2C_TIMEOUT_TC      (25U)          /*!< 25 ms */
    334          #define I2C_TIMEOUT_TCR     (25U)          /*!< 25 ms */
    335          #define I2C_TIMEOUT_TXIS    (25U)          /*!< 25 ms */
    336          #define I2C_TIMEOUT_FLAG    (25U)          /*!< 25 ms */
    337          
    338          #define MAX_NBYTE_SIZE      255U
    339          #define SlaveAddr_SHIFT     7U
    340          #define SlaveAddr_MSK       0x06U
    341          
    342          /* Private define for @ref PreviousState usage */
    343          #define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) & (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY)))) /*!< Mask State define, keep only RX and TX bits            */
    344          #define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))                                                        /*!< Default Value                                          */
    345          #define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy TX, combinaison of State LSB and Mode enum */
    346          #define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy RX, combinaison of State LSB and Mode enum */
    347          #define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy TX, combinaison of State LSB and Mode enum  */
    348          #define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy RX, combinaison of State LSB and Mode enum  */
    349          #define I2C_STATE_MEM_BUSY_TX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))               /*!< Memory Busy TX, combinaison of State LSB and Mode enum */
    350          #define I2C_STATE_MEM_BUSY_RX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))               /*!< Memory Busy RX, combinaison of State LSB and Mode enum */
    351          
    352          
    353          /* Private define to centralize the enable/disable of Interrupts */
    354          #define I2C_XFER_TX_IT          (0x00000001U)
    355          #define I2C_XFER_RX_IT          (0x00000002U)
    356          #define I2C_XFER_LISTEN_IT      (0x00000004U)
    357          
    358          #define I2C_XFER_ERROR_IT       (0x00000011U)
    359          #define I2C_XFER_CPLT_IT        (0x00000012U)
    360          #define I2C_XFER_RELOAD_IT      (0x00000012U)
    361          
    362          /* Private define Sequential Transfer Options default/reset value */
    363          #define I2C_NO_OPTION_FRAME     (0xFFFF0000U)
    364          /**
    365            * @}
    366            */
    367          
    368          /* Private macro -------------------------------------------------------------*/
    369          /* Private variables ---------------------------------------------------------*/
    370          /* Private function prototypes -----------------------------------------------*/
    371          
    372          /** @defgroup I2C_Private_Functions I2C Private Functions
    373            * @{
    374            */
    375          /* Private functions to handle DMA transfer */
    376          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    377          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    378          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    379          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    380          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    381          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma);
    382          
    383          /* Private functions to handle IT transfer */
    384          static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    385          static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c);
    386          static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c);
    387          static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    388          static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    389          static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    390          static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode);
    391          
    392          /* Private functions to handle IT transfer */
    393          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    394          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    395          
    396          /* Private functions for I2C transfer IRQ handler */
    397          static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    398          static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    399          static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    400          static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    401          
    402          /* Private functions to handle flags during polling transfer */
    403          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart);
    404          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    405          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    406          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    407          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    408          
    409          /* Private functions to centralize the enable/disable of Interrupts */
    410          static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);
    411          static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);
    412          
    413          /* Private function to flush TXDR register */
    414          static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c);
    415          
    416          /* Private function to handle  start, restart or stop a transfer */
    417          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request);
    418          
    419          /* Private function to Convert Specific options */
    420          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);
    421          /**
    422            * @}
    423            */
    424          
    425          /* Exported functions --------------------------------------------------------*/
    426          
    427          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    428            * @{
    429            */
    430          
    431          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    432           *  @brief    Initialization and Configuration functions
    433           *
    434          @verbatim
    435           ===============================================================================
    436                        ##### Initialization and de-initialization functions #####
    437           ===============================================================================
    438              [..]  This subsection provides a set of functions allowing to initialize and
    439                    deinitialize the I2Cx peripheral:
    440          
    441                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    442                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    443          
    444                (+) Call the function HAL_I2C_Init() to configure the selected device with
    445                    the selected configuration:
    446                  (++) Clock Timing
    447                  (++) Own Address 1
    448                  (++) Addressing mode (Master, Slave)
    449                  (++) Dual Addressing mode
    450                  (++) Own Address 2
    451                  (++) Own Address 2 Mask
    452                  (++) General call mode
    453                  (++) Nostretch mode
    454          
    455                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    456                    of the selected I2Cx peripheral.
    457          
    458          @endverbatim
    459            * @{
    460            */
    461          
    462          /**
    463            * @brief  Initializes the I2C according to the specified parameters
    464            *         in the I2C_InitTypeDef and initialize the associated handle.
    465            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    466            *                the configuration information for the specified I2C.
    467            * @retval HAL status
    468            */

   \                                 In section .text, align 2, keep-with-next
    469          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    470          {
   \                     HAL_I2C_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    471            /* Check the I2C handle allocation */
    472            if (hi2c == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_I2C_Init_0
    473            {
    474              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    475            }
    476          
    477            /* Check the parameters */
    478            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    479            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    480            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    481            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    482            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    483            assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    484            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    485            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    486          
    487            if (hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \        0xA   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0xB920             CBNZ.N   R0,??HAL_I2C_Init_1
    488            {
    489              /* Allocate lock resource and initialize it */
    490              hi2c->Lock = HAL_UNLOCKED;
   \       0x10   0x2100             MOVS     R1,#+0
    491          
    492          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    493              /* Init the I2C Callback settings */
    494              hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    495              hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    496              hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
    497              hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
    498              hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
    499              hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
    500              hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
    501              hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
    502              hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    503              hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
    504          
    505              if (hi2c->MspInitCallback == NULL)
    506              {
    507                hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
    508              }
    509          
    510              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    511              hi2c->MspInitCallback(hi2c);
    512          #else
    513              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    514              HAL_I2C_MspInit(hi2c);
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x7029             STRB     R1,[R5, #+0]
   \       0x16   0x.... 0x....      BL       HAL_I2C_MspInit
    515          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    516            }
    517          
    518            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \       0x1A   0x.... 0x....      BL       ?Subroutine23
    519          
    520            /* Disable the selected I2C peripheral */
    521            __HAL_I2C_DISABLE(hi2c);
    522          
    523            /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
    524            /* Configure I2Cx: Frequency range */
    525            hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x1E   0x6860             LDR      R0,[R4, #+4]
   \       0x20   0x6822             LDR      R2,[R4, #+0]
   \       0x22   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \       0x26   0x6110             STR      R0,[R2, #+16]
    526          
    527            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    528            /* Disable Own Address1 before set the Own Address1 configuration */
    529            hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6881             LDR      R1,[R0, #+8]
   \       0x2C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \       0x30   0x6081             STR      R1,[R0, #+8]
    530          
    531            /* Configure I2Cx: Own Address1 and ack own address1 mode */
    532            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \       0x32   0x68E0             LDR      R0,[R4, #+12]
   \       0x34   0x68A1             LDR      R1,[R4, #+8]
   \       0x36   0x2801             CMP      R0,#+1
    533            {
    534              hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    535            }
    536            else /* I2C_ADDRESSINGMODE_10BIT */
    537            {
    538              hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0xBF0C             ITE      EQ 
   \       0x3C   0xF441 0x4100      ORREQ    R1,R1,#0x8000
   \       0x40   0xF441 0x4104      ORRNE    R1,R1,#0x8400
   \       0x44   0x6081             STR      R1,[R0, #+8]
    539            }
    540          
    541            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    542            /* Configure I2Cx: Addressing Master mode */
    543            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x46   0x68E1             LDR      R1,[R4, #+12]
   \       0x48   0x2902             CMP      R1,#+2
   \       0x4A   0xD103             BNE.N    ??HAL_I2C_Init_2
    544            {
    545              hi2c->Instance->CR2 = (I2C_CR2_ADD10);
   \       0x4C   0x6822             LDR      R2,[R4, #+0]
   \       0x4E   0xF44F 0x6000      MOV      R0,#+2048
   \       0x52   0x6050             STR      R0,[R2, #+4]
    546            }
    547            /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
    548            hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
   \                     ??HAL_I2C_Init_2: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6841             LDR      R1,[R0, #+4]
   \       0x58   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \       0x5C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x60   0x6041             STR      R1,[R0, #+4]
    549          
    550            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    551            /* Disable Own Address2 before set the Own Address2 configuration */
    552            hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x68C2             LDR      R2,[R0, #+12]
   \       0x66   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x6A   0x60C2             STR      R2,[R0, #+12]
    553          
    554            /* Configure I2Cx: Dual mode and Own Address2 */
    555            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
   \       0x6C   0x6921             LDR      R1,[R4, #+16]
   \       0x6E   0x6960             LDR      R0,[R4, #+20]
   \       0x70   0x6823             LDR      R3,[R4, #+0]
   \       0x72   0x69A2             LDR      R2,[R4, #+24]
   \       0x74   0x4301             ORRS     R1,R0,R1
   \       0x76   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x7A   0x60D9             STR      R1,[R3, #+12]
    556          
    557            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    558            /* Configure I2Cx: Generalcall and NoStretch mode */
    559            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \       0x7C   0x69E1             LDR      R1,[R4, #+28]
   \       0x7E   0x6A20             LDR      R0,[R4, #+32]
   \       0x80   0x6822             LDR      R2,[R4, #+0]
   \       0x82   0x4301             ORRS     R1,R0,R1
   \       0x84   0x6011             STR      R1,[R2, #+0]
    560          
    561            /* Enable the selected I2C peripheral */
    562            __HAL_I2C_ENABLE(hi2c);
   \       0x86   0x6820             LDR      R0,[R4, #+0]
    563          
    564            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x6803             LDR      R3,[R0, #+0]
   \       0x8C   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x90   0x6003             STR      R3,[R0, #+0]
    565            hi2c->State = HAL_I2C_STATE_READY;
   \       0x92   0x2020             MOVS     R0,#+32
   \       0x94   0x6069             STR      R1,[R5, #+4]
   \       0x96   0x7068             STRB     R0,[R5, #+1]
    566            hi2c->PreviousState = I2C_STATE_NONE;
    567            hi2c->Mode = HAL_I2C_MODE_NONE;
    568          
    569            return HAL_OK;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x6321             STR      R1,[R4, #+48]
   \       0x9C   0x70A9             STRB     R1,[R5, #+2]
   \       0x9E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    570          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x2024             MOVS     R0,#+36
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x0849             LSRS     R1,R1,#+1
   \        0xA   0x0049             LSLS     R1,R1,#+1
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \                     ??Subroutine8_0: (+1)
   \        0x2   0xF104 0x0540      ADD      R5,R4,#+64
   \        0x6   0x7868             LDRB     R0,[R5, #+1]
   \        0x8   0x4770             BX       LR
    571          
    572          /**
    573            * @brief  DeInitialize the I2C peripheral.
    574            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    575            *                the configuration information for the specified I2C.
    576            * @retval HAL status
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    579          {
   \                     HAL_I2C_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    580            /* Check the I2C handle allocation */
    581            if (hi2c == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    582            {
    583              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    584            }
    585          
    586            /* Check the parameters */
    587            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    588          
    589            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \        0xA   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xE   0x.... 0x....      BL       ?Subroutine23
    590          
    591            /* Disable the I2C Peripheral Clock */
    592            __HAL_I2C_DISABLE(hi2c);
    593          
    594          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    595            if (hi2c->MspDeInitCallback == NULL)
    596            {
    597              hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
    598            }
    599          
    600            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    601            hi2c->MspDeInitCallback(hi2c);
    602          #else
    603            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    604            HAL_I2C_MspDeInit(hi2c);
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       HAL_I2C_MspDeInit
    605          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    606          
    607            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6068             STR      R0,[R5, #+4]
    608            hi2c->State = HAL_I2C_STATE_RESET;
   \       0x1C   0x7068             STRB     R0,[R5, #+1]
    609            hi2c->PreviousState = I2C_STATE_NONE;
   \       0x1E   0x6320             STR      R0,[R4, #+48]
    610            hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x20   0x70A8             STRB     R0,[R5, #+2]
    611          
    612            /* Release Lock */
    613            __HAL_UNLOCK(hi2c);
   \       0x22   0x7028             STRB     R0,[R5, #+0]
    614          
    615            return HAL_OK;
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    616          }
    617          
    618          /**
    619            * @brief Initialize the I2C MSP.
    620            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    621            *                the configuration information for the specified I2C.
    622            * @retval None
    623            */

   \                                 In section .text, align 2
    624          __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    625          {
    626            /* Prevent unused argument(s) compilation warning */
    627            UNUSED(hi2c);
    628          
    629            /* NOTE : This function should not be modified, when the callback is needed,
    630                      the HAL_I2C_MspInit could be implemented in the user file
    631             */
    632          }
   \                     HAL_I2C_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    633          
    634          /**
    635            * @brief DeInitialize the I2C MSP.
    636            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    637            *                the configuration information for the specified I2C.
    638            * @retval None
    639            */

   \                                 In section .text, align 2
    640          __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    641          {
    642            /* Prevent unused argument(s) compilation warning */
    643            UNUSED(hi2c);
    644          
    645            /* NOTE : This function should not be modified, when the callback is needed,
    646                      the HAL_I2C_MspDeInit could be implemented in the user file
    647             */
    648          }
   \                     HAL_I2C_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    649          
    650          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    651          /**
    652            * @brief  Register a User I2C Callback
    653            *         To be used instead of the weak predefined callback
    654            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    655            *                the configuration information for the specified I2C.
    656            * @param  CallbackID ID of the callback to be registered
    657            *         This parameter can be one of the following values:
    658            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    659            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    660            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    661            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    662            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    663            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    664            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    665            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    666            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    667            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    668            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    669            * @param  pCallback pointer to the Callback function
    670            * @retval HAL status
    671            */
    672          HAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback)
    673          {
    674            HAL_StatusTypeDef status = HAL_OK;
    675          
    676            if (pCallback == NULL)
    677            {
    678              /* Update the error code */
    679              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    680          
    681              return HAL_ERROR;
    682            }
    683            /* Process locked */
    684            __HAL_LOCK(hi2c);
    685          
    686            if (HAL_I2C_STATE_READY == hi2c->State)
    687            {
    688              switch (CallbackID)
    689              {
    690                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    691                  hi2c->MasterTxCpltCallback = pCallback;
    692                  break;
    693          
    694                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    695                  hi2c->MasterRxCpltCallback = pCallback;
    696                  break;
    697          
    698                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    699                  hi2c->SlaveTxCpltCallback = pCallback;
    700                  break;
    701          
    702                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    703                  hi2c->SlaveRxCpltCallback = pCallback;
    704                  break;
    705          
    706                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    707                  hi2c->ListenCpltCallback = pCallback;
    708                  break;
    709          
    710                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    711                  hi2c->MemTxCpltCallback = pCallback;
    712                  break;
    713          
    714                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    715                  hi2c->MemRxCpltCallback = pCallback;
    716                  break;
    717          
    718                case HAL_I2C_ERROR_CB_ID :
    719                  hi2c->ErrorCallback = pCallback;
    720                  break;
    721          
    722                case HAL_I2C_ABORT_CB_ID :
    723                  hi2c->AbortCpltCallback = pCallback;
    724                  break;
    725          
    726                case HAL_I2C_MSPINIT_CB_ID :
    727                  hi2c->MspInitCallback = pCallback;
    728                  break;
    729          
    730                case HAL_I2C_MSPDEINIT_CB_ID :
    731                  hi2c->MspDeInitCallback = pCallback;
    732                  break;
    733          
    734                default :
    735                  /* Update the error code */
    736                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    737          
    738                  /* Return error status */
    739                  status =  HAL_ERROR;
    740                  break;
    741              }
    742            }
    743            else if (HAL_I2C_STATE_RESET == hi2c->State)
    744            {
    745              switch (CallbackID)
    746              {
    747                case HAL_I2C_MSPINIT_CB_ID :
    748                  hi2c->MspInitCallback = pCallback;
    749                  break;
    750          
    751                case HAL_I2C_MSPDEINIT_CB_ID :
    752                  hi2c->MspDeInitCallback = pCallback;
    753                  break;
    754          
    755                default :
    756                  /* Update the error code */
    757                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    758          
    759                  /* Return error status */
    760                  status =  HAL_ERROR;
    761                  break;
    762              }
    763            }
    764            else
    765            {
    766              /* Update the error code */
    767              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    768          
    769              /* Return error status */
    770              status =  HAL_ERROR;
    771            }
    772          
    773            /* Release Lock */
    774            __HAL_UNLOCK(hi2c);
    775            return status;
    776          }
    777          
    778          /**
    779            * @brief  Unregister an I2C Callback
    780            *         I2C callback is redirected to the weak predefined callback
    781            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    782            *                the configuration information for the specified I2C.
    783            * @param  CallbackID ID of the callback to be unregistered
    784            *         This parameter can be one of the following values:
    785            *         This parameter can be one of the following values:
    786            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    787            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    788            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    789            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    790            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    791            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    792            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    793            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    794            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    795            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    796            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    797            * @retval HAL status
    798            */
    799          HAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)
    800          {
    801            HAL_StatusTypeDef status = HAL_OK;
    802          
    803            /* Process locked */
    804            __HAL_LOCK(hi2c);
    805          
    806            if (HAL_I2C_STATE_READY == hi2c->State)
    807            {
    808              switch (CallbackID)
    809              {
    810                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    811                  hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    812                  break;
    813          
    814                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    815                  hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    816                  break;
    817          
    818                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    819                  hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */
    820                  break;
    821          
    822                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    823                  hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */
    824                  break;
    825          
    826                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    827                  hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */
    828                  break;
    829          
    830                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    831                  hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */
    832                  break;
    833          
    834                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    835                  hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */
    836                  break;
    837          
    838                case HAL_I2C_ERROR_CB_ID :
    839                  hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */
    840                  break;
    841          
    842                case HAL_I2C_ABORT_CB_ID :
    843                  hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    844                  break;
    845          
    846                case HAL_I2C_MSPINIT_CB_ID :
    847                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    848                  break;
    849          
    850                case HAL_I2C_MSPDEINIT_CB_ID :
    851                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    852                  break;
    853          
    854                default :
    855                  /* Update the error code */
    856                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    857          
    858                  /* Return error status */
    859                  status =  HAL_ERROR;
    860                  break;
    861              }
    862            }
    863            else if (HAL_I2C_STATE_RESET == hi2c->State)
    864            {
    865              switch (CallbackID)
    866              {
    867                case HAL_I2C_MSPINIT_CB_ID :
    868                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    869                  break;
    870          
    871                case HAL_I2C_MSPDEINIT_CB_ID :
    872                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    873                  break;
    874          
    875                default :
    876                  /* Update the error code */
    877                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    878          
    879                  /* Return error status */
    880                  status =  HAL_ERROR;
    881                  break;
    882              }
    883            }
    884            else
    885            {
    886              /* Update the error code */
    887              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    888          
    889              /* Return error status */
    890              status =  HAL_ERROR;
    891            }
    892          
    893            /* Release Lock */
    894            __HAL_UNLOCK(hi2c);
    895            return status;
    896          }
    897          
    898          /**
    899            * @brief  Register the Slave Address Match I2C Callback
    900            *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
    901            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    902            *                the configuration information for the specified I2C.
    903            * @param  pCallback pointer to the Address Match Callback function
    904            * @retval HAL status
    905            */
    906          HAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)
    907          {
    908            HAL_StatusTypeDef status = HAL_OK;
    909          
    910            if (pCallback == NULL)
    911            {
    912              /* Update the error code */
    913              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    914          
    915              return HAL_ERROR;
    916            }
    917            /* Process locked */
    918            __HAL_LOCK(hi2c);
    919          
    920            if (HAL_I2C_STATE_READY == hi2c->State)
    921            {
    922              hi2c->AddrCallback = pCallback;
    923            }
    924            else
    925            {
    926              /* Update the error code */
    927              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    928          
    929              /* Return error status */
    930              status =  HAL_ERROR;
    931            }
    932          
    933            /* Release Lock */
    934            __HAL_UNLOCK(hi2c);
    935            return status;
    936          }
    937          
    938          /**
    939            * @brief  UnRegister the Slave Address Match I2C Callback
    940            *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
    941            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    942            *                the configuration information for the specified I2C.
    943            * @retval HAL status
    944            */
    945          HAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)
    946          {
    947            HAL_StatusTypeDef status = HAL_OK;
    948          
    949            /* Process locked */
    950            __HAL_LOCK(hi2c);
    951          
    952            if (HAL_I2C_STATE_READY == hi2c->State)
    953            {
    954              hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */
    955            }
    956            else
    957            {
    958              /* Update the error code */
    959              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    960          
    961              /* Return error status */
    962              status =  HAL_ERROR;
    963            }
    964          
    965            /* Release Lock */
    966            __HAL_UNLOCK(hi2c);
    967            return status;
    968          }
    969          
    970          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    971          
    972          /**
    973            * @}
    974            */
    975          
    976          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    977           *  @brief   Data transfers functions
    978           *
    979          @verbatim
    980           ===============================================================================
    981                                ##### IO operation functions #####
    982           ===============================================================================
    983              [..]
    984              This subsection provides a set of functions allowing to manage the I2C data
    985              transfers.
    986          
    987              (#) There are two modes of transfer:
    988                 (++) Blocking mode : The communication is performed in the polling mode.
    989                      The status of all data processing is returned by the same function
    990                      after finishing transfer.
    991                 (++) No-Blocking mode : The communication is performed using Interrupts
    992                      or DMA. These functions return the status of the transfer startup.
    993                      The end of the data processing will be indicated through the
    994                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    995                      using DMA mode.
    996          
    997              (#) Blocking mode functions are :
    998                  (++) HAL_I2C_Master_Transmit()
    999                  (++) HAL_I2C_Master_Receive()
   1000                  (++) HAL_I2C_Slave_Transmit()
   1001                  (++) HAL_I2C_Slave_Receive()
   1002                  (++) HAL_I2C_Mem_Write()
   1003                  (++) HAL_I2C_Mem_Read()
   1004                  (++) HAL_I2C_IsDeviceReady()
   1005          
   1006              (#) No-Blocking mode functions with Interrupt are :
   1007                  (++) HAL_I2C_Master_Transmit_IT()
   1008                  (++) HAL_I2C_Master_Receive_IT()
   1009                  (++) HAL_I2C_Slave_Transmit_IT()
   1010                  (++) HAL_I2C_Slave_Receive_IT()
   1011                  (++) HAL_I2C_Mem_Write_IT()
   1012                  (++) HAL_I2C_Mem_Read_IT()
   1013                  (++) HAL_I2C_Master_Seq_Transmit_IT()
   1014                  (++) HAL_I2C_Master_Seq_Receive_IT()
   1015                  (++) HAL_I2C_Slave_Seq_Transmit_IT()
   1016                  (++) HAL_I2C_Slave_Seq_Receive_IT()
   1017                  (++) HAL_I2C_EnableListen_IT()
   1018                  (++) HAL_I2C_DisableListen_IT()
   1019                  (++) HAL_I2C_Master_Abort_IT()
   1020          
   1021              (#) No-Blocking mode functions with DMA are :
   1022                  (++) HAL_I2C_Master_Transmit_DMA()
   1023                  (++) HAL_I2C_Master_Receive_DMA()
   1024                  (++) HAL_I2C_Slave_Transmit_DMA()
   1025                  (++) HAL_I2C_Slave_Receive_DMA()
   1026                  (++) HAL_I2C_Mem_Write_DMA()
   1027                  (++) HAL_I2C_Mem_Read_DMA()
   1028                  (++) HAL_I2C_Master_Seq_Transmit_DMA()
   1029                  (++) HAL_I2C_Master_Seq_Receive_DMA()
   1030                  (++) HAL_I2C_Slave_Seq_Transmit_DMA()
   1031                  (++) HAL_I2C_Slave_Seq_Receive_DMA()
   1032          
   1033              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
   1034                  (++) HAL_I2C_MasterTxCpltCallback()
   1035                  (++) HAL_I2C_MasterRxCpltCallback()
   1036                  (++) HAL_I2C_SlaveTxCpltCallback()
   1037                  (++) HAL_I2C_SlaveRxCpltCallback()
   1038                  (++) HAL_I2C_MemTxCpltCallback()
   1039                  (++) HAL_I2C_MemRxCpltCallback()
   1040                  (++) HAL_I2C_AddrCallback()
   1041                  (++) HAL_I2C_ListenCpltCallback()
   1042                  (++) HAL_I2C_ErrorCallback()
   1043                  (++) HAL_I2C_AbortCpltCallback()
   1044          
   1045          @endverbatim
   1046            * @{
   1047            */
   1048          
   1049          /**
   1050            * @brief  Transmits in master mode an amount of data in blocking mode.
   1051            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1052            *                the configuration information for the specified I2C.
   1053            * @param  DevAddress Target device address: The device 7 bits address value
   1054            *         in datasheet must be shifted to the left before calling the interface
   1055            * @param  pData Pointer to data buffer
   1056            * @param  Size Amount of data to be sent
   1057            * @param  Timeout Timeout duration
   1058            * @retval HAL status
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1061          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine50
   1062            uint32_t tickstart;
   1063          
   1064            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_104: (+1)
   \        0x8   0xD13C             BNE.N    ??HAL_I2C_Master_Transmit_0
   1065            {
   1066              /* Process Locked */
   1067              __HAL_LOCK(hi2c);
   \        0xA   0x7821             LDRB     R1,[R4, #+0]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD039             BEQ.N    ??HAL_I2C_Master_Transmit_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x7020             STRB     R0,[R4, #+0]
   1068          
   1069              /* Init tickstart for timeout management*/
   1070              tickstart = HAL_GetTick();
   \       0x14   0x.... 0x....      BL       HAL_GetTick
   \       0x18   0x.... 0x....      BL       ?Subroutine54
   1071          
   1072              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_115: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD138             BNE.N    ??HAL_I2C_Master_Transmit_1
   1073              {
   1074                return HAL_ERROR;
   1075              }
   1076          
   1077              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x20   0x2021             MOVS     R0,#+33
   1078              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x7060             STRB     R0,[R4, #+1]
   1079              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x70A1             STRB     R1,[R4, #+2]
   1080          
   1081              /* Prepare transfer parameters */
   1082              hi2c->pBuffPtr  = pData;
   1083              hi2c->XferCount = Size;
   1084              hi2c->XferISR   = NULL;
   1085          
   1086              /* Send Slave Address */
   1087              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1088              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x80002000
   \       0x2E   0x.... 0x....      BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_145: (+1)
   \       0x32   0xBF28             IT       CS 
   \       0x34   0x8535             STRHCS   R5,[R6, #+40]
   1089              {
   1090                hi2c->XferSize = MAX_NBYTE_SIZE;
   1091                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \       0x36   0xD205             BCS.N    ??HAL_I2C_Master_Transmit_2
   1092              }
   1093              else
   1094              {
   1095                hi2c->XferSize = hi2c->XferCount;
   \       0x38   0x8D72             LDRH     R2,[R6, #+42]
   1096                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   1097              }
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \       0x3A   0x.... 0x....      BL       ??Subroutine73_0
   \                     ??CrossCallReturnLabel_165: (+1)
   \       0x3E   0xE005             B.N      ??HAL_I2C_Master_Transmit_4
   1098          
   1099              while (hi2c->XferCount > 0U)
   1100              {
   1101                /* Wait until TXIS flag is set */
   1102                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1103                {
   1104                  return HAL_ERROR;
   1105                }
   1106                /* Write data to TXDR */
   1107                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   1108          
   1109                /* Increment Buffer pointer */
   1110                hi2c->pBuffPtr++;
   1111          
   1112                hi2c->XferCount--;
   1113                hi2c->XferSize--;
   1114          
   1115                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   1116                {
   1117                  /* Wait until TCR flag is set */
   1118                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   1119                  {
   1120                    return HAL_ERROR;
   1121                  }
   1122          
   1123                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1124                  {
   1125                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \       0x40   0x8535             STRH     R5,[R6, #+40]
   1126                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x4A   0x22FF             MOVS     R2,#+255
   1127                  }
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \       0x4C   0x.... 0x....      BL       ?Subroutine57
   \                     ??CrossCallReturnLabel_127: (+1)
   \       0x50   0x.... 0x....      BL       ?Subroutine76
   \                     ??CrossCallReturnLabel_169: (+1)
   \       0x54   0xD019             BEQ.N    ??HAL_I2C_Master_Transmit_6
   \       0x56   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD119             BNE.N    ??HAL_I2C_Master_Transmit_1
   \       0x5E   0x.... 0x....      BL       ?Subroutine72
   \                     ??CrossCallReturnLabel_161: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD0F4             BEQ.N    ??CrossCallReturnLabel_127
   \       0x66   0xB289             UXTH     R1,R1
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD1F1             BNE.N    ??CrossCallReturnLabel_127
   \       0x6C   0x.... 0x....      BL       ?Subroutine56
   \                     ??CrossCallReturnLabel_121: (+1)
   \       0x70   0xB978             CBNZ.N   R0,??HAL_I2C_Master_Transmit_1
   \       0x72   0x.... 0x....      BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_171: (+1)
   \       0x76   0xD2E3             BCS.N    ??HAL_I2C_Master_Transmit_5
   1128                  else
   1129                  {
   1130                    hi2c->XferSize = hi2c->XferCount;
   \       0x78   0x8D72             LDRH     R2,[R6, #+42]
   1131                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE7DD             B.N      ??HAL_I2C_Master_Transmit_3
   1132                  }
   1133                }
   1134              }
   1135          
   1136              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1137              /* Wait until STOPF flag is set */
   1138              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1139              {
   1140                return HAL_ERROR;
   1141              }
   1142          
   1143              /* Clear STOP Flag */
   1144              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \       0x7E   0x.... 0x....      BL       ?Subroutine49
   1145          
   1146              /* Clear Configuration Register 2 */
   1147              I2C_RESET_CR2(hi2c);
   1148          
   1149              hi2c->State = HAL_I2C_STATE_READY;
   1150              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1151          
   1152              /* Process Unlocked */
   1153              __HAL_UNLOCK(hi2c);
   1154          
   1155              return HAL_OK;
   \                     ??CrossCallReturnLabel_102: (+1)
   \       0x82   0xE000             B.N      ??HAL_I2C_Master_Transmit_8
   1156            }
   1157            else
   1158            {
   1159              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \       0x84   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \       0x86   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1160            }
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \       0x8A   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD0F5             BEQ.N    ??HAL_I2C_Master_Transmit_7
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xE7F7             B.N      ??HAL_I2C_Master_Transmit_8
   1161          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine76: (+1)
   \        0x0   0x8D70             LDRH     R0,[R6, #+42]
   \        0x2   0x464A             MOV      R2,R9
   \        0x4   0x4639             MOV      R1,R7
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine64: (+1)
   \        0x0   0x6062             STR      R2,[R4, #+4]
   \        0x2   0x6275             STR      R5,[R6, #+36]
   \        0x4   0x25FF             MOVS     R5,#+255
   \        0x6   0x8577             STRH     R7,[R6, #+42]
   \        0x8   0x6372             STR      R2,[R6, #+52]
   \        0xA   0x9F08             LDR      R7,[SP, #+32]
   \        0xC   0x8D71             LDRH     R1,[R6, #+42]
   \        0xE   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0440      ADD      R4,R6,#+64
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461F             MOV      R7,R3
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \        0x0   0x6832             LDR      R2,[R6, #+0]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0xfe00e800
   \        0x8   0x61D1             STR      R1,[R2, #+28]
   \        0xA   0x6831             LDR      R1,[R6, #+0]
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x684B             LDR      R3,[R1, #+4]
   \       0x10   0x4003             ANDS     R3,R0,R3
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x604B             STR      R3,[R1, #+4]
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x7061             STRB     R1,[R4, #+1]
   \       0x1A   0x70A2             STRB     R2,[R4, #+2]
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine77: (+1)
   \        0x0   0x8D70             LDRH     R0,[R6, #+42]
   \        0x2   0xF5B0 0x7F80      CMP      R0,#+256
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine73: (+1)
   \        0x0   0x8D72             LDRH     R2,[R6, #+42]
   \                     ??Subroutine73_0: (+1)
   \        0x2   0xF04F 0x7300      MOV      R3,#+33554432
   \        0x6   0x8532             STRH     R2,[R6, #+40]
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine72: (+1)
   \        0x0   0x6A70             LDR      R0,[R6, #+36]
   \        0x2   0x6832             LDR      R2,[R6, #+0]
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x6291             STR      R1,[R2, #+40]
   \        0x8   0x6A73             LDR      R3,[R6, #+36]
   \        0xA   0x1C58             ADDS     R0,R3,#+1
   \        0xC   0x6270             STR      R0,[R6, #+36]
   \        0xE   0x8D71             LDRH     R1,[R6, #+42]
   \       0x10   0x1E4A             SUBS     R2,R1,#+1
   \       0x12   0x8572             STRH     R2,[R6, #+42]
   \       0x14   0x8D33             LDRH     R3,[R6, #+40]
   \       0x16   0x1E59             SUBS     R1,R3,#+1
   \       0x18   0x8531             STRH     R1,[R6, #+40]
   \       0x1A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine57: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine56: (+1)
   \        0x0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \        0x4   0x463B             MOV      R3,R7
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2180             MOVS     R1,#+128
   \        0xA   0x4630             MOV      R0,R6
   \        0xC   0x.... 0x....      B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine54: (+1)
   \        0x0   0x4681             MOV      R9,R0
   \        0x2   0x2319             MOVS     R3,#+25
   \        0x4   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF44F 0x4100      MOV      R1,#+32768
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x.... 0x....      B.W      I2C_WaitOnFlagUntilTimeout
   1162          
   1163          /**
   1164            * @brief  Receives in master mode an amount of data in blocking mode.
   1165            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1166            *                the configuration information for the specified I2C.
   1167            * @param  DevAddress Target device address: The device 7 bits address value
   1168            *         in datasheet must be shifted to the left before calling the interface
   1169            * @param  pData Pointer to data buffer
   1170            * @param  Size Amount of data to be sent
   1171            * @param  Timeout Timeout duration
   1172            * @retval HAL status
   1173            */

   \                                 In section .text, align 2, keep-with-next
   1174          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1175          {
   \                     HAL_I2C_Master_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine50
   1176            uint32_t tickstart;
   1177          
   1178            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_105: (+1)
   \        0x8   0xD13C             BNE.N    ??HAL_I2C_Master_Receive_0
   1179            {
   1180              /* Process Locked */
   1181              __HAL_LOCK(hi2c);
   \        0xA   0x7821             LDRB     R1,[R4, #+0]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD039             BEQ.N    ??HAL_I2C_Master_Receive_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x7020             STRB     R0,[R4, #+0]
   1182          
   1183              /* Init tickstart for timeout management*/
   1184              tickstart = HAL_GetTick();
   \       0x14   0x.... 0x....      BL       HAL_GetTick
   \       0x18   0x.... 0x....      BL       ?Subroutine54
   1185          
   1186              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_114: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD138             BNE.N    ??HAL_I2C_Master_Receive_1
   1187              {
   1188                return HAL_ERROR;
   1189              }
   1190          
   1191              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x20   0x2022             MOVS     R0,#+34
   1192              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x7060             STRB     R0,[R4, #+1]
   1193              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x70A1             STRB     R1,[R4, #+2]
   1194          
   1195              /* Prepare transfer parameters */
   1196              hi2c->pBuffPtr  = pData;
   1197              hi2c->XferCount = Size;
   1198              hi2c->XferISR   = NULL;
   1199          
   1200              /* Send Slave Address */
   1201              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1202              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x80002400
   \       0x2E   0x.... 0x....      BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_146: (+1)
   \       0x32   0xBF28             IT       CS 
   \       0x34   0x8535             STRHCS   R5,[R6, #+40]
   1203              {
   1204                hi2c->XferSize = MAX_NBYTE_SIZE;
   1205                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \       0x36   0xD205             BCS.N    ??HAL_I2C_Master_Receive_2
   1206              }
   1207              else
   1208              {
   1209                hi2c->XferSize = hi2c->XferCount;
   \       0x38   0x8D72             LDRH     R2,[R6, #+42]
   1210                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   1211              }
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \       0x3A   0x.... 0x....      BL       ??Subroutine73_0
   \                     ??CrossCallReturnLabel_166: (+1)
   \       0x3E   0xE005             B.N      ??HAL_I2C_Master_Receive_4
   1212          
   1213              while (hi2c->XferCount > 0U)
   1214              {
   1215                /* Wait until RXNE flag is set */
   1216                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1217                {
   1218                  return HAL_ERROR;
   1219                }
   1220          
   1221                /* Read data from RXDR */
   1222                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   1223          
   1224                /* Increment Buffer pointer */
   1225                hi2c->pBuffPtr++;
   1226          
   1227                hi2c->XferSize--;
   1228                hi2c->XferCount--;
   1229          
   1230                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   1231                {
   1232                  /* Wait until TCR flag is set */
   1233                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   1234                  {
   1235                    return HAL_ERROR;
   1236                  }
   1237          
   1238                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1239                  {
   1240                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \       0x40   0x8535             STRH     R5,[R6, #+40]
   1241                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x4A   0x22FF             MOVS     R2,#+255
   1242                  }
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \       0x4C   0x.... 0x....      BL       ?Subroutine57
   \                     ??CrossCallReturnLabel_126: (+1)
   \       0x50   0x.... 0x....      BL       ?Subroutine76
   \                     ??CrossCallReturnLabel_170: (+1)
   \       0x54   0xD019             BEQ.N    ??HAL_I2C_Master_Receive_6
   \       0x56   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD119             BNE.N    ??HAL_I2C_Master_Receive_1
   \       0x5E   0x.... 0x....      BL       ?Subroutine78
   \                     ??CrossCallReturnLabel_175: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD0F4             BEQ.N    ??CrossCallReturnLabel_126
   \       0x66   0xB289             UXTH     R1,R1
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD1F1             BNE.N    ??CrossCallReturnLabel_126
   \       0x6C   0x.... 0x....      BL       ?Subroutine56
   \                     ??CrossCallReturnLabel_120: (+1)
   \       0x70   0xB978             CBNZ.N   R0,??HAL_I2C_Master_Receive_1
   \       0x72   0x.... 0x....      BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_172: (+1)
   \       0x76   0xD2E3             BCS.N    ??HAL_I2C_Master_Receive_5
   1243                  else
   1244                  {
   1245                    hi2c->XferSize = hi2c->XferCount;
   \       0x78   0x8D72             LDRH     R2,[R6, #+42]
   1246                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE7DD             B.N      ??HAL_I2C_Master_Receive_3
   1247                  }
   1248                }
   1249              }
   1250          
   1251              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1252              /* Wait until STOPF flag is set */
   1253              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1254              {
   1255                return HAL_ERROR;
   1256              }
   1257          
   1258              /* Clear STOP Flag */
   1259              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \       0x7E   0x.... 0x....      BL       ?Subroutine49
   1260          
   1261              /* Clear Configuration Register 2 */
   1262              I2C_RESET_CR2(hi2c);
   1263          
   1264              hi2c->State = HAL_I2C_STATE_READY;
   1265              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1266          
   1267              /* Process Unlocked */
   1268              __HAL_UNLOCK(hi2c);
   1269          
   1270              return HAL_OK;
   \                     ??CrossCallReturnLabel_103: (+1)
   \       0x82   0xE000             B.N      ??HAL_I2C_Master_Receive_8
   1271            }
   1272            else
   1273            {
   1274              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \       0x84   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \       0x86   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1275            }
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \       0x8A   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD0F5             BEQ.N    ??HAL_I2C_Master_Receive_7
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xE7F7             B.N      ??HAL_I2C_Master_Receive_8
   1276          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine78: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6A41             LDR      R1,[R0, #+36]
   \        0x4   0x6A72             LDR      R2,[R6, #+36]
   \        0x6   0x7011             STRB     R1,[R2, #+0]
   \        0x8   0x8D31             LDRH     R1,[R6, #+40]
   \        0xA   0x6A70             LDR      R0,[R6, #+36]
   \        0xC   0x1C43             ADDS     R3,R0,#+1
   \        0xE   0x6273             STR      R3,[R6, #+36]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x8531             STRH     R1,[R6, #+40]
   \       0x14   0x8D72             LDRH     R2,[R6, #+42]
   \       0x16   0x1E53             SUBS     R3,R2,#+1
   \       0x18   0x8573             STRH     R3,[R6, #+42]
   \       0x1A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x1C   0x4770             BX       LR
   1277          
   1278          /**
   1279            * @brief  Transmits in slave mode an amount of data in blocking mode.
   1280            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1281            *                the configuration information for the specified I2C.
   1282            * @param  pData Pointer to data buffer
   1283            * @param  Size Amount of data to be sent
   1284            * @param  Timeout Timeout duration
   1285            * @retval HAL status
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1288          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine53
   1289            uint32_t tickstart;
   1290          
   1291            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_110: (+1)
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD14C             BNE.N    ??HAL_I2C_Slave_Transmit_0
   1292            {
   1293              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xBF18             IT       NE 
   \       0x14   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x18   0xD103             BNE.N    ??HAL_I2C_Slave_Transmit_1
   1294              {
   1295                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x1A   0xF44F 0x7000      MOV      R0,#+512
   \       0x1E   0x6068             STR      R0,[R5, #+4]
   1296                return  HAL_ERROR;
   \       0x20   0xE03E             B.N      ??CrossCallReturnLabel_71
   1297              }
   1298              /* Process Locked */
   1299              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \       0x22   0x7829             LDRB     R1,[R5, #+0]
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xD040             BEQ.N    ??HAL_I2C_Slave_Transmit_0
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7028             STRB     R0,[R5, #+0]
   1300          
   1301              /* Init tickstart for timeout management*/
   1302              tickstart = HAL_GetTick();
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   1303          
   1304              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x30   0x2121             MOVS     R1,#+33
   \       0x32   0x.... 0x....      BL       ?Subroutine81
   1305              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1306              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1307          
   1308              /* Prepare transfer parameters */
   1309              hi2c->pBuffPtr  = pData;
   1310              hi2c->XferCount = Size;
   1311              hi2c->XferISR   = NULL;
   1312          
   1313              /* Enable Address Acknowledge */
   1314              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1315          
   1316              /* Wait until ADDR flag is set */
   1317              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_183: (+1)
   \       0x36   0x4643             MOV      R3,R8
   \       0x38   0xF8A6 0x902A      STRH     R9,[R6, #+42]
   \       0x3C   0x.... 0x....      BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x40   0xBB60             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_2
   1318              {
   1319                /* Disable Address Acknowledge */
   1320                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1321                return HAL_ERROR;
   1322              }
   1323          
   1324              /* Clear ADDR flag */
   1325              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x42   0x6831             LDR      R1,[R6, #+0]
   \       0x44   0x2008             MOVS     R0,#+8
   \       0x46   0x61C8             STR      R0,[R1, #+28]
   1326          
   1327              /* If 10bit addressing mode is selected */
   1328              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x48   0x68F2             LDR      R2,[R6, #+12]
   \       0x4A   0x2A02             CMP      R2,#+2
   \       0x4C   0xD109             BNE.N    ??HAL_I2C_Slave_Transmit_3
   1329              {
   1330                /* Wait until ADDR flag is set */
   1331                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x4E   0x9700             STR      R7,[SP, #+0]
   \       0x50   0x4643             MOV      R3,R8
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x2108             MOVS     R1,#+8
   \       0x56   0x.... 0x....      BL       ??Subroutine58_0
   \                     ??CrossCallReturnLabel_130: (+1)
   \       0x5A   0xB9F8             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_2
   1332                {
   1333                  /* Disable Address Acknowledge */
   1334                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1335                  return HAL_ERROR;
   1336                }
   1337          
   1338                /* Clear ADDR flag */
   1339                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x5C   0x6831             LDR      R1,[R6, #+0]
   \       0x5E   0x2008             MOVS     R0,#+8
   \       0x60   0x61C8             STR      R0,[R1, #+28]
   1340              }
   1341          
   1342              /* Wait until DIR flag is set Transmitter mode */
   1343              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \       0x62   0x9700             STR      R7,[SP, #+0]
   \       0x64   0x4643             MOV      R3,R8
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0xF44F 0x3180      MOV      R1,#+65536
   \       0x6C   0x.... 0x....      BL       ??Subroutine58_0
   \                     ??CrossCallReturnLabel_129: (+1)
   \       0x70   0xB150             CBZ.N    R0,??HAL_I2C_Slave_Transmit_4
   1344              {
   1345                /* Disable Address Acknowledge */
   1346                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0x72   0xE013             B.N      ??HAL_I2C_Slave_Transmit_2
   1347                return HAL_ERROR;
   1348              }
   1349          
   1350              while (hi2c->XferCount > 0U)
   1351              {
   1352                /* Wait until TXIS flag is set */
   1353                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1354                {
   1355                  /* Disable Address Acknowledge */
   1356                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1357                  return HAL_ERROR;
   1358                }
   1359          
   1360                /* Write data to TXDR */
   1361                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \       0x74   0x6A70             LDR      R0,[R6, #+36]
   \       0x76   0x6832             LDR      R2,[R6, #+0]
   \       0x78   0x7801             LDRB     R1,[R0, #+0]
   \       0x7A   0x6291             STR      R1,[R2, #+40]
   1362          
   1363                /* Increment Buffer pointer */
   1364                hi2c->pBuffPtr++;
   \       0x7C   0x6A73             LDR      R3,[R6, #+36]
   \       0x7E   0x1C58             ADDS     R0,R3,#+1
   \       0x80   0x6270             STR      R0,[R6, #+36]
   1365          
   1366                hi2c->XferCount--;
   \       0x82   0x8D71             LDRH     R1,[R6, #+42]
   \       0x84   0x1E4A             SUBS     R2,R1,#+1
   \       0x86   0x8572             STRH     R2,[R6, #+42]
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \       0x88   0x8D70             LDRH     R0,[R6, #+42]
   \       0x8A   0x463A             MOV      R2,R7
   \       0x8C   0x4641             MOV      R1,R8
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0xD00D             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   \       0x94   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD0EB             BEQ.N    ??HAL_I2C_Slave_Transmit_5
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \       0x9C   0x.... 0x....      BL       ??Subroutine37_0
   1367              }
   1368          
   1369              /* Wait until STOP flag is set */
   1370              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1371              {
   1372                /* Disable Address Acknowledge */
   1373                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1374          
   1375                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1376                {
   1377                  /* Normal use case for Transmitter mode */
   1378                  /* A NACK is generated to confirm the end of transfer */
   1379                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1380                }
   1381                else
   1382                {
   1383                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE003             B.N      ??HAL_I2C_Slave_Transmit_7
   1384                }
   1385              }
   1386          
   1387              /* Clear STOP flag */
   1388              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   1389          
   1390              /* Wait until BUSY flag is reset */
   1391              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
   1392              {
   1393                /* Disable Address Acknowledge */
   1394                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1395                return HAL_ERROR;
   1396              }
   1397          
   1398              /* Disable Address Acknowledge */
   1399              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1400          
   1401              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \       0xA4   0x.... 0x....      BL       ?Subroutine45
   1402              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1403          
   1404              /* Process Unlocked */
   1405              __HAL_UNLOCK(hi2c);
   1406          
   1407              return HAL_OK;
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0xA8   0xE000             B.N      ??HAL_I2C_Slave_Transmit_7
   1408            }
   1409            else
   1410            {
   1411              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \       0xAA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \       0xAC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1412            }
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \       0xB0   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0xB4   0xB130             CBZ.N    R0,??HAL_I2C_Slave_Transmit_9
   \       0xB6   0x.... 0x....      BL       ??Subroutine37_0
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0xBA   0x6868             LDR      R0,[R5, #+4]
   \       0xBC   0x2804             CMP      R0,#+4
   \       0xBE   0xD1EF             BNE.N    ??CrossCallReturnLabel_71
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0x6069             STR      R1,[R5, #+4]
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \       0xC4   0x6832             LDR      R2,[R6, #+0]
   \       0xC6   0x2020             MOVS     R0,#+32
   \       0xC8   0x4643             MOV      R3,R8
   \       0xCA   0xF44F 0x4100      MOV      R1,#+32768
   \       0xCE   0x61D0             STR      R0,[R2, #+28]
   \       0xD0   0x2201             MOVS     R2,#+1
   \       0xD2   0x.... 0x....      BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_133: (+1)
   \       0xD6   0x.... 0x....      BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0xDA   0xD0E3             BEQ.N    ??HAL_I2C_Slave_Transmit_8
   \       0xDC   0xE7E0             B.N      ??CrossCallReturnLabel_71
   1413          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine81: (+1)
   \        0x0   0x4607             MOV      R7,R0
   \        0x2   0x7069             STRB     R1,[R5, #+1]
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0x70AA             STRB     R2,[R5, #+2]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x6068             STR      R0,[R5, #+4]
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6274             STR      R4,[R6, #+36]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine53: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0540      ADD      R5,R6,#+64
   \        0x6   0x7868             LDRB     R0,[R5, #+1]
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7068             STRB     R0,[R5, #+1]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x70AA             STRB     R2,[R5, #+2]
   \        0xA   0x702A             STRB     R2,[R5, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \        0x0   0x6371             STR      R1,[R6, #+52]
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0x2108             MOVS     R1,#+8
   \        0x6   0x6842             LDR      R2,[R0, #+4]
   \        0x8   0xF422 0x4200      BIC      R2,R2,#0x8000
   \        0xC   0x6042             STR      R2,[R0, #+4]
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x9700             STR      R7,[SP, #+0]
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0x.... 0x....      B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine58: (+1)
   \        0x0   0x9700             STR      R7,[SP, #+0]
   \                     ??Subroutine58_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \                     ??Subroutine37_0: (+1)
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine37_1: (+1)
   \        0x4   0x6841             LDR      R1,[R0, #+4]
   \        0x6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0xA   0x6041             STR      R1,[R0, #+4]
   \        0xC   0x4770             BX       LR
   1414          
   1415          /**
   1416            * @brief  Receive in slave mode an amount of data in blocking mode
   1417            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1418            *                the configuration information for the specified I2C.
   1419            * @param  pData Pointer to data buffer
   1420            * @param  Size Amount of data to be sent
   1421            * @param  Timeout Timeout duration
   1422            * @retval HAL status
   1423            */

   \                                 In section .text, align 2, keep-with-next
   1424          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1425          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine53
   1426            uint32_t tickstart;
   1427          
   1428            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_111: (+1)
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD159             BNE.N    ??HAL_I2C_Slave_Receive_0
   1429            {
   1430              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xBF18             IT       NE 
   \       0x14   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x18   0xD103             BNE.N    ??HAL_I2C_Slave_Receive_1
   1431              {
   1432                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x1A   0xF44F 0x7000      MOV      R0,#+512
   \       0x1E   0x6068             STR      R0,[R5, #+4]
   1433                return  HAL_ERROR;
   \       0x20   0xE04B             B.N      ??HAL_I2C_Slave_Receive_2
   1434              }
   1435              /* Process Locked */
   1436              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \       0x22   0x7829             LDRB     R1,[R5, #+0]
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xD04D             BEQ.N    ??HAL_I2C_Slave_Receive_0
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7028             STRB     R0,[R5, #+0]
   1437          
   1438              /* Init tickstart for timeout management*/
   1439              tickstart = HAL_GetTick();
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   1440          
   1441              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x30   0x2122             MOVS     R1,#+34
   \       0x32   0x.... 0x....      BL       ?Subroutine81
   1442              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1443              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1444          
   1445              /* Prepare transfer parameters */
   1446              hi2c->pBuffPtr  = pData;
   1447              hi2c->XferCount = Size;
   1448              hi2c->XferISR   = NULL;
   1449          
   1450              /* Enable Address Acknowledge */
   1451              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1452          
   1453              /* Wait until ADDR flag is set */
   1454              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_184: (+1)
   \       0x36   0x464B             MOV      R3,R9
   \       0x38   0xF8A6 0x802A      STRH     R8,[R6, #+42]
   \       0x3C   0x.... 0x....      BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD146             BNE.N    ??HAL_I2C_Slave_Receive_3
   1455              {
   1456                /* Disable Address Acknowledge */
   1457                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1458                return HAL_ERROR;
   1459              }
   1460          
   1461              /* Clear ADDR flag */
   1462              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x44   0x6831             LDR      R1,[R6, #+0]
   \       0x46   0x2008             MOVS     R0,#+8
   1463          
   1464              /* Wait until DIR flag is reset Receiver mode */
   1465              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
   \       0x48   0x464B             MOV      R3,R9
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0x61C8             STR      R0,[R1, #+28]
   \       0x4E   0xF44F 0x3180      MOV      R1,#+65536
   \       0x52   0x.... 0x....      BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_132: (+1)
   \       0x56   0xB148             CBZ.N    R0,??HAL_I2C_Slave_Receive_4
   1466              {
   1467                /* Disable Address Acknowledge */
   1468                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0x58   0xE03B             B.N      ??HAL_I2C_Slave_Receive_3
   1469                return HAL_ERROR;
   1470              }
   1471          
   1472              while (hi2c->XferCount > 0U)
   1473              {
   1474                /* Wait until RXNE flag is set */
   1475                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1476                {
   1477                  /* Disable Address Acknowledge */
   1478                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1479          
   1480                  /* Store Last receive data if any */
   1481                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   1482                  {
   1483                    /* Read data from RXDR */
   1484                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   1485          
   1486                    /* Increment Buffer pointer */
   1487                    hi2c->pBuffPtr++;
   1488          
   1489                    hi2c->XferCount--;
   1490                  }
   1491          
   1492                  return HAL_ERROR;
   1493                }
   1494          
   1495                /* Read data from RXDR */
   1496                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \       0x5A   0x6A41             LDR      R1,[R0, #+36]
   \       0x5C   0x6A72             LDR      R2,[R6, #+36]
   \       0x5E   0x7011             STRB     R1,[R2, #+0]
   1497          
   1498                /* Increment Buffer pointer */
   1499                hi2c->pBuffPtr++;
   \       0x60   0x6A70             LDR      R0,[R6, #+36]
   \       0x62   0x1C43             ADDS     R3,R0,#+1
   \       0x64   0x6273             STR      R3,[R6, #+36]
   1500          
   1501                hi2c->XferCount--;
   \       0x66   0x8D71             LDRH     R1,[R6, #+42]
   \       0x68   0x1E4A             SUBS     R2,R1,#+1
   \       0x6A   0x8572             STRH     R2,[R6, #+42]
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \       0x6C   0x8D70             LDRH     R0,[R6, #+42]
   \       0x6E   0x463A             MOV      R2,R7
   \       0x70   0x4649             MOV      R1,R9
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0x4630             MOV      R0,R6
   \       0x76   0xD028             BEQ.N    ??HAL_I2C_Slave_Receive_6
   \       0x78   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0x6830             LDR      R0,[R6, #+0]
   \       0x80   0xD0EB             BEQ.N    ??HAL_I2C_Slave_Receive_5
   \       0x82   0x.... 0x....      BL       ??Subroutine37_1
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0x6982             LDR      R2,[R0, #+24]
   \       0x8A   0x0751             LSLS     R1,R2,#+29
   \       0x8C   0xD515             BPL.N    ??HAL_I2C_Slave_Receive_2
   \       0x8E   0x6A40             LDR      R0,[R0, #+36]
   \       0x90   0x6A72             LDR      R2,[R6, #+36]
   \       0x92   0x7010             STRB     R0,[R2, #+0]
   \       0x94   0x6A71             LDR      R1,[R6, #+36]
   \       0x96   0x1C4B             ADDS     R3,R1,#+1
   \       0x98   0x6273             STR      R3,[R6, #+36]
   \       0x9A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x9C   0x1E42             SUBS     R2,R0,#+1
   \       0x9E   0x8572             STRH     R2,[R6, #+42]
   \       0xA0   0xE00B             B.N      ??HAL_I2C_Slave_Receive_2
   1502              }
   1503          
   1504              /* Wait until STOP flag is set */
   1505              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1506              {
   1507                /* Disable Address Acknowledge */
   1508                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1509                return HAL_ERROR;
   1510              }
   1511          
   1512              /* Clear STOP flag */
   1513              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \       0xA2   0x6831             LDR      R1,[R6, #+0]
   \       0xA4   0x2020             MOVS     R0,#+32
   1514          
   1515              /* Wait until BUSY flag is reset */
   1516              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
   \       0xA6   0x464B             MOV      R3,R9
   \       0xA8   0x2201             MOVS     R2,#+1
   \       0xAA   0x61C8             STR      R0,[R1, #+28]
   \       0xAC   0xF44F 0x4100      MOV      R1,#+32768
   \       0xB0   0x.... 0x....      BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_131: (+1)
   \       0xB4   0x.... 0x....      BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0xB8   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_8
   1517              {
   1518                /* Disable Address Acknowledge */
   1519                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1520                return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0xE003             B.N      ??HAL_I2C_Slave_Receive_9
   1521              }
   1522          
   1523              /* Disable Address Acknowledge */
   1524              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1525          
   1526              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \       0xBE   0x.... 0x....      BL       ?Subroutine45
   1527              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1528          
   1529              /* Process Unlocked */
   1530              __HAL_UNLOCK(hi2c);
   1531          
   1532              return HAL_OK;
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0xC2   0xE000             B.N      ??HAL_I2C_Slave_Receive_9
   1533            }
   1534            else
   1535            {
   1536              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \       0xC4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \       0xC6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1537            }
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \       0xCA   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD0E7             BEQ.N    ??HAL_I2C_Slave_Receive_7
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \       0xD2   0x.... 0x....      BL       ??Subroutine37_0
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0xD6   0xE7F0             B.N      ??HAL_I2C_Slave_Receive_2
   1538          }
   1539          
   1540          /**
   1541            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1542            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1543            *                the configuration information for the specified I2C.
   1544            * @param  DevAddress Target device address: The device 7 bits address value
   1545            *         in datasheet must be shifted to the left before calling the interface
   1546            * @param  pData Pointer to data buffer
   1547            * @param  Size Amount of data to be sent
   1548            * @retval HAL status
   1549            */

   \                                 In section .text, align 2, keep-with-next
   1550          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1551          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
   1552            uint32_t xfermode;
   1553          
   1554            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0x2820             CMP      R0,#+32
   \        0x8   0xD112             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1555            {
   1556              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0xA   0x6826             LDR      R6,[R4, #+0]
   \        0xC   0x69B7             LDR      R7,[R6, #+24]
   \        0xE   0x0438             LSLS     R0,R7,#+16
   \       0x10   0xD40E             BMI.N    ??HAL_I2C_Master_Transmit_IT_0
   1557              {
   1558                return HAL_BUSY;
   1559              }
   1560          
   1561              /* Process Locked */
   1562              __HAL_LOCK(hi2c);
   \       0x12   0x782E             LDRB     R6,[R5, #+0]
   \       0x14   0x2E01             CMP      R6,#+1
   \       0x16   0xD00B             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \       0x18   0x2701             MOVS     R7,#+1
   1563          
   1564              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x1A   0x2021             MOVS     R0,#+33
   \       0x1C   0x.... 0x....      BL       ?Subroutine28
   1565              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1566              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1567          
   1568              /* Prepare transfer parameters */
   1569              hi2c->pBuffPtr    = pData;
   1570              hi2c->XferCount   = Size;
   1571              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1572              hi2c->XferISR     = I2C_Master_ISR_IT;
   1573          
   1574              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1575              {
   1576                hi2c->XferSize = MAX_NBYTE_SIZE;
   1577                xfermode = I2C_RELOAD_MODE;
   1578              }
   1579              else
   1580              {
   1581                hi2c->XferSize = hi2c->XferCount;
   1582                xfermode = I2C_AUTOEND_MODE;
   1583              }
   1584          
   1585              /* Send Slave Address */
   1586              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   1587              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x20   0x.... 0x....      LDR.W    R6,??DataTable23  ;; 0x80002000
   \       0x24   0x.... 0x....      BL       ?Subroutine22
   1588          
   1589              /* Process Unlocked */
   1590              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x28   0x702F             STRB     R7,[R5, #+0]
   1591          
   1592              /* Note : The I2C interrupts must be enabled after unlocking current process
   1593                        to avoid the risk of I2C interrupt handle execution before current
   1594                        process unlock */
   1595          
   1596              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1597              /* possible to enable all of these */
   1598              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1599              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....             B.N      ??Subroutine0_0
   1600          
   1601              return HAL_OK;
   1602            }
   1603            else
   1604            {
   1605              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1606            }
   1607          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0x702F             STRB     R7,[R5, #+0]
   \        0x2   0x2610             MOVS     R6,#+16
   \        0x4   0x7068             STRB     R0,[R5, #+1]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x70AE             STRB     R6,[R5, #+2]
   \        0xA   0x6068             STR      R0,[R5, #+4]
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0xffff0000
   \       0x10   0x6262             STR      R2,[R4, #+36]
   \       0x12   0x.... 0x....      LDR.W    R2,??DataTable23_1
   \       0x16   0x8563             STRH     R3,[R4, #+42]
   \       0x18   0x62E0             STR      R0,[R4, #+44]
   \       0x1A   0x6362             STR      R2,[R4, #+52]
   \       0x1C   0x8D63             LDRH     R3,[R4, #+42]
   \       0x1E   0xF5B3 0x7F80      CMP      R3,#+256
   \       0x22   0xD304             BCC.N    ??Subroutine28_0
   \       0x24   0x20FF             MOVS     R0,#+255
   \       0x26   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x2A   0x8520             STRH     R0,[R4, #+40]
   \       0x2C   0x4770             BX       LR
   \                     ??Subroutine28_0: (+1)
   \       0x2E   0x8D62             LDRH     R2,[R4, #+42]
   \       0x30   0xF04F 0x7300      MOV      R3,#+33554432
   \       0x34   0x8522             STRH     R2,[R4, #+40]
   \                     ??Subroutine28_1: (+1)
   \       0x36   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x9600             STR      R6,[SP, #+0]
   \        0x4   0x8D22             LDRH     R2,[R4, #+40]
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0x.... 0x....      B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x62C2             STR      R2,[R0, #+44]
   \        0x2   0x6344             STR      R4,[R0, #+52]
   \        0x4   0x701F             STRB     R7,[R3, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0x6   0x.... 0x....      BL       I2C_Enable_IRQ
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}
   1608          
   1609          /**
   1610            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1611            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1612            *                the configuration information for the specified I2C.
   1613            * @param  DevAddress Target device address: The device 7 bits address value
   1614            *         in datasheet must be shifted to the left before calling the interface
   1615            * @param  pData Pointer to data buffer
   1616            * @param  Size Amount of data to be sent
   1617            * @retval HAL status
   1618            */

   \                                 In section .text, align 2, keep-with-next
   1619          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1620          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
   1621            uint32_t xfermode;
   1622          
   1623            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0x2820             CMP      R0,#+32
   \        0x8   0xD112             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1624            {
   1625              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0xA   0x6826             LDR      R6,[R4, #+0]
   \        0xC   0x69B7             LDR      R7,[R6, #+24]
   \        0xE   0x0438             LSLS     R0,R7,#+16
   \       0x10   0xD40E             BMI.N    ??HAL_I2C_Master_Receive_IT_0
   1626              {
   1627                return HAL_BUSY;
   1628              }
   1629          
   1630              /* Process Locked */
   1631              __HAL_LOCK(hi2c);
   \       0x12   0x782E             LDRB     R6,[R5, #+0]
   \       0x14   0x2E01             CMP      R6,#+1
   \       0x16   0xD00B             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \       0x18   0x2701             MOVS     R7,#+1
   1632          
   1633              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x1A   0x2022             MOVS     R0,#+34
   \       0x1C   0x.... 0x....      BL       ?Subroutine28
   1634              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1635              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1636          
   1637              /* Prepare transfer parameters */
   1638              hi2c->pBuffPtr    = pData;
   1639              hi2c->XferCount   = Size;
   1640              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1641              hi2c->XferISR     = I2C_Master_ISR_IT;
   1642          
   1643              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1644              {
   1645                hi2c->XferSize = MAX_NBYTE_SIZE;
   1646                xfermode = I2C_RELOAD_MODE;
   1647              }
   1648              else
   1649              {
   1650                hi2c->XferSize = hi2c->XferCount;
   1651                xfermode = I2C_AUTOEND_MODE;
   1652              }
   1653          
   1654              /* Send Slave Address */
   1655              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   1656              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x20   0x.... 0x....      LDR.W    R6,??DataTable19  ;; 0x80002400
   \       0x24   0x.... 0x....      BL       ?Subroutine22
   1657          
   1658              /* Process Unlocked */
   1659              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x28   0x702F             STRB     R7,[R5, #+0]
   1660          
   1661              /* Note : The I2C interrupts must be enabled after unlocking current process
   1662                        to avoid the risk of I2C interrupt handle execution before current
   1663                        process unlock */
   1664          
   1665              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1666              /* possible to enable all of these */
   1667              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1668              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x2A   0x2102             MOVS     R1,#+2
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....             B.N      ??Subroutine0_0
   1669          
   1670              return HAL_OK;
   1671            }
   1672            else
   1673            {
   1674              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1675            }
   1676          }
   1677          
   1678          /**
   1679            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
   1680            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1681            *                the configuration information for the specified I2C.
   1682            * @param  pData Pointer to data buffer
   1683            * @param  Size Amount of data to be sent
   1684            * @retval HAL status
   1685            */

   \                                 In section .text, align 2, keep-with-next
   1686          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1687          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1688            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0340      ADD      R3,R0,#+64
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD108             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1689            {
   1690              /* Process Locked */
   1691              __HAL_LOCK(hi2c);
   \        0xC   0x781D             LDRB     R5,[R3, #+0]
   \        0xE   0x2D01             CMP      R5,#+1
   \       0x10   0xD005             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \       0x12   0x2401             MOVS     R4,#+1
   1692          
   1693              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x14   0x2521             MOVS     R5,#+33
   \       0x16   0x.... 0x....      BL       ?Subroutine85
   1694              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1695              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1696          
   1697              /* Enable Address Acknowledge */
   1698              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1699          
   1700              /* Prepare transfer parameters */
   1701              hi2c->pBuffPtr    = pData;
   1702              hi2c->XferCount   = Size;
   1703              hi2c->XferSize    = hi2c->XferCount;
   1704              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1705              hi2c->XferISR     = I2C_Slave_ISR_IT;
   1706          
   1707              /* Process Unlocked */
   1708              __HAL_UNLOCK(hi2c);
   1709          
   1710              /* Note : The I2C interrupts must be enabled after unlocking current process
   1711                        to avoid the risk of I2C interrupt handle execution before current
   1712                        process unlock */
   1713          
   1714              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1715              /* possible to enable all of these */
   1716              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1717              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
   \                     ??CrossCallReturnLabel_195: (+1)
   \       0x1A   0x2105             MOVS     R1,#+5
   \       0x1C   0x....             B.N      ?Subroutine0
   1718          
   1719              return HAL_OK;
   1720            }
   1721            else
   1722            {
   1723              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1724            }
   1725          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine85: (+1)
   \        0x0   0x701C             STRB     R4,[R3, #+0]
   \        0x2   0x2620             MOVS     R6,#+32
   \        0x4   0x705D             STRB     R5,[R3, #+1]
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x709E             STRB     R6,[R3, #+2]
   \        0xA   0x605F             STR      R7,[R3, #+4]
   \        0xC   0x6804             LDR      R4,[R0, #+0]
   \        0xE   0x6865             LDR      R5,[R4, #+4]
   \       0x10   0xF425 0x4500      BIC      R5,R5,#0x8000
   \       0x14   0x6065             STR      R5,[R4, #+4]
   \       0x16   0x.... 0x....      LDR.W    R4,??DataTable23_2
   \       0x1A   0x6241             STR      R1,[R0, #+36]
   \       0x1C   0x8542             STRH     R2,[R0, #+42]
   \       0x1E   0x8D41             LDRH     R1,[R0, #+42]
   \       0x20   0x.... 0x....      LDR.W    R2,??DataTable22  ;; 0xffff0000
   \       0x24   0x8501             STRH     R1,[R0, #+40]
   \       0x26   0x4770             BX       LR
   1726          
   1727          /**
   1728            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
   1729            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1730            *                the configuration information for the specified I2C.
   1731            * @param  pData Pointer to data buffer
   1732            * @param  Size Amount of data to be sent
   1733            * @retval HAL status
   1734            */

   \                                 In section .text, align 2, keep-with-next
   1735          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1736          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1737            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0340      ADD      R3,R0,#+64
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD108             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1738            {
   1739              /* Process Locked */
   1740              __HAL_LOCK(hi2c);
   \        0xC   0x781D             LDRB     R5,[R3, #+0]
   \        0xE   0x2D01             CMP      R5,#+1
   \       0x10   0xD005             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \       0x12   0x2401             MOVS     R4,#+1
   1741          
   1742              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x14   0x2522             MOVS     R5,#+34
   \       0x16   0x.... 0x....      BL       ?Subroutine85
   1743              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1744              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1745          
   1746              /* Enable Address Acknowledge */
   1747              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1748          
   1749              /* Prepare transfer parameters */
   1750              hi2c->pBuffPtr    = pData;
   1751              hi2c->XferCount   = Size;
   1752              hi2c->XferSize    = hi2c->XferCount;
   1753              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1754              hi2c->XferISR     = I2C_Slave_ISR_IT;
   1755          
   1756              /* Process Unlocked */
   1757              __HAL_UNLOCK(hi2c);
   1758          
   1759              /* Note : The I2C interrupts must be enabled after unlocking current process
   1760                        to avoid the risk of I2C interrupt handle execution before current
   1761                        process unlock */
   1762          
   1763              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1764              /* possible to enable all of these */
   1765              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1766              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   \                     ??CrossCallReturnLabel_196: (+1)
   \       0x1A   0x2106             MOVS     R1,#+6
   \       0x1C   0x....             B.N      ?Subroutine0
   1767          
   1768              return HAL_OK;
   1769            }
   1770            else
   1771            {
   1772              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1773            }
   1774          }
   1775          
   1776          /**
   1777            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1778            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1779            *                the configuration information for the specified I2C.
   1780            * @param  DevAddress Target device address: The device 7 bits address value
   1781            *         in datasheet must be shifted to the left before calling the interface
   1782            * @param  pData Pointer to data buffer
   1783            * @param  Size Amount of data to be sent
   1784            * @retval HAL status
   1785            */

   \                                 In section .text, align 2, keep-with-next
   1786          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1787          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine8
   1788            uint32_t xfermode;
   1789            HAL_StatusTypeDef dmaxferstatus;
   1790          
   1791            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD14D             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1792            {
   1793              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \       0x10   0x6822             LDR      R2,[R4, #+0]
   \       0x12   0x6997             LDR      R7,[R2, #+24]
   \       0x14   0x0438             LSLS     R0,R7,#+16
   \       0x16   0xD449             BMI.N    ??HAL_I2C_Master_Transmit_DMA_0
   1794              {
   1795                return HAL_BUSY;
   1796              }
   1797          
   1798              /* Process Locked */
   1799              __HAL_LOCK(hi2c);
   \       0x18   0x782A             LDRB     R2,[R5, #+0]
   \       0x1A   0x2A01             CMP      R2,#+1
   \       0x1C   0xD046             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \       0x1E   0x2701             MOVS     R7,#+1
   1800          
   1801              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0x702F             STRB     R7,[R5, #+0]
   1802              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \       0x24   0x2210             MOVS     R2,#+16
   \       0x26   0x7068             STRB     R0,[R5, #+1]
   1803              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x28   0xF04F 0x0C00      MOV      R12,#+0
   \       0x2C   0x70AA             STRB     R2,[R5, #+2]
   1804          
   1805              /* Prepare transfer parameters */
   1806              hi2c->pBuffPtr    = pData;
   1807              hi2c->XferCount   = Size;
   1808              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0xffff0000
   \       0x32   0xF8C5 0xC004      STR      R12,[R5, #+4]
   1809              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x36   0x.... 0x....      LDR.W    R2,??DataTable23_3
   \       0x3A   0x6261             STR      R1,[R4, #+36]
   1810          
   1811              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x3C   0x.... 0x....      LDR.W    R7,??DataTable18  ;; 0x80002000
   \       0x40   0x8563             STRH     R3,[R4, #+42]
   \       0x42   0x62E0             STR      R0,[R4, #+44]
   \       0x44   0x6362             STR      R2,[R4, #+52]
   \       0x46   0x8D60             LDRH     R0,[R4, #+42]
   \       0x48   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x4C   0xD304             BCC.N    ??HAL_I2C_Master_Transmit_DMA_1
   1812              {
   1813                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x4E   0x22FF             MOVS     R2,#+255
   1814                xfermode = I2C_RELOAD_MODE;
   \       0x50   0xF04F 0x7880      MOV      R8,#+16777216
   \       0x54   0x8522             STRH     R2,[R4, #+40]
   \       0x56   0xE002             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1815              }
   1816              else
   1817              {
   1818                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \       0x58   0x.... 0x....      BL       ?Subroutine86
   1819                xfermode = I2C_AUTOEND_MODE;
   1820              }
   1821          
   1822              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_197: (+1)
   \       0x5C   0xD020             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_3
   1823              {
   1824                if (hi2c->hdmatx != NULL)
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \       0x5E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x60   0xB1B8             CBZ.N    R0,??HAL_I2C_Master_Transmit_DMA_4
   1825                {
   1826                  /* Set the I2C DMA transfer complete callback */
   1827                  hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x62   0x.... 0x....      LDR.W    R2,??DataTable24
   \       0x66   0x63C2             STR      R2,[R0, #+60]
   1828          
   1829                  /* Set the DMA error callback */
   1830                  hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x68   0x6BA3             LDR      R3,[R4, #+56]
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0x6E   0x64D8             STR      R0,[R3, #+76]
   1831          
   1832                  /* Set the unused DMA callbacks to NULL */
   1833                  hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x70   0x6BA0             LDR      R0,[R4, #+56]
   \       0x72   0xF8C0 0xC040      STR      R12,[R0, #+64]
   1834                  hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x76   0x6BA0             LDR      R0,[R4, #+56]
   \       0x78   0xF8C0 0xC050      STR      R12,[R0, #+80]
   1835          
   1836                  /* Enable the DMA stream */
   1837                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   1838                }
   1839                else
   1840                {
   1841                  /* Update I2C state */
   1842                  hi2c->State     = HAL_I2C_STATE_READY;
   1843                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1844          
   1845                  /* Update I2C error code */
   1846                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   1847          
   1848                  /* Process Unlocked */
   1849                  __HAL_UNLOCK(hi2c);
   1850          
   1851                  return HAL_ERROR;
   1852                }
   1853          
   1854                if (dmaxferstatus == HAL_OK)
   \       0x7C   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x80   0xB950             CBNZ.N   R0,??HAL_I2C_Master_Transmit_DMA_5
   1855                {
   1856                  /* Send Slave Address */
   1857                  /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1858                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
   \       0x82   0x.... 0x....      BL       ?Subroutine21
   1859          
   1860                  /* Update XferCount value */
   1861                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_229: (+1)
   \       0x86   0x.... 0x....      BL       ?Subroutine24
   1862          
   1863                  /* Process Unlocked */
   1864                  __HAL_UNLOCK(hi2c);
   1865          
   1866                  /* Note : The I2C interrupts must be enabled after unlocking current process
   1867                            to avoid the risk of I2C interrupt handle execution before current
   1868                            process unlock */
   1869                  /* Enable ERR and NACK interrupts */
   1870                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   1871          
   1872                  /* Enable DMA Request */
   1873                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x.... 0x....      BL       ?Subroutine34
   1874                }
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x90   0xE00A             B.N      ??CrossCallReturnLabel_51
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \       0x92   0x.... 0x....      BL       ?Subroutine29
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0x96   0xE001             B.N      ??CrossCallReturnLabel_149
   1875                else
   1876                {
   1877                  /* Update I2C state */
   1878                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \       0x98   0x.... 0x....      BL       ?Subroutine66
   1879                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1880          
   1881                  /* Update I2C error code */
   1882                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   1883          
   1884                  /* Process Unlocked */
   1885                  __HAL_UNLOCK(hi2c);
   1886          
   1887                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_149: (+1)
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xE006             B.N      ??HAL_I2C_Master_Transmit_DMA_6
   1888                }
   1889              }
   1890              else
   1891              {
   1892                /* Update Transfer ISR function pointer */
   1893                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \       0xA0   0x.... 0x....      BL       ?Subroutine26
   1894          
   1895                /* Send Slave Address */
   1896                /* Set NBYTES to write and generate START condition */
   1897                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   1898          
   1899                /* Process Unlocked */
   1900                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_225: (+1)
   \       0xA4   0x.... 0x....      BL       ?Subroutine25
   1901          
   1902                /* Note : The I2C interrupts must be enabled after unlocking current process
   1903                          to avoid the risk of I2C interrupt handle execution before current
   1904                          process unlock */
   1905                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1906                /* possible to enable all of these */
   1907                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1908                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   1909              }
   1910          
   1911              return HAL_OK;
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xE000             B.N      ??HAL_I2C_Master_Transmit_DMA_6
   1912            }
   1913            else
   1914            {
   1915              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \       0xAC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \       0xAE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1916            }
   1917          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \        0x4   0x4643             MOV      R3,R8
   \        0x6   0x6360             STR      R0,[R4, #+52]
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x9700             STR      R7,[SP, #+0]
   \        0xC                      REQUIRE ??Subroutine95_0
   \        0xC                      ;; // Fall through to label ??Subroutine95_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine95_0: (+1)
   \        0x0   0x4631             MOV      R1,R6
   \                     ??Subroutine95_1: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x9700             STR      R7,[SP, #+0]
   \        0x2   0x8D22             LDRH     R2,[R4, #+40]
   \        0x4   0x4643             MOV      R3,R8
   \        0x6   0x4631             MOV      R1,R6
   \        0x8                      REQUIRE ??Subroutine96_0
   \        0x8                      ;; // Fall through to label ??Subroutine96_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine96_0: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x.... 0x....      B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine86: (+1)
   \        0x0   0x8D60             LDRH     R0,[R4, #+42]
   \        0x2   0xF04F 0x7800      MOV      R8,#+33554432
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0x8520             STRH     R0,[R4, #+40]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine66: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7069             STRB     R1,[R5, #+1]
   \        0x6   0x70AA             STRB     R2,[R5, #+2]
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6068             STR      R0,[R5, #+4]
   \       0x10   0x702A             STRB     R2,[R5, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0xF885 0xC002      STRB     R12,[R5, #+2]
   \        0x8   0x6869             LDR      R1,[R5, #+4]
   \        0xA   0xF041 0x0180      ORR      R1,R1,#0x80
   \        0xE   0x6069             STR      R1,[R5, #+4]
   \       0x10   0xF885 0xC000      STRB     R12,[R5, #+0]
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x8D61             LDRH     R1,[R4, #+42]
   \        0x2   0x8D20             LDRH     R0,[R4, #+40]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x1A09             SUBS     R1,R1,R0
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x8561             STRH     R1,[R4, #+42]
   \        0xC   0x2111             MOVS     R1,#+17
   \        0xE   0x702A             STRB     R2,[R5, #+0]
   \       0x10   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x2101             MOVS     R1,#+1
   \                     ??Subroutine25_0: (+1)
   \        0x4   0x7028             STRB     R0,[R5, #+0]
   \                     ??Subroutine25_1: (+1)
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x8D23             LDRH     R3,[R4, #+40]
   \        0x4   0xF100 0x0228      ADD      R2,R0,#+40
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x.... 0x....      B.W      HAL_DMA_Start_IT
   1918          
   1919          /**
   1920            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
   1921            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1922            *                the configuration information for the specified I2C.
   1923            * @param  DevAddress Target device address: The device 7 bits address value
   1924            *         in datasheet must be shifted to the left before calling the interface
   1925            * @param  pData Pointer to data buffer
   1926            * @param  Size Amount of data to be sent
   1927            * @retval HAL status
   1928            */

   \                                 In section .text, align 2, keep-with-next
   1929          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1930          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine8
   1931            uint32_t xfermode;
   1932            HAL_StatusTypeDef dmaxferstatus;
   1933          
   1934            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD14F             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1935            {
   1936              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x698F             LDR      R7,[R1, #+24]
   \       0x12   0x0438             LSLS     R0,R7,#+16
   \       0x14   0xD44B             BMI.N    ??HAL_I2C_Master_Receive_DMA_0
   1937              {
   1938                return HAL_BUSY;
   1939              }
   1940          
   1941              /* Process Locked */
   1942              __HAL_LOCK(hi2c);
   \       0x16   0x7829             LDRB     R1,[R5, #+0]
   \       0x18   0x2901             CMP      R1,#+1
   \       0x1A   0xD048             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \       0x1C   0x2701             MOVS     R7,#+1
   1943          
   1944              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x1E   0x2022             MOVS     R0,#+34
   \       0x20   0x702F             STRB     R7,[R5, #+0]
   1945              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x7068             STRB     R0,[R5, #+1]
   1946              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x26   0xF04F 0x0C00      MOV      R12,#+0
   \       0x2A   0x70A9             STRB     R1,[R5, #+2]
   1947          
   1948              /* Prepare transfer parameters */
   1949              hi2c->pBuffPtr    = pData;
   1950              hi2c->XferCount   = Size;
   1951              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0xffff0000
   \       0x30   0xF8C5 0xC004      STR      R12,[R5, #+4]
   1952              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable23_3
   \       0x38   0x6262             STR      R2,[R4, #+36]
   1953          
   1954              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x3A   0x.... 0x....      LDR.W    R7,??DataTable19  ;; 0x80002400
   \       0x3E   0x8563             STRH     R3,[R4, #+42]
   \       0x40   0x62E0             STR      R0,[R4, #+44]
   \       0x42   0x6361             STR      R1,[R4, #+52]
   \       0x44   0x8D60             LDRH     R0,[R4, #+42]
   \       0x46   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x4A   0xD304             BCC.N    ??HAL_I2C_Master_Receive_DMA_1
   1955              {
   1956                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x4C   0x21FF             MOVS     R1,#+255
   1957                xfermode = I2C_RELOAD_MODE;
   \       0x4E   0xF04F 0x7880      MOV      R8,#+16777216
   \       0x52   0x8521             STRH     R1,[R4, #+40]
   \       0x54   0xE002             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1958              }
   1959              else
   1960              {
   1961                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \       0x56   0x.... 0x....      BL       ?Subroutine86
   1962                xfermode = I2C_AUTOEND_MODE;
   1963              }
   1964          
   1965              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_198: (+1)
   \       0x5A   0xD022             BEQ.N    ??HAL_I2C_Master_Receive_DMA_3
   1966              {
   1967                if (hi2c->hdmarx != NULL)
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \       0x5C   0x6BE0             LDR      R0,[R4, #+60]
   \       0x5E   0xB1C8             CBZ.N    R0,??HAL_I2C_Master_Receive_DMA_4
   1968                {
   1969                  /* Set the I2C DMA transfer complete callback */
   1970                  hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x60   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x64   0x63C1             STR      R1,[R0, #+60]
   1971          
   1972                  /* Set the DMA error callback */
   1973                  hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x66   0x6BE3             LDR      R3,[R4, #+60]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0x6C   0x64D8             STR      R0,[R3, #+76]
   1974          
   1975                  /* Set the unused DMA callbacks to NULL */
   1976                  hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x6E   0x6BE0             LDR      R0,[R4, #+60]
   \       0x70   0xF8C0 0xC040      STR      R12,[R0, #+64]
   1977                  hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x74   0x6BE0             LDR      R0,[R4, #+60]
   \       0x76   0xF8C0 0xC050      STR      R12,[R0, #+80]
   1978          
   1979                  /* Enable the DMA stream */
   1980                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   1981                }
   1982                else
   1983                {
   1984                  /* Update I2C state */
   1985                  hi2c->State     = HAL_I2C_STATE_READY;
   1986                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1987          
   1988                  /* Update I2C error code */
   1989                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   1990          
   1991                  /* Process Unlocked */
   1992                  __HAL_UNLOCK(hi2c);
   1993          
   1994                  return HAL_ERROR;
   1995                }
   1996          
   1997                if (dmaxferstatus == HAL_OK)
   \       0x7A   0x.... 0x....      BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x7E   0xB960             CBNZ.N   R0,??HAL_I2C_Master_Receive_DMA_5
   1998                {
   1999                  /* Send Slave Address */
   2000                  /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2001                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \       0x80   0x.... 0x....      BL       ?Subroutine21
   2002          
   2003                  /* Update XferCount value */
   2004                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_228: (+1)
   \       0x84   0x.... 0x....      BL       ?Subroutine24
   2005          
   2006                  /* Process Unlocked */
   2007                  __HAL_UNLOCK(hi2c);
   2008          
   2009                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2010                            to avoid the risk of I2C interrupt handle execution before current
   2011                            process unlock */
   2012                  /* Enable ERR and NACK interrupts */
   2013                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2014          
   2015                  /* Enable DMA Request */
   2016                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6801             LDR      R1,[R0, #+0]
   \       0x8C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x90   0x6001             STR      R1,[R0, #+0]
   \       0x92   0xE00A             B.N      ??CrossCallReturnLabel_50
   2017                }
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \       0x94   0x.... 0x....      BL       ?Subroutine29
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0x98   0xE001             B.N      ??CrossCallReturnLabel_150
   2018                else
   2019                {
   2020                  /* Update I2C state */
   2021                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \       0x9A   0x.... 0x....      BL       ?Subroutine66
   2022                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   2023          
   2024                  /* Update I2C error code */
   2025                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2026          
   2027                  /* Process Unlocked */
   2028                  __HAL_UNLOCK(hi2c);
   2029          
   2030                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_150: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xE006             B.N      ??HAL_I2C_Master_Receive_DMA_6
   2031                }
   2032              }
   2033              else
   2034              {
   2035                /* Update Transfer ISR function pointer */
   2036                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \       0xA2   0x.... 0x....      BL       ?Subroutine26
   2037          
   2038                /* Send Slave Address */
   2039                /* Set NBYTES to read and generate START condition */
   2040                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   2041          
   2042                /* Process Unlocked */
   2043                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_224: (+1)
   \       0xA6   0x.... 0x....      BL       ?Subroutine25
   2044          
   2045                /* Note : The I2C interrupts must be enabled after unlocking current process
   2046                          to avoid the risk of I2C interrupt handle execution before current
   2047                          process unlock */
   2048                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   2049                /* possible to enable all of these */
   2050                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2051                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   2052              }
   2053          
   2054              return HAL_OK;
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xE000             B.N      ??HAL_I2C_Master_Receive_DMA_6
   2055            }
   2056            else
   2057            {
   2058              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \       0xAE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \       0xB0   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2059            }
   2060          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x8D23             LDRH     R3,[R4, #+40]
   \        0x4   0xF100 0x0124      ADD      R1,R0,#+36
   \        0x8   0x6BE0             LDR      R0,[R4, #+60]
   \        0xA   0x.... 0x....      B.W      HAL_DMA_Start_IT
   2061          
   2062          /**
   2063            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
   2064            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2065            *                the configuration information for the specified I2C.
   2066            * @param  pData Pointer to data buffer
   2067            * @param  Size Amount of data to be sent
   2068            * @retval HAL status
   2069            */

   \                                 In section .text, align 2, keep-with-next
   2070          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2071          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine87
   2072            HAL_StatusTypeDef dmaxferstatus;
   2073          
   2074            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_199: (+1)
   \        0x6   0xD132             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   2075            {
   2076              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Transmit_DMA_1
   \        0xA   0x0010             MOVS     R0,R2
   \        0xC   0xD103             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   2077              {
   2078                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \        0xE   0xF44F 0x7000      MOV      R0,#+512
   \       0x12   0x6060             STR      R0,[R4, #+4]
   2079                return  HAL_ERROR;
   \       0x14   0xE029             B.N      ??CrossCallReturnLabel_69
   2080              }
   2081              /* Process Locked */
   2082              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \       0x16   0x7823             LDRB     R3,[R4, #+0]
   \       0x18   0x2B01             CMP      R3,#+1
   \       0x1A   0xD028             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \       0x1C   0x2001             MOVS     R0,#+1
   2083          
   2084              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x1E   0x2621             MOVS     R6,#+33
   \       0x20   0x.... 0x....      BL       ?Subroutine55
   2085              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   2086              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2087          
   2088              /* Prepare transfer parameters */
   2089              hi2c->pBuffPtr    = pData;
   2090              hi2c->XferCount   = Size;
   2091              hi2c->XferSize    = hi2c->XferCount;
   2092              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2093              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   2094          
   2095              if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_116: (+1)
   \       0x24   0x6BA8             LDR      R0,[R5, #+56]
   \       0x26   0x636B             STR      R3,[R5, #+52]
   \       0x28   0xB1D0             CBZ.N    R0,??HAL_I2C_Slave_Transmit_DMA_3
   2096              {
   2097                /* Set the I2C DMA transfer complete callback */
   2098                hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \       0x2A   0x.... 0x....      LDR.W    R2,??DataTable27
   2099          
   2100                /* Set the DMA error callback */
   2101                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   2102          
   2103                /* Set the unused DMA callbacks to NULL */
   2104                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   2105                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x2E   0x2600             MOVS     R6,#+0
   \       0x30   0x63C2             STR      R2,[R0, #+60]
   \       0x32   0x6BAB             LDR      R3,[R5, #+56]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0x38   0x64D8             STR      R0,[R3, #+76]
   \       0x3A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x3C   0x6407             STR      R7,[R0, #+64]
   \       0x3E   0x6BAF             LDR      R7,[R5, #+56]
   \       0x40   0x653E             STR      R6,[R7, #+80]
   2106          
   2107                /* Enable the DMA stream */
   2108                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   2109              }
   2110              else
   2111              {
   2112                /* Update I2C state */
   2113                hi2c->State     = HAL_I2C_STATE_LISTEN;
   2114                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2115          
   2116                /* Update I2C error code */
   2117                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2118          
   2119                /* Process Unlocked */
   2120                __HAL_UNLOCK(hi2c);
   2121          
   2122                return HAL_ERROR;
   2123              }
   2124          
   2125              if (dmaxferstatus == HAL_OK)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x46   0xF100 0x0228      ADD      R2,R0,#+40
   \       0x4A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x4C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x50   0xB948             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_DMA_4
   2126              {
   2127                /* Enable Address Acknowledge */
   2128                hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \       0x52   0x.... 0x....      BL       ?Subroutine30
   2129          
   2130                /* Process Unlocked */
   2131                __HAL_UNLOCK(hi2c);
   2132          
   2133                /* Note : The I2C interrupts must be enabled after unlocking current process
   2134                          to avoid the risk of I2C interrupt handle execution before current
   2135                          process unlock */
   2136                /* Enable ERR, STOP, NACK, ADDR interrupts */
   2137                I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   2138          
   2139                /* Enable DMA Request */
   2140                hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x56   0x6828             LDR      R0,[R5, #+0]
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0x5E   0x....             B.N      ?Subroutine1
   2141              }
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \       0x60   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_143: (+1)
   \       0x64   0xE001             B.N      ??CrossCallReturnLabel_69
   2142              else
   2143              {
   2144                /* Update I2C state */
   2145                hi2c->State     = HAL_I2C_STATE_LISTEN;
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \       0x66   0x.... 0x....      BL       ?Subroutine36
   2146                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2147          
   2148                /* Update I2C error code */
   2149                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2150          
   2151                /* Process Unlocked */
   2152                __HAL_UNLOCK(hi2c);
   2153          
   2154                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
   2155              }
   2156          
   2157              return HAL_OK;
   2158            }
   2159            else
   2160            {
   2161              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \       0x6E   0x2002             MOVS     R0,#+2
   \       0x70   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2162            }
   2163          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine87: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x0440      ADD      R4,R5,#+64
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine63: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x70A7             STRB     R7,[R4, #+2]
   \        0x6   0x6862             LDR      R2,[R4, #+4]
   \        0x8   0xF042 0x0280      ORR      R2,R2,#0x80
   \        0xC   0x6062             STR      R2,[R4, #+4]
   \        0xE   0x7027             STRB     R7,[R4, #+0]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine55: (+1)
   \        0x0   0x7020             STRB     R0,[R4, #+0]
   \        0x2   0x2320             MOVS     R3,#+32
   \        0x4   0x7066             STRB     R6,[R4, #+1]
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x70A3             STRB     R3,[R4, #+2]
   \        0xA   0x.... 0x....      LDR.W    R3,??DataTable28_1
   \        0xE   0x6067             STR      R7,[R4, #+4]
   \       0x10   0x6269             STR      R1,[R5, #+36]
   \       0x12   0x856A             STRH     R2,[R5, #+42]
   \       0x14   0x8D68             LDRH     R0,[R5, #+42]
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable22  ;; 0xffff0000
   \       0x1A   0x8528             STRH     R0,[R5, #+40]
   \       0x1C   0x62EA             STR      R2,[R5, #+44]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \        0x0   0x2128             MOVS     R1,#+40
   \        0x2   0x7061             STRB     R1,[R4, #+1]
   \        0x4   0x70A6             STRB     R6,[R4, #+2]
   \        0x6   0x6860             LDR      R0,[R4, #+4]
   \        0x8   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xC   0x6060             STR      R0,[R4, #+4]
   \        0xE   0x7026             STRB     R6,[R4, #+0]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF421 0x4100      BIC      R1,R1,#0x8000
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x2104             MOVS     R1,#+4
   \        0xC   0x7026             STRB     R6,[R4, #+0]
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}
   2164          
   2165          /**
   2166            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
   2167            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2168            *                the configuration information for the specified I2C.
   2169            * @param  pData Pointer to data buffer
   2170            * @param  Size Amount of data to be sent
   2171            * @retval HAL status
   2172            */

   \                                 In section .text, align 2, keep-with-next
   2173          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2174          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine87
   2175            HAL_StatusTypeDef dmaxferstatus;
   2176          
   2177            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_200: (+1)
   \        0x6   0xD133             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   2178            {
   2179              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Receive_DMA_1
   \        0xA   0x0010             MOVS     R0,R2
   \        0xC   0xD103             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   2180              {
   2181                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \        0xE   0xF44F 0x7000      MOV      R0,#+512
   \       0x12   0x6060             STR      R0,[R4, #+4]
   2182                return  HAL_ERROR;
   \       0x14   0xE02A             B.N      ??CrossCallReturnLabel_70
   2183              }
   2184              /* Process Locked */
   2185              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \       0x16   0x7823             LDRB     R3,[R4, #+0]
   \       0x18   0x2B01             CMP      R3,#+1
   \       0x1A   0xD029             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \       0x1C   0x2001             MOVS     R0,#+1
   2186          
   2187              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x1E   0x2622             MOVS     R6,#+34
   \       0x20   0x.... 0x....      BL       ?Subroutine55
   2188              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   2189              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2190          
   2191              /* Prepare transfer parameters */
   2192              hi2c->pBuffPtr    = pData;
   2193              hi2c->XferCount   = Size;
   2194              hi2c->XferSize    = hi2c->XferCount;
   2195              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2196              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   2197          
   2198              if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_117: (+1)
   \       0x24   0x6BE8             LDR      R0,[R5, #+60]
   \       0x26   0x636B             STR      R3,[R5, #+52]
   \       0x28   0xB1D8             CBZ.N    R0,??HAL_I2C_Slave_Receive_DMA_3
   2199              {
   2200                /* Set the I2C DMA transfer complete callback */
   2201                hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \       0x2A   0x.... 0x....      LDR.W    R2,??DataTable28
   2202          
   2203                /* Set the DMA error callback */
   2204                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2205          
   2206                /* Set the unused DMA callbacks to NULL */
   2207                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   2208                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x2E   0x2600             MOVS     R6,#+0
   \       0x30   0x63C2             STR      R2,[R0, #+60]
   \       0x32   0x6BEB             LDR      R3,[R5, #+60]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable24_1
   2209          
   2210                /* Enable the DMA stream */
   2211                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   2212              }
   2213              else
   2214              {
   2215                /* Update I2C state */
   2216                hi2c->State     = HAL_I2C_STATE_LISTEN;
   2217                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2218          
   2219                /* Update I2C error code */
   2220                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2221          
   2222                /* Process Unlocked */
   2223                __HAL_UNLOCK(hi2c);
   2224          
   2225                return HAL_ERROR;
   2226              }
   2227          
   2228              if (dmaxferstatus == HAL_OK)
   \       0x38   0x460A             MOV      R2,R1
   \       0x3A   0x64D8             STR      R0,[R3, #+76]
   \       0x3C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x3E   0x6407             STR      R7,[R0, #+64]
   \       0x40   0x6BEF             LDR      R7,[R5, #+60]
   \       0x42   0x653E             STR      R6,[R7, #+80]
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x48   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x4C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x4E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x52   0xB948             CBNZ.N   R0,??HAL_I2C_Slave_Receive_DMA_4
   2229              {
   2230                /* Enable Address Acknowledge */
   2231                hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \       0x54   0x.... 0x....      BL       ?Subroutine30
   2232          
   2233                /* Process Unlocked */
   2234                __HAL_UNLOCK(hi2c);
   2235          
   2236                /* Note : The I2C interrupts must be enabled after unlocking current process
   2237                          to avoid the risk of I2C interrupt handle execution before current
   2238                          process unlock */
   2239                /* Enable ERR, STOP, NACK, ADDR interrupts */
   2240                I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   2241          
   2242                /* Enable DMA Request */
   2243                hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6801             LDR      R1,[R0, #+0]
   \       0x5C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x60   0x....             B.N      ?Subroutine1
   2244              }
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \       0x62   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_144: (+1)
   \       0x66   0xE001             B.N      ??CrossCallReturnLabel_70
   2245              else
   2246              {
   2247                /* Update I2C state */
   2248                hi2c->State     = HAL_I2C_STATE_LISTEN;
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \       0x68   0x.... 0x....      BL       ?Subroutine36
   2249                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2250          
   2251                /* Update I2C error code */
   2252                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2253          
   2254                /* Process Unlocked */
   2255                __HAL_UNLOCK(hi2c);
   2256          
   2257                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}
   2258              }
   2259          
   2260              return HAL_OK;
   2261            }
   2262            else
   2263            {
   2264              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2265            }
   2266          }
   2267          /**
   2268            * @brief  Write an amount of data in blocking mode to a specific memory address
   2269            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2270            *                the configuration information for the specified I2C.
   2271            * @param  DevAddress Target device address: The device 7 bits address value
   2272            *         in datasheet must be shifted to the left before calling the interface
   2273            * @param  MemAddress Internal memory address
   2274            * @param  MemAddSize Size of internal memory address
   2275            * @param  pData Pointer to data buffer
   2276            * @param  Size Amount of data to be sent
   2277            * @param  Timeout Timeout duration
   2278            * @retval HAL status
   2279            */

   \                                 In section .text, align 2, keep-with-next
   2280          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2281          {
   \                     HAL_I2C_Mem_Write: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine51
   2282            uint32_t tickstart;
   2283          
   2284            /* Check the parameters */
   2285            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2286          
   2287            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_106: (+1)
   \        0x8   0xD14E             BNE.N    ??HAL_I2C_Mem_Write_0
   \        0xA   0x9D0C             LDR      R5,[SP, #+48]
   2288            {
   2289              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9F0D             LDRNE    R7,[SP, #+52]
   \       0x12   0x2F00             CMPNE    R7,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_1
   2290              {
   2291                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6061             STR      R1,[R4, #+4]
   2292                return  HAL_ERROR;
   \       0x1C   0xE03F             B.N      ??HAL_I2C_Mem_Write_2
   2293              }
   2294          
   2295              /* Process Locked */
   2296              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \       0x1E   0x7820             LDRB     R0,[R4, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD041             BEQ.N    ??HAL_I2C_Mem_Write_0
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7021             STRB     R1,[R4, #+0]
   2297          
   2298              /* Init tickstart for timeout management*/
   2299              tickstart = HAL_GetTick();
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x.... 0x....      BL       ?Subroutine54
   2300          
   2301              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_113: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD134             BNE.N    ??HAL_I2C_Mem_Write_2
   2302              {
   2303                return HAL_ERROR;
   2304              }
   2305          
   2306              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2021             MOVS     R0,#+33
   2307              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine46
   2308              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2309          
   2310              /* Prepare transfer parameters */
   2311              hi2c->pBuffPtr  = pData;
   2312              hi2c->XferCount = Size;
   2313              hi2c->XferISR   = NULL;
   2314          
   2315              /* Send Slave Address and Memory Address */
   2316              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \       0x3E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Write_3
   2317              {
   2318                /* Process Unlocked */
   2319                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7020             STRB     R0,[R4, #+0]
   2320                return HAL_ERROR;
   \       0x44   0xE02B             B.N      ??HAL_I2C_Mem_Write_2
   2321              }
   2322          
   2323              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   2324              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \       0x46   0x8D71             LDRH     R1,[R6, #+42]
   \       0x48   0x25FF             MOVS     R5,#+255
   \       0x4A   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x4E   0xD319             BCC.N    ??HAL_I2C_Mem_Write_4
   2325              {
   2326                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x50   0x.... 0x....      BL       ?Subroutine75
   2327                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2328              }
   \                     ??CrossCallReturnLabel_167: (+1)
   \       0x54   0x.... 0x....      BL       ?Subroutine57
   \                     ??CrossCallReturnLabel_125: (+1)
   \       0x58   0x9F0E             LDR      R7,[SP, #+56]
   2329              else
   2330              {
   2331                hi2c->XferSize = hi2c->XferCount;
   2332                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2333              }
   2334          
   2335              do
   2336              {
   2337                /* Wait until TXIS flag is set */
   2338                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \       0x5A   0x464A             MOV      R2,R9
   \       0x5C   0x4639             MOV      R1,R7
   \       0x5E   0x4630             MOV      R0,R6
   \       0x60   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD11A             BNE.N    ??HAL_I2C_Mem_Write_2
   2339                {
   2340                  return HAL_ERROR;
   2341                }
   2342          
   2343                /* Write data to TXDR */
   2344                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0x68   0x.... 0x....      BL       ?Subroutine72
   2345          
   2346                /* Increment Buffer pointer */
   2347                hi2c->pBuffPtr++;
   2348          
   2349                hi2c->XferCount--;
   2350                hi2c->XferSize--;
   2351          
   2352                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \                     ??CrossCallReturnLabel_162: (+1)
   \       0x6C   0xB188             CBZ.N    R0,??CrossCallReturnLabel_124
   \       0x6E   0xB289             UXTH     R1,R1
   \       0x70   0xB979             CBNZ.N   R1,??CrossCallReturnLabel_124
   2353                {
   2354                  /* Wait until TCR flag is set */
   2355                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x72   0x.... 0x....      BL       ?Subroutine56
   \                     ??CrossCallReturnLabel_119: (+1)
   \       0x76   0xB990             CBNZ.N   R0,??HAL_I2C_Mem_Write_2
   2356                  {
   2357                    return HAL_ERROR;
   2358                  }
   2359          
   2360                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x78   0x.... 0x....      BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_173: (+1)
   \       0x7C   0xD305             BCC.N    ??HAL_I2C_Mem_Write_6
   2361                  {
   2362                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x7E   0x.... 0x....      BL       ?Subroutine19
   2363                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2364                  }
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x82   0xE004             B.N      ??CrossCallReturnLabel_24
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \       0x84   0x.... 0x....      BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_163: (+1)
   \       0x88   0xE7E4             B.N      ??CrossCallReturnLabel_167
   2365                  else
   2366                  {
   2367                    hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \       0x8A   0x.... 0x....      BL       ?Subroutine18
   2368                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2369                  }
   2370                }
   2371          
   2372              }
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x8E   0x.... 0x....      BL       ?Subroutine57
   2373              while (hi2c->XferCount > 0U);
   \                     ??CrossCallReturnLabel_124: (+1)
   \       0x92   0x8D70             LDRH     R0,[R6, #+42]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD1E0             BNE.N    ??HAL_I2C_Mem_Write_5
   2374          
   2375              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2376              /* Wait until STOPF flag is reset */
   2377              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0x98   0x.... 0x....      BL       ?Subroutine79
   \                     ??CrossCallReturnLabel_178: (+1)
   \       0x9C   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Write_7
   2378              {
   2379                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xE003             B.N      ??HAL_I2C_Mem_Write_8
   2380              }
   2381          
   2382              /* Clear STOP Flag */
   2383              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \       0xA2   0x.... 0x....      BL       ?Subroutine43
   2384          
   2385              /* Clear Configuration Register 2 */
   2386              I2C_RESET_CR2(hi2c);
   2387          
   2388              hi2c->State = HAL_I2C_STATE_READY;
   2389              hi2c->Mode  = HAL_I2C_MODE_NONE;
   2390          
   2391              /* Process Unlocked */
   2392              __HAL_UNLOCK(hi2c);
   2393          
   2394              return HAL_OK;
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0xA6   0xE000             B.N      ??HAL_I2C_Mem_Write_8
   2395            }
   2396            else
   2397            {
   2398              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \       0xA8   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \       0xAA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2399            }
   2400          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine79: (+1)
   \        0x0   0x464A             MOV      R2,R9
   \        0x2   0x4639             MOV      R1,R7
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x.... 0x....      B.W      I2C_WaitOnSTOPFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine75: (+1)
   \        0x0   0x8535             STRH     R5,[R6, #+40]
   \        0x2   0xF04F 0x7380      MOV      R3,#+16777216
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x22FF             MOVS     R2,#+255
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine51: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0440      ADD      R4,R6,#+64
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4692             MOV      R10,R2
   \        0xC   0x469B             MOV      R11,R3
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \        0x0   0x2140             MOVS     R1,#+64
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x70A1             STRB     R1,[R4, #+2]
   \        0x8   0x465B             MOV      R3,R11
   \        0xA   0x6060             STR      R0,[R4, #+4]
   \        0xC   0x4652             MOV      R2,R10
   \        0xE   0x6275             STR      R5,[R6, #+36]
   \       0x10   0x8577             STRH     R7,[R6, #+42]
   \       0x12   0x6370             STR      R0,[R6, #+52]
   \       0x14   0x990E             LDR      R1,[SP, #+56]
   \       0x16   0x9100             STR      R1,[SP, #+0]
   \       0x18   0x4641             MOV      R1,R8
   \       0x1A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \        0x0   0x6831             LDR      R1,[R6, #+0]
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x61C8             STR      R0,[R1, #+28]
   \        0x8   0x6831             LDR      R1,[R6, #+0]
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0xfe00e800
   \        0xE   0x684A             LDR      R2,[R1, #+4]
   \       0x10   0x4002             ANDS     R2,R0,R2
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x604A             STR      R2,[R1, #+4]
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x7061             STRB     R1,[R4, #+1]
   \       0x1A   0x70A3             STRB     R3,[R4, #+2]
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x8535             STRH     R5,[R6, #+40]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xF04F 0x7380      MOV      R3,#+16777216
   \        0xA   0x22FF             MOVS     R2,#+255
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x8D72             LDRH     R2,[R6, #+42]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0xF04F 0x7300      MOV      R3,#+33554432
   \        0x8   0x8532             STRH     R2,[R6, #+40]
   \        0xA   0xB2D2             UXTB     R2,R2
   \        0xC   0x9100             STR      R1,[SP, #+0]
   \        0xE   0x4770             BX       LR
   2401          
   2402          /**
   2403            * @brief  Read an amount of data in blocking mode from a specific memory address
   2404            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2405            *                the configuration information for the specified I2C.
   2406            * @param  DevAddress Target device address: The device 7 bits address value
   2407            *         in datasheet must be shifted to the left before calling the interface
   2408            * @param  MemAddress Internal memory address
   2409            * @param  MemAddSize Size of internal memory address
   2410            * @param  pData Pointer to data buffer
   2411            * @param  Size Amount of data to be sent
   2412            * @param  Timeout Timeout duration
   2413            * @retval HAL status
   2414            */

   \                                 In section .text, align 2, keep-with-next
   2415          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2416          {
   \                     HAL_I2C_Mem_Read: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine51
   2417            uint32_t tickstart;
   2418          
   2419            /* Check the parameters */
   2420            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2421          
   2422            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_107: (+1)
   \        0x8   0xD152             BNE.N    ??HAL_I2C_Mem_Read_0
   \        0xA   0x9D0C             LDR      R5,[SP, #+48]
   2423            {
   2424              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9F0D             LDRNE    R7,[SP, #+52]
   \       0x12   0x2F00             CMPNE    R7,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_1
   2425              {
   2426                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6061             STR      R1,[R4, #+4]
   2427                return  HAL_ERROR;
   \       0x1C   0xE043             B.N      ??HAL_I2C_Mem_Read_2
   2428              }
   2429          
   2430              /* Process Locked */
   2431              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \       0x1E   0x7820             LDRB     R0,[R4, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD045             BEQ.N    ??HAL_I2C_Mem_Read_0
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7021             STRB     R1,[R4, #+0]
   2432          
   2433              /* Init tickstart for timeout management*/
   2434              tickstart = HAL_GetTick();
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x.... 0x....      BL       ?Subroutine54
   2435          
   2436              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_112: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD138             BNE.N    ??HAL_I2C_Mem_Read_2
   2437              {
   2438                return HAL_ERROR;
   2439              }
   2440          
   2441              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x34   0x2022             MOVS     R0,#+34
   2442              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine46
   2443              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2444          
   2445              /* Prepare transfer parameters */
   2446              hi2c->pBuffPtr  = pData;
   2447              hi2c->XferCount = Size;
   2448              hi2c->XferISR   = NULL;
   2449          
   2450              /* Send Slave Address and Memory Address */
   2451              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_97: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryRead
   \       0x3E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Read_3
   2452              {
   2453                /* Process Unlocked */
   2454                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7020             STRB     R0,[R4, #+0]
   2455                return HAL_ERROR;
   \       0x44   0xE02F             B.N      ??HAL_I2C_Mem_Read_2
   2456              }
   2457          
   2458              /* Send Slave Address */
   2459              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2460              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \       0x46   0x8D71             LDRH     R1,[R6, #+42]
   \       0x48   0x25FF             MOVS     R5,#+255
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x80002400
   \       0x4E   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x52   0xD31B             BCC.N    ??HAL_I2C_Mem_Read_4
   2461              {
   2462                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x54   0x.... 0x....      BL       ?Subroutine75
   2463                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   2464              }
   \                     ??CrossCallReturnLabel_168: (+1)
   \       0x58   0x.... 0x....      BL       ?Subroutine57
   \                     ??CrossCallReturnLabel_123: (+1)
   \       0x5C   0x9F0E             LDR      R7,[SP, #+56]
   2465              else
   2466              {
   2467                hi2c->XferSize = hi2c->XferCount;
   2468                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   2469              }
   2470          
   2471              do
   2472              {
   2473                /* Wait until RXNE flag is set */
   2474                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \       0x5E   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x62   0x463B             MOV      R3,R7
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0x2104             MOVS     R1,#+4
   \       0x68   0x.... 0x....      BL       ??Subroutine58_0
   \                     ??CrossCallReturnLabel_128: (+1)
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD11A             BNE.N    ??HAL_I2C_Mem_Read_2
   2475                {
   2476                  return HAL_ERROR;
   2477                }
   2478          
   2479                /* Read data from RXDR */
   2480                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x70   0x.... 0x....      BL       ?Subroutine78
   2481          
   2482                /* Increment Buffer pointer */
   2483                hi2c->pBuffPtr++;
   2484          
   2485                hi2c->XferSize--;
   2486                hi2c->XferCount--;
   2487          
   2488                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \                     ??CrossCallReturnLabel_176: (+1)
   \       0x74   0xB188             CBZ.N    R0,??CrossCallReturnLabel_122
   \       0x76   0xB289             UXTH     R1,R1
   \       0x78   0xB979             CBNZ.N   R1,??CrossCallReturnLabel_122
   2489                {
   2490                  /* Wait until TCR flag is set */
   2491                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x7A   0x.... 0x....      BL       ?Subroutine56
   \                     ??CrossCallReturnLabel_118: (+1)
   \       0x7E   0xB990             CBNZ.N   R0,??HAL_I2C_Mem_Read_2
   2492                  {
   2493                    return HAL_ERROR;
   2494                  }
   2495          
   2496                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x80   0x.... 0x....      BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_174: (+1)
   \       0x84   0xD305             BCC.N    ??HAL_I2C_Mem_Read_6
   2497                  {
   2498                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x86   0x.... 0x....      BL       ?Subroutine19
   2499                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2500                  }
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x8A   0xE004             B.N      ??CrossCallReturnLabel_25
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \       0x8C   0x.... 0x....      BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_164: (+1)
   \       0x90   0xE7E2             B.N      ??CrossCallReturnLabel_168
   2501                  else
   2502                  {
   2503                    hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \       0x92   0x.... 0x....      BL       ?Subroutine18
   2504                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2505                  }
   2506                }
   2507              }
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x96   0x.... 0x....      BL       ?Subroutine57
   2508              while (hi2c->XferCount > 0U);
   \                     ??CrossCallReturnLabel_122: (+1)
   \       0x9A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD1DE             BNE.N    ??HAL_I2C_Mem_Read_5
   2509          
   2510              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2511              /* Wait until STOPF flag is reset */
   2512              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xA0   0x.... 0x....      BL       ?Subroutine79
   \                     ??CrossCallReturnLabel_177: (+1)
   \       0xA4   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Read_7
   2513              {
   2514                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE003             B.N      ??HAL_I2C_Mem_Read_8
   2515              }
   2516          
   2517              /* Clear STOP Flag */
   2518              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \       0xAA   0x.... 0x....      BL       ?Subroutine43
   2519          
   2520              /* Clear Configuration Register 2 */
   2521              I2C_RESET_CR2(hi2c);
   2522          
   2523              hi2c->State = HAL_I2C_STATE_READY;
   2524              hi2c->Mode  = HAL_I2C_MODE_NONE;
   2525          
   2526              /* Process Unlocked */
   2527              __HAL_UNLOCK(hi2c);
   2528          
   2529              return HAL_OK;
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0xAE   0xE000             B.N      ??HAL_I2C_Mem_Read_8
   2530            }
   2531            else
   2532            {
   2533              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \       0xB0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \       0xB2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2534            }
   2535          }
   2536          /**
   2537            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2538            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2539            *                the configuration information for the specified I2C.
   2540            * @param  DevAddress Target device address: The device 7 bits address value
   2541            *         in datasheet must be shifted to the left before calling the interface
   2542            * @param  MemAddress Internal memory address
   2543            * @param  MemAddSize Size of internal memory address
   2544            * @param  pData Pointer to data buffer
   2545            * @param  Size Amount of data to be sent
   2546            * @retval HAL status
   2547            */

   \                                 In section .text, align 2, keep-with-next
   2548          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2549          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine9
   2550            uint32_t tickstart;
   2551            uint32_t xfermode;
   2552          
   2553            /* Check the parameters */
   2554            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2555          
   2556            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x8   0xD12D             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2557            {
   2558              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9E0B             LDRNE    R6,[SP, #+44]
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_IT_1
   2559              {
   2560                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6069             STR      R1,[R5, #+4]
   2561                return  HAL_ERROR;
   \       0x1C   0xE012             B.N      ??HAL_I2C_Mem_Write_IT_2
   2562              }
   2563          
   2564              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x040A             LSLS     R2,R1,#+16
   \       0x24   0xD41F             BMI.N    ??HAL_I2C_Mem_Write_IT_0
   2565              {
   2566                return HAL_BUSY;
   2567              }
   2568          
   2569              /* Process Locked */
   2570              __HAL_LOCK(hi2c);
   \       0x26   0x7828             LDRB     R0,[R5, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD01C             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x7029             STRB     R1,[R5, #+0]
   2571          
   2572              /* Init tickstart for timeout management*/
   2573              tickstart = HAL_GetTick();
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   2574          
   2575              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2221             MOVS     R2,#+33
   2576              hi2c->Mode        = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine10
   2577              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2578          
   2579              /* Prepare transfer parameters */
   2580              hi2c->pBuffPtr    = pData;
   2581              hi2c->XferCount   = Size;
   2582              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2583              hi2c->XferISR     = I2C_Master_ISR_IT;
   2584          
   2585              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2586              {
   2587                hi2c->XferSize = MAX_NBYTE_SIZE;
   2588                xfermode = I2C_RELOAD_MODE;
   2589              }
   2590              else
   2591              {
   2592                hi2c->XferSize = hi2c->XferCount;
   2593                xfermode = I2C_AUTOEND_MODE;
   2594              }
   2595          
   2596              /* Send Slave Address and Memory Address */
   2597              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \       0x3E   0xB118             CBZ.N    R0,??HAL_I2C_Mem_Write_IT_3
   2598              {
   2599                /* Process Unlocked */
   2600                __HAL_UNLOCK(hi2c);
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x7029             STRB     R1,[R5, #+0]
   2601                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE00F             B.N      ??HAL_I2C_Mem_Write_IT_4
   2602              }
   2603          
   2604              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2605              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \       0x48   0x9000             STR      R0,[SP, #+0]
   \       0x4A   0x8D3A             LDRH     R2,[R7, #+40]
   \       0x4C   0x4623             MOV      R3,R4
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x.... 0x....      BL       ??Subroutine97_1
   2606          
   2607              /* Process Unlocked */
   2608              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_233: (+1)
   \       0x56   0x2100             MOVS     R1,#+0
   2609          
   2610              /* Note : The I2C interrupts must be enabled after unlocking current process
   2611                        to avoid the risk of I2C interrupt handle execution before current
   2612                        process unlock */
   2613          
   2614              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   2615              /* possible to enable all of these */
   2616              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2617              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x58   0x4638             MOV      R0,R7
   \       0x5A   0x7029             STRB     R1,[R5, #+0]
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0x.... 0x....      BL       I2C_Enable_IRQ
   2618          
   2619              return HAL_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_4
   2620            }
   2621            else
   2622            {
   2623              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \       0x66   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \       0x68   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2624            }
   2625          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x2340             MOVS     R3,#+64
   \        0x2   0x706A             STRB     R2,[R5, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70AB             STRB     R3,[R5, #+2]
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable22  ;; 0xffff0000
   \        0xC   0x6069             STR      R1,[R5, #+4]
   \        0xE   0x.... 0x....      ADR.W    R1,I2C_Master_ISR_IT
   \       0x12   0x627C             STR      R4,[R7, #+36]
   \       0x14   0x857E             STRH     R6,[R7, #+42]
   \       0x16   0x62FA             STR      R2,[R7, #+44]
   \       0x18   0x6379             STR      R1,[R7, #+52]
   \       0x1A   0x8D7B             LDRH     R3,[R7, #+42]
   \       0x1C   0xF5B3 0x7F80      CMP      R3,#+256
   \       0x20   0xD304             BCC.N    ??Subroutine10_0
   \       0x22   0x21FF             MOVS     R1,#+255
   \       0x24   0xF04F 0x7480      MOV      R4,#+16777216
   \       0x28   0x8539             STRH     R1,[R7, #+40]
   \       0x2A   0xE003             B.N      ??Subroutine10_1
   \                     ??Subroutine10_0: (+1)
   \       0x2C   0x8D7A             LDRH     R2,[R7, #+42]
   \       0x2E   0xF04F 0x7400      MOV      R4,#+33554432
   \       0x32   0x853A             STRH     R2,[R7, #+40]
   \                     ??Subroutine10_1: (+1)
   \       0x34   0x9001             STR      R0,[SP, #+4]
   \       0x36   0x2019             MOVS     R0,#+25
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x4653             MOV      R3,R10
   \       0x3C   0x464A             MOV      R2,R9
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4607             MOV      R7,R0
   \        0x2   0xF107 0x0540      ADD      R5,R7,#+64
   \        0x6   0x7868             LDRB     R0,[R5, #+1]
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine97_0: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \                     ??Subroutine97_1: (+1)
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x.... 0x....      B.W      I2C_TransferConfig
   2626          
   2627          /**
   2628            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2629            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2630            *                the configuration information for the specified I2C.
   2631            * @param  DevAddress Target device address: The device 7 bits address value
   2632            *         in datasheet must be shifted to the left before calling the interface
   2633            * @param  MemAddress Internal memory address
   2634            * @param  MemAddSize Size of internal memory address
   2635            * @param  pData Pointer to data buffer
   2636            * @param  Size Amount of data to be sent
   2637            * @retval HAL status
   2638            */

   \                                 In section .text, align 2, keep-with-next
   2639          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2640          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine9
   2641            uint32_t tickstart;
   2642            uint32_t xfermode;
   2643          
   2644            /* Check the parameters */
   2645            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2646          
   2647            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x8   0xD12F             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2648            {
   2649              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9E0B             LDRNE    R6,[SP, #+44]
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_IT_1
   2650              {
   2651                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6069             STR      R1,[R5, #+4]
   2652                return  HAL_ERROR;
   \       0x1C   0xE012             B.N      ??HAL_I2C_Mem_Read_IT_2
   2653              }
   2654          
   2655              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x040A             LSLS     R2,R1,#+16
   \       0x24   0xD421             BMI.N    ??HAL_I2C_Mem_Read_IT_0
   2656              {
   2657                return HAL_BUSY;
   2658              }
   2659          
   2660              /* Process Locked */
   2661              __HAL_LOCK(hi2c);
   \       0x26   0x7828             LDRB     R0,[R5, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD01E             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x7029             STRB     R1,[R5, #+0]
   2662          
   2663              /* Init tickstart for timeout management*/
   2664              tickstart = HAL_GetTick();
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   2665          
   2666              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x34   0x2222             MOVS     R2,#+34
   2667              hi2c->Mode        = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine10
   2668              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2669          
   2670              /* Prepare transfer parameters */
   2671              hi2c->pBuffPtr    = pData;
   2672              hi2c->XferCount   = Size;
   2673              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2674              hi2c->XferISR     = I2C_Master_ISR_IT;
   2675          
   2676              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2677              {
   2678                hi2c->XferSize = MAX_NBYTE_SIZE;
   2679                xfermode = I2C_RELOAD_MODE;
   2680              }
   2681              else
   2682              {
   2683                hi2c->XferSize = hi2c->XferCount;
   2684                xfermode = I2C_AUTOEND_MODE;
   2685              }
   2686          
   2687              /* Send Slave Address and Memory Address */
   2688              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryRead
   \       0x3E   0xB118             CBZ.N    R0,??HAL_I2C_Mem_Read_IT_3
   2689              {
   2690                /* Process Unlocked */
   2691                __HAL_UNLOCK(hi2c);
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x7029             STRB     R1,[R5, #+0]
   2692                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE011             B.N      ??HAL_I2C_Mem_Read_IT_4
   2693              }
   2694          
   2695              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2696              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x80002400
   \       0x4C   0x4623             MOV      R3,R4
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x8D3A             LDRH     R2,[R7, #+40]
   \       0x52   0x4641             MOV      R1,R8
   \       0x54   0x4638             MOV      R0,R7
   \       0x56   0x.... 0x....      BL       ??Subroutine97_1
   2697          
   2698              /* Process Unlocked */
   2699              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_232: (+1)
   \       0x5A   0x2100             MOVS     R1,#+0
   2700          
   2701              /* Note : The I2C interrupts must be enabled after unlocking current process
   2702                        to avoid the risk of I2C interrupt handle execution before current
   2703                        process unlock */
   2704          
   2705              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   2706              /* possible to enable all of these */
   2707              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2708              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x5C   0x4638             MOV      R0,R7
   \       0x5E   0x7029             STRB     R1,[R5, #+0]
   \       0x60   0x2102             MOVS     R1,#+2
   \       0x62   0x.... 0x....      BL       I2C_Enable_IRQ
   2709          
   2710              return HAL_OK;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_4
   2711            }
   2712            else
   2713            {
   2714              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \       0x6A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \       0x6C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2715            }
   2716          }
   2717          /**
   2718            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2719            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2720            *                the configuration information for the specified I2C.
   2721            * @param  DevAddress Target device address: The device 7 bits address value
   2722            *         in datasheet must be shifted to the left before calling the interface
   2723            * @param  MemAddress Internal memory address
   2724            * @param  MemAddSize Size of internal memory address
   2725            * @param  pData Pointer to data buffer
   2726            * @param  Size Amount of data to be sent
   2727            * @retval HAL status
   2728            */

   \                                 In section .text, align 2, keep-with-next
   2729          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2730          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine52
   2731            uint32_t tickstart;
   2732            uint32_t xfermode;
   2733            HAL_StatusTypeDef dmaxferstatus;
   2734          
   2735            /* Check the parameters */
   2736            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2737          
   2738            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_108: (+1)
   \        0x8   0xD149             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2739            {
   2740              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9D0B             LDRNE    R5,[SP, #+44]
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_DMA_1
   2741              {
   2742                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6079             STR      R1,[R7, #+4]
   2743                return  HAL_ERROR;
   \       0x1C   0xE03D             B.N      ??CrossCallReturnLabel_151
   2744              }
   2745          
   2746              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x040A             LSLS     R2,R1,#+16
   \       0x24   0xD43B             BMI.N    ??HAL_I2C_Mem_Write_DMA_0
   2747              {
   2748                return HAL_BUSY;
   2749              }
   2750          
   2751              /* Process Locked */
   2752              __HAL_LOCK(hi2c);
   \       0x26   0x7838             LDRB     R0,[R7, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD038             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x7039             STRB     R1,[R7, #+0]
   2753          
   2754              /* Init tickstart for timeout management*/
   2755              tickstart = HAL_GetTick();
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   2756          
   2757              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2221             MOVS     R2,#+33
   2758              hi2c->Mode        = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine11
   2759              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2760          
   2761              /* Prepare transfer parameters */
   2762              hi2c->pBuffPtr    = pData;
   2763              hi2c->XferCount   = Size;
   2764              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2765              hi2c->XferISR     = I2C_Master_ISR_DMA;
   2766          
   2767              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2768              {
   2769                hi2c->XferSize = MAX_NBYTE_SIZE;
   2770                xfermode = I2C_RELOAD_MODE;
   2771              }
   2772              else
   2773              {
   2774                hi2c->XferSize = hi2c->XferCount;
   2775                xfermode = I2C_AUTOEND_MODE;
   2776              }
   2777          
   2778              /* Send Slave Address and Memory Address */
   2779              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \       0x3E   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_2
   2780              {
   2781                /* Process Unlocked */
   2782                __HAL_UNLOCK(hi2c);
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0xE026             B.N      ??CrossCallReturnLabel_22
   2783                return HAL_ERROR;
   2784              }
   2785          
   2786          
   2787              if (hi2c->hdmatx != NULL)
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \       0x44   0x6BB0             LDR      R0,[R6, #+56]
   \       0x46   0xB310             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_3
   2788              {
   2789                /* Set the I2C DMA transfer complete callback */
   2790                hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable24
   \       0x4C   0x63C1             STR      R1,[R0, #+60]
   2791          
   2792                /* Set the DMA error callback */
   2793                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x4E   0x6BB2             LDR      R2,[R6, #+56]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable24_1
   2794          
   2795                /* Set the unused DMA callbacks to NULL */
   2796                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x64D0             STR      R0,[R2, #+76]
   \       0x58   0x6BB0             LDR      R0,[R6, #+56]
   2797                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x6401             STR      R1,[R0, #+64]
   \       0x5E   0x6BB1             LDR      R1,[R6, #+56]
   \       0x60   0x650A             STR      R2,[R1, #+80]
   2798          
   2799                /* Enable the DMA stream */
   2800                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   2801              }
   2802              else
   2803              {
   2804                /* Update I2C state */
   2805                hi2c->State     = HAL_I2C_STATE_READY;
   2806                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2807          
   2808                /* Update I2C error code */
   2809                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2810          
   2811                /* Process Unlocked */
   2812                __HAL_UNLOCK(hi2c);
   2813          
   2814                return HAL_ERROR;
   2815              }
   2816          
   2817              if (dmaxferstatus == HAL_OK)
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x8D33             LDRH     R3,[R6, #+40]
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0xF100 0x0228      ADD      R2,R0,#+40
   \       0x6C   0x6BB0             LDR      R0,[R6, #+56]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x72   0xB980             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_4
   2818              {
   2819                /* Send Slave Address */
   2820                /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2821                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x8D32             LDRH     R2,[R6, #+40]
   \       0x78   0x462B             MOV      R3,R5
   \       0x7A   0x4641             MOV      R1,R8
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x.... 0x....      BL       ??Subroutine97_1
   2822          
   2823                /* Update XferCount value */
   2824                hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_231: (+1)
   \       0x82   0x.... 0x....      BL       ?Subroutine59
   2825          
   2826                /* Process Unlocked */
   2827                __HAL_UNLOCK(hi2c);
   2828          
   2829                /* Note : The I2C interrupts must be enabled after unlocking current process
   2830                          to avoid the risk of I2C interrupt handle execution before current
   2831                          process unlock */
   2832                /* Enable ERR and NACK interrupts */
   2833                I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2834          
   2835                /* Enable DMA Request */
   2836                hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_135: (+1)
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0x.... 0x....      BL       ?Subroutine33
   2837              }
   2838              else
   2839              {
   2840                /* Update I2C state */
   2841                hi2c->State     = HAL_I2C_STATE_READY;
   2842                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2843          
   2844                /* Update I2C error code */
   2845                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2846          
   2847                /* Process Unlocked */
   2848                __HAL_UNLOCK(hi2c);
   2849          
   2850                return HAL_ERROR;
   2851              }
   2852          
   2853              return HAL_OK;
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x8C   0xE008             B.N      ??HAL_I2C_Mem_Write_DMA_5
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \       0x8E   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x92   0x7039             STRB     R1,[R7, #+0]
   \       0x94   0xE001             B.N      ??CrossCallReturnLabel_151
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \       0x96   0x.... 0x....      BL       ?Subroutine67
   \                     ??CrossCallReturnLabel_151: (+1)
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_5
   2854            }
   2855            else
   2856            {
   2857              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \       0x9E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \       0xA0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2858            }
   2859          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine67: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7079             STRB     R1,[R7, #+1]
   \        0x6   0x70BA             STRB     R2,[R7, #+2]
   \        0x8   0x6878             LDR      R0,[R7, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6078             STR      R0,[R7, #+4]
   \       0x10   0x703A             STRB     R2,[R7, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine59: (+1)
   \        0x0   0x8D71             LDRH     R1,[R6, #+42]
   \        0x2   0x8D30             LDRH     R0,[R6, #+40]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x1A09             SUBS     R1,R1,R0
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x8571             STRH     R1,[R6, #+42]
   \        0xC   0x2111             MOVS     R1,#+17
   \        0xE   0x703A             STRB     R2,[R7, #+0]
   \       0x10   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine52: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0740      ADD      R7,R6,#+64
   \        0x6   0x7878             LDRB     R0,[R7, #+1]
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x7078             STRB     R0,[R7, #+1]
   \        0x6   0x70B9             STRB     R1,[R7, #+2]
   \        0x8   0x687A             LDR      R2,[R7, #+4]
   \        0xA   0xF042 0x0280      ORR      R2,R2,#0x80
   \        0xE   0x607A             STR      R2,[R7, #+4]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x2340             MOVS     R3,#+64
   \        0x2   0x707A             STRB     R2,[R7, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70BB             STRB     R3,[R7, #+2]
   \        0x8   0x....             LDR.N    R2,??DataTable22  ;; 0xffff0000
   \        0xA   0x6079             STR      R1,[R7, #+4]
   \        0xC   0x.... 0x....      ADR.W    R1,I2C_Master_ISR_DMA
   \       0x10   0x6274             STR      R4,[R6, #+36]
   \       0x12   0x8575             STRH     R5,[R6, #+42]
   \       0x14   0x62F2             STR      R2,[R6, #+44]
   \       0x16   0x6371             STR      R1,[R6, #+52]
   \       0x18   0x8D73             LDRH     R3,[R6, #+42]
   \       0x1A   0xF5B3 0x7F80      CMP      R3,#+256
   \       0x1E   0xD304             BCC.N    ??Subroutine11_0
   \       0x20   0x21FF             MOVS     R1,#+255
   \       0x22   0xF04F 0x7580      MOV      R5,#+16777216
   \       0x26   0x8531             STRH     R1,[R6, #+40]
   \       0x28   0xE003             B.N      ??Subroutine11_1
   \                     ??Subroutine11_0: (+1)
   \       0x2A   0x8D72             LDRH     R2,[R6, #+42]
   \       0x2C   0xF04F 0x7500      MOV      R5,#+33554432
   \       0x30   0x8532             STRH     R2,[R6, #+40]
   \                     ??Subroutine11_1: (+1)
   \       0x32   0x9001             STR      R0,[SP, #+4]
   \       0x34   0x2019             MOVS     R0,#+25
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x4653             MOV      R3,R10
   \       0x3A   0x464A             MOV      R2,R9
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   2860          
   2861          /**
   2862            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   2863            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2864            *                the configuration information for the specified I2C.
   2865            * @param  DevAddress Target device address: The device 7 bits address value
   2866            *         in datasheet must be shifted to the left before calling the interface
   2867            * @param  MemAddress Internal memory address
   2868            * @param  MemAddSize Size of internal memory address
   2869            * @param  pData Pointer to data buffer
   2870            * @param  Size Amount of data to be read
   2871            * @retval HAL status
   2872            */

   \                                 In section .text, align 2, keep-with-next
   2873          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2874          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine52
   2875            uint32_t tickstart;
   2876            uint32_t xfermode;
   2877            HAL_StatusTypeDef dmaxferstatus;
   2878          
   2879            /* Check the parameters */
   2880            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2881          
   2882            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_109: (+1)
   \        0x8   0xD14B             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2883            {
   2884              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x9D0B             LDRNE    R5,[SP, #+44]
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_DMA_1
   2885              {
   2886                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6079             STR      R1,[R7, #+4]
   2887                return  HAL_ERROR;
   \       0x1C   0xE03F             B.N      ??CrossCallReturnLabel_152
   2888              }
   2889          
   2890              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x040A             LSLS     R2,R1,#+16
   \       0x24   0xD43D             BMI.N    ??HAL_I2C_Mem_Read_DMA_0
   2891              {
   2892                return HAL_BUSY;
   2893              }
   2894          
   2895              /* Process Locked */
   2896              __HAL_LOCK(hi2c);
   \       0x26   0x7838             LDRB     R0,[R7, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD03A             BEQ.N    ??HAL_I2C_Mem_Read_DMA_0
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x7039             STRB     R1,[R7, #+0]
   2897          
   2898              /* Init tickstart for timeout management*/
   2899              tickstart = HAL_GetTick();
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   2900          
   2901              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x34   0x2222             MOVS     R2,#+34
   2902              hi2c->Mode        = HAL_I2C_MODE_MEM;
   \       0x36   0x.... 0x....      BL       ?Subroutine11
   2903              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2904          
   2905              /* Prepare transfer parameters */
   2906              hi2c->pBuffPtr    = pData;
   2907              hi2c->XferCount   = Size;
   2908              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2909              hi2c->XferISR     = I2C_Master_ISR_DMA;
   2910          
   2911              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2912              {
   2913                hi2c->XferSize = MAX_NBYTE_SIZE;
   2914                xfermode = I2C_RELOAD_MODE;
   2915              }
   2916              else
   2917              {
   2918                hi2c->XferSize = hi2c->XferCount;
   2919                xfermode = I2C_AUTOEND_MODE;
   2920              }
   2921          
   2922              /* Send Slave Address and Memory Address */
   2923              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x3A   0x.... 0x....      BL       I2C_RequestMemoryRead
   \       0x3E   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_2
   2924              {
   2925                /* Process Unlocked */
   2926                __HAL_UNLOCK(hi2c);
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0xE028             B.N      ??CrossCallReturnLabel_23
   2927                return HAL_ERROR;
   2928              }
   2929          
   2930              if (hi2c->hdmarx != NULL)
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \       0x44   0x6BF0             LDR      R0,[R6, #+60]
   \       0x46   0xB320             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_3
   2931              {
   2932                /* Set the I2C DMA transfer complete callback */
   2933                hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable25
   \       0x4C   0x63C1             STR      R1,[R0, #+60]
   2934          
   2935                /* Set the DMA error callback */
   2936                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x4E   0x6BF2             LDR      R2,[R6, #+60]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable24_1
   2937          
   2938                /* Set the unused DMA callbacks to NULL */
   2939                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x64D0             STR      R0,[R2, #+76]
   \       0x58   0x6BF0             LDR      R0,[R6, #+60]
   2940                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x6401             STR      R1,[R0, #+64]
   \       0x5E   0x6BF1             LDR      R1,[R6, #+60]
   \       0x60   0x650A             STR      R2,[R1, #+80]
   2941          
   2942                /* Enable the DMA stream */
   2943                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   2944              }
   2945              else
   2946              {
   2947                /* Update I2C state */
   2948                hi2c->State     = HAL_I2C_STATE_READY;
   2949                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2950          
   2951                /* Update I2C error code */
   2952                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2953          
   2954                /* Process Unlocked */
   2955                __HAL_UNLOCK(hi2c);
   2956          
   2957                return HAL_ERROR;
   2958              }
   2959          
   2960              if (dmaxferstatus == HAL_OK)
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x8D33             LDRH     R3,[R6, #+40]
   \       0x66   0x4622             MOV      R2,R4
   \       0x68   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x6C   0x6BF0             LDR      R0,[R6, #+60]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x72   0xB990             CBNZ.N   R0,??HAL_I2C_Mem_Read_DMA_4
   2961              {
   2962                /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2963                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x80002400
   \       0x78   0x462B             MOV      R3,R5
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x8D32             LDRH     R2,[R6, #+40]
   \       0x7E   0x4641             MOV      R1,R8
   \       0x80   0x4630             MOV      R0,R6
   \       0x82   0x.... 0x....      BL       ??Subroutine97_1
   2964          
   2965                /* Update XferCount value */
   2966                hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_230: (+1)
   \       0x86   0x.... 0x....      BL       ?Subroutine59
   2967          
   2968                /* Process Unlocked */
   2969                __HAL_UNLOCK(hi2c);
   2970          
   2971                /* Note : The I2C interrupts must be enabled after unlocking current process
   2972                          to avoid the risk of I2C interrupt handle execution before current
   2973                          process unlock */
   2974                /* Enable ERR and NACK interrupts */
   2975                I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2976          
   2977                /* Enable DMA Request */
   2978                hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_134: (+1)
   \       0x8A   0x6830             LDR      R0,[R6, #+0]
   \       0x8C   0x.... 0x....      BL       ?Subroutine35
   2979              }
   2980              else
   2981              {
   2982                /* Update I2C state */
   2983                hi2c->State     = HAL_I2C_STATE_READY;
   2984                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2985          
   2986                /* Update I2C error code */
   2987                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2988          
   2989                /* Process Unlocked */
   2990                __HAL_UNLOCK(hi2c);
   2991          
   2992                return HAL_ERROR;
   2993              }
   2994          
   2995              return HAL_OK;
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x90   0xE008             B.N      ??HAL_I2C_Mem_Read_DMA_5
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \       0x92   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x96   0x7039             STRB     R1,[R7, #+0]
   \       0x98   0xE001             B.N      ??CrossCallReturnLabel_152
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \       0x9A   0x.... 0x....      BL       ?Subroutine67
   \                     ??CrossCallReturnLabel_152: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_5
   2996            }
   2997            else
   2998            {
   2999              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \       0xA2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \       0xA4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3000            }
   3001          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   3002          
   3003          /**
   3004            * @brief  Checks if target device is ready for communication.
   3005            * @note   This function is used with Memory devices
   3006            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3007            *                the configuration information for the specified I2C.
   3008            * @param  DevAddress Target device address: The device 7 bits address value
   3009            *         in datasheet must be shifted to the left before calling the interface
   3010            * @param  Trials Number of trials
   3011            * @param  Timeout Timeout duration
   3012            * @retval HAL status
   3013            */

   \                                 In section .text, align 2, keep-with-next
   3014          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   3015          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   3016            uint32_t tickstart;
   3017          
   3018            __IO uint32_t I2C_Trials = 0UL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
   3019          
   3020            FlagStatus tmp1;
   3021            FlagStatus tmp2;
   3022          
   3023            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xA   0xF105 0x0640      ADD      R6,R5,#+64
   \        0xE   0x7874             LDRB     R4,[R6, #+1]
   \       0x10   0x2C20             CMP      R4,#+32
   \       0x12   0xD142             BNE.N    ??HAL_I2C_IsDeviceReady_0
   3024            {
   3025              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6987             LDR      R7,[R0, #+24]
   \       0x18   0x043C             LSLS     R4,R7,#+16
   \       0x1A   0xD43E             BMI.N    ??HAL_I2C_IsDeviceReady_0
   3026              {
   3027                return HAL_BUSY;
   3028              }
   3029          
   3030              /* Process Locked */
   3031              __HAL_LOCK(hi2c);
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD03B             BEQ.N    ??HAL_I2C_IsDeviceReady_0
   \       0x22   0x2701             MOVS     R7,#+1
   3032          
   3033              hi2c->State = HAL_I2C_STATE_BUSY;
   \       0x24   0x2424             MOVS     R4,#+36
   \       0x26   0x7037             STRB     R7,[R6, #+0]
   3034              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x7074             STRB     R4,[R6, #+1]
   \       0x2C   0xF3C1 0x0709      UBFX     R7,R1,#+0,#+10
   \       0x30   0x6070             STR      R0,[R6, #+4]
   \       0x32   0x4690             MOV      R8,R2
   \       0x34   0x461C             MOV      R4,R3
   3035          
   3036              do
   3037              {
   3038                /* Generate Start */
   3039                hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \       0x36   0x68E9             LDR      R1,[R5, #+12]
   \       0x38   0x2901             CMP      R1,#+1
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0xBF06             ITTE     EQ 
   \       0x3E   0xF047 0x7000      ORREQ    R0,R7,#0x2000000
   \       0x42   0xF440 0x5000      ORREQ    R0,R0,#0x2000
   \       0x46   0xF447 0x5020      ORRNE    R0,R7,#0x2800
   \       0x4A   0x6048             STR      R0,[R1, #+4]
   3040          
   3041                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3042                /* Wait until STOPF flag is set or a NACK flag is set*/
   3043                tickstart = HAL_GetTick();
   \       0x4C   0x.... 0x....      BL       HAL_GetTick
   \       0x50   0x4681             MOV      R9,R0
   3044          
   3045                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x6988             LDR      R0,[R1, #+24]
   3046                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \       0x56   0x6989             LDR      R1,[R1, #+24]
   \       0x58   0x0940             LSRS     R0,R0,#+5
   \       0x5A   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x5E   0x0909             LSRS     R1,R1,#+4
   \       0x60   0xF001 0x0101      AND      R1,R1,#0x1
   3047          
   3048                while ((tmp1 == RESET) && (tmp2 == RESET))
   \       0x64   0x4308             ORRS     R0,R1,R0
   \       0x66   0xD11B             BNE.N    ??HAL_I2C_IsDeviceReady_3
   3049                {
   3050                  if (Timeout != HAL_MAX_DELAY)
   \       0x68   0xF114 0x0F01      CMN      R4,#+1
   \       0x6C   0xD0F1             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   3051                  {
   3052                    if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x6E   0x.... 0x....      BL       HAL_GetTick
   \       0x72   0xEBA0 0x0009      SUB      R0,R0,R9
   \       0x76   0x4284             CMP      R4,R0
   \       0x78   0xD344             BCC.N    ??HAL_I2C_IsDeviceReady_4
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD1E9             BNE.N    ??HAL_I2C_IsDeviceReady_2
   3053                    {
   3054                      /* Update I2C state */
   3055                      hi2c->State = HAL_I2C_STATE_READY;
   3056          
   3057                      /* Update I2C error code */
   3058                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3059          
   3060                      /* Process Unlocked */
   3061                      __HAL_UNLOCK(hi2c);
   3062          
   3063                      return HAL_ERROR;
   3064                    }
   3065                  }
   3066          
   3067                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0x7E   0xE041             B.N      ??HAL_I2C_IsDeviceReady_4
   3068                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   3069                }
   3070          
   3071                /* Check if the NACKF flag has not been set */
   3072                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
   3073                {
   3074                  /* Wait until STOPF flag is reset */
   3075                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \       0x80   0x.... 0x....      BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_138: (+1)
   \       0x84   0xB938             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_6
   3076                  {
   3077                    return HAL_ERROR;
   3078                  }
   3079          
   3080                  /* Clear STOP Flag */
   3081                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0x86   0x6829             LDR      R1,[R5, #+0]
   \       0x88   0x2020             MOVS     R0,#+32
   3082          
   3083                  /* Device is ready */
   3084                  hi2c->State = HAL_I2C_STATE_READY;
   3085          
   3086                  /* Process Unlocked */
   3087                  __HAL_UNLOCK(hi2c);
   \       0x8A   0x2300             MOVS     R3,#+0
   \       0x8C   0x61C8             STR      R0,[R1, #+28]
   \       0x8E   0x7070             STRB     R0,[R6, #+1]
   3088          
   3089                  return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x7033             STRB     R3,[R6, #+0]
   \       0x94   0xE002             B.N      ??HAL_I2C_IsDeviceReady_7
   3090                }
   3091                else
   3092                {
   3093                  /* Wait until STOPF flag is reset */
   3094                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   3095                  {
   3096                    return HAL_ERROR;
   3097                  }
   3098          
   3099                  /* Clear NACK Flag */
   3100                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   3101          
   3102                  /* Clear STOP Flag, auto generated with autoend*/
   3103                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3104                }
   3105          
   3106                /* Check if the maximum allowed number of trials has been reached */
   3107                if (I2C_Trials == Trials)
   3108                {
   3109                  /* Generate Stop */
   3110                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   3111          
   3112                  /* Wait until STOPF flag is reset */
   3113                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   3114                  {
   3115                    return HAL_ERROR;
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE000             B.N      ??HAL_I2C_IsDeviceReady_7
   3116                  }
   3117          
   3118                  /* Clear STOP Flag */
   3119                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3120                }
   3121          
   3122                /* Increment Trials */
   3123                I2C_Trials++;
   3124              }
   3125              while (I2C_Trials < Trials);
   3126          
   3127              /* Update I2C state */
   3128              hi2c->State = HAL_I2C_STATE_READY;
   3129          
   3130              /* Update I2C error code */
   3131              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3132          
   3133              /* Process Unlocked */
   3134              __HAL_UNLOCK(hi2c);
   3135          
   3136              return HAL_ERROR;
   3137            }
   3138            else
   3139            {
   3140              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \       0x9A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \       0x9C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   3141            }
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \       0xA0   0x6828             LDR      R0,[R5, #+0]
   \       0xA2   0x4623             MOV      R3,R4
   \       0xA4   0x6981             LDR      R1,[R0, #+24]
   \       0xA6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0xAA   0x06CA             LSLS     R2,R1,#+27
   \       0xAC   0xD5E8             BPL.N    ??HAL_I2C_IsDeviceReady_5
   \       0xAE   0x.... 0x....      BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_137: (+1)
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD1EF             BNE.N    ??HAL_I2C_IsDeviceReady_6
   \       0xB6   0x6829             LDR      R1,[R5, #+0]
   \       0xB8   0x2010             MOVS     R0,#+16
   \       0xBA   0x2220             MOVS     R2,#+32
   \       0xBC   0x61C8             STR      R0,[R1, #+28]
   \       0xBE   0x682B             LDR      R3,[R5, #+0]
   \       0xC0   0x61DA             STR      R2,[R3, #+28]
   \       0xC2   0x9801             LDR      R0,[SP, #+4]
   \       0xC4   0x4540             CMP      R0,R8
   \       0xC6   0xD10E             BNE.N    ??HAL_I2C_IsDeviceReady_8
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x4623             MOV      R3,R4
   \       0xCC   0x2200             MOVS     R2,#+0
   \       0xCE   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0xD2   0x2120             MOVS     R1,#+32
   \       0xD4   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0xD8   0x.... 0x....      BL       ??Subroutine60_0
   \                     ??CrossCallReturnLabel_136: (+1)
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD1DA             BNE.N    ??HAL_I2C_IsDeviceReady_6
   \       0xE0   0x6829             LDR      R1,[R5, #+0]
   \       0xE2   0x2020             MOVS     R0,#+32
   \       0xE4   0x61C8             STR      R0,[R1, #+28]
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \       0xE6   0x9A01             LDR      R2,[SP, #+4]
   \       0xE8   0x1C52             ADDS     R2,R2,#+1
   \       0xEA   0x9201             STR      R2,[SP, #+4]
   \       0xEC   0x9801             LDR      R0,[SP, #+4]
   \       0xEE   0x4540             CMP      R0,R8
   \       0xF0   0xD3A1             BCC.N    ??HAL_I2C_IsDeviceReady_1
   \       0xF2   0x2120             MOVS     R1,#+32
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x7071             STRB     R1,[R6, #+1]
   \       0xF8   0x6872             LDR      R2,[R6, #+4]
   \       0xFA   0xF042 0x0220      ORR      R2,R2,#0x20
   \       0xFE   0x6072             STR      R2,[R6, #+4]
   \      0x100   0x7030             STRB     R0,[R6, #+0]
   \      0x102   0xE7C8             B.N      ??HAL_I2C_IsDeviceReady_6
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \      0x104   0x2120             MOVS     R1,#+32
   \      0x106   0x7071             STRB     R1,[R6, #+1]
   \      0x108   0x6870             LDR      R0,[R6, #+4]
   \      0x10A   0x2100             MOVS     R1,#+0
   \      0x10C   0xF040 0x0020      ORR      R0,R0,#0x20
   \      0x110   0x6070             STR      R0,[R6, #+4]
   \      0x112   0x7031             STRB     R1,[R6, #+0]
   \      0x114   0xE7BF             B.N      ??HAL_I2C_IsDeviceReady_6
   3142          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine60: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x2120             MOVS     R1,#+32
   \                     ??Subroutine60_0: (+1)
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x.... 0x....      B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \        0x0   0x6841             LDR      R1,[R0, #+4]
   \        0x2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \        0x6   0x6041             STR      R1,[R0, #+4]
   \        0x8   0x4770             BX       LR
   3143          
   3144          /**
   3145            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
   3146            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3147            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3148            *                the configuration information for the specified I2C.
   3149            * @param  DevAddress Target device address: The device 7 bits address value
   3150            *         in datasheet must be shifted to the left before calling the interface
   3151            * @param  pData Pointer to data buffer
   3152            * @param  Size Amount of data to be sent
   3153            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3154            * @retval HAL status
   3155            */

   \                                 In section .text, align 2, keep-with-next
   3156          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3157          {
   \                     HAL_I2C_Master_Seq_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine83
   3158            uint32_t xfermode;
   3159            uint32_t xferrequest = I2C_GENERATE_START_WRITE;
   3160          
   3161            /* Check the parameters */
   3162            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3163          
   3164            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_189: (+1)
   \        0x8   0x....             LDR.N    R6,??DataTable23  ;; 0x80002000
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD124             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   3165            {
   3166              /* Process Locked */
   3167              __HAL_LOCK(hi2c);
   \        0xE   0x7839             LDRB     R1,[R7, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD021             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   \       0x14   0x9808             LDR      R0,[SP, #+32]
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x7039             STRB     R1,[R7, #+0]
   3168          
   3169              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x1A   0x2121             MOVS     R1,#+33
   \       0x1C   0x.... 0x....      BL       ?Subroutine62
   3170              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3171              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3172          
   3173              /* Prepare transfer parameters */
   3174              hi2c->pBuffPtr    = pData;
   3175              hi2c->XferCount   = Size;
   3176              hi2c->XferOptions = XferOptions;
   3177              hi2c->XferISR     = I2C_Master_ISR_IT;
   3178          
   3179              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3180              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3181              {
   3182                hi2c->XferSize = MAX_NBYTE_SIZE;
   3183                xfermode = I2C_RELOAD_MODE;
   3184              }
   3185              else
   3186              {
   3187                hi2c->XferSize = hi2c->XferCount;
   3188                xfermode = hi2c->XferOptions;
   3189              }
   3190          
   3191              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3192              /* Mean Previous state is same as current state */
   3193              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_141: (+1)
   \       0x20   0x2911             CMP      R1,#+17
   \       0x22   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_1
   \       0x24   0x28AA             CMP      R0,#+170
   \       0x26   0xBF1C             ITT      NE 
   \       0x28   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x2C   0x2600             MOVNE    R6,#+0
   3194              {
   3195                xferrequest = I2C_NO_STARTSTOP;
   \       0x2E   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_2
   3196              }
   3197              else
   3198              {
   3199                /* Convert OTHER_xxx XferOptions if any */
   3200                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_1: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x.... 0x....      BL       I2C_ConvertOtherXferOptions
   3201          
   3202                /* Update xfermode accordingly if no reload is necessary */
   3203                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x36   0x8D60             LDRH     R0,[R4, #+42]
   \       0x38   0x28FF             CMP      R0,#+255
   \       0x3A   0xBF38             IT       CC 
   \       0x3C   0x6AE5             LDRCC    R5,[R4, #+44]
   3204                {
   3205                  xfermode = hi2c->XferOptions;
   3206                }
   3207              }
   3208          
   3209              /* Send Slave Address and set NBYTES to write */
   3210              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_2: (+1)
   \       0x3E   0x9600             STR      R6,[SP, #+0]
   \       0x40   0x8D22             LDRH     R2,[R4, #+40]
   \       0x42   0x462B             MOV      R3,R5
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x.... 0x....      BL       ??Subroutine96_0
   3211          
   3212              /* Process Unlocked */
   3213              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_227: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   3214          
   3215              /* Note : The I2C interrupts must be enabled after unlocking current process
   3216                        to avoid the risk of I2C interrupt handle execution before current
   3217                        process unlock */
   3218              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x7038             STRB     R0,[R7, #+0]
   \       0x50   0x.... 0x....      BL       ??Subroutine25_1
   3219          
   3220              return HAL_OK;
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_3
   3221            }
   3222            else
   3223            {
   3224              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_0: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_3: (+1)
   \       0x5A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3225            }
   3226          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine83: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0740      ADD      R7,R4,#+64
   \        0x6   0x7878             LDRB     R0,[R7, #+1]
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine62: (+1)
   \        0x0   0x7079             STRB     R1,[R7, #+1]
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x70B9             STRB     R1,[R7, #+2]
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x607D             STR      R5,[R7, #+4]
   \        0xA   0x.... 0x....      ADR.W    R1,I2C_Master_ISR_IT
   \        0xE   0x6262             STR      R2,[R4, #+36]
   \       0x10   0x8563             STRH     R3,[R4, #+42]
   \       0x12   0x62E0             STR      R0,[R4, #+44]
   \       0x14   0x6361             STR      R1,[R4, #+52]
   \       0x16   0x8D62             LDRH     R2,[R4, #+42]
   \       0x18   0x2AFF             CMP      R2,#+255
   \       0x1A   0xD904             BLS.N    ??Subroutine62_0
   \       0x1C   0x21FF             MOVS     R1,#+255
   \       0x1E   0xF04F 0x7580      MOV      R5,#+16777216
   \       0x22   0x8521             STRH     R1,[R4, #+40]
   \       0x24   0xE002             B.N      ??Subroutine62_1
   \                     ??Subroutine62_0: (+1)
   \       0x26   0x8D62             LDRH     R2,[R4, #+42]
   \       0x28   0x8522             STRH     R2,[R4, #+40]
   \       0x2A   0x6AE5             LDR      R5,[R4, #+44]
   \                     ??Subroutine62_1: (+1)
   \       0x2C   0x6B21             LDR      R1,[R4, #+48]
   \       0x2E   0x4770             BX       LR
   3227          
   3228          /**
   3229            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
   3230            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3231            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3232            *                the configuration information for the specified I2C.
   3233            * @param  DevAddress Target device address: The device 7 bits address value
   3234            *         in datasheet must be shifted to the left before calling the interface
   3235            * @param  pData Pointer to data buffer
   3236            * @param  Size Amount of data to be sent
   3237            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3238            * @retval HAL status
   3239            */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine74: (+1)
   \        0x0   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \        0x4   0x8D2A             LDRH     R2,[R5, #+40]
   \        0x6   0x463B             MOV      R3,R7
   \        0x8   0x4649             MOV      R1,R9
   \        0xA                      REQUIRE ??Subroutine97_0
   \        0xA                      ;; // Fall through to label ??Subroutine97_0

   \                                 In section .text, align 2, keep-with-next
   3240          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3241          {
   \                     HAL_I2C_Master_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   3242            uint32_t xfermode;
   3243            uint32_t xferrequest = I2C_GENERATE_START_WRITE;
   3244            HAL_StatusTypeDef dmaxferstatus;
   3245          
   3246            /* Check the parameters */
   3247            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3248          
   3249            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x6   0xF105 0x0640      ADD      R6,R5,#+64
   \        0xA   0x7870             LDRB     R0,[R6, #+1]
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable23  ;; 0x80002000
   \       0x10   0x4689             MOV      R9,R1
   \       0x12   0x46C2             MOV      R10,R8
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xD14E             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   3250            {
   3251              /* Process Locked */
   3252              __HAL_LOCK(hi2c);
   \       0x18   0x7831             LDRB     R1,[R6, #+0]
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xD04B             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   \       0x1E   0x4614             MOV      R4,R2
   \       0x20   0x980A             LDR      R0,[SP, #+40]
   \       0x22   0x2201             MOVS     R2,#+1
   3253          
   3254              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x24   0x2121             MOVS     R1,#+33
   \       0x26   0x7032             STRB     R2,[R6, #+0]
   3255              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3256              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x28   0xF04F 0x0E00      MOV      LR,#+0
   \       0x2C   0x7071             STRB     R1,[R6, #+1]
   \       0x2E   0x2110             MOVS     R1,#+16
   \       0x30   0x70B1             STRB     R1,[R6, #+2]
   3257          
   3258              /* Prepare transfer parameters */
   3259              hi2c->pBuffPtr    = pData;
   3260              hi2c->XferCount   = Size;
   3261              hi2c->XferOptions = XferOptions;
   3262              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x32   0x.... 0x....      ADR.W    R1,I2C_Master_ISR_DMA
   \       0x36   0xF8C6 0xE004      STR      LR,[R6, #+4]
   \       0x3A   0x626C             STR      R4,[R5, #+36]
   \       0x3C   0x856B             STRH     R3,[R5, #+42]
   \       0x3E   0x62E8             STR      R0,[R5, #+44]
   \       0x40   0x6369             STR      R1,[R5, #+52]
   3263          
   3264              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3265              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x42   0x8D6A             LDRH     R2,[R5, #+42]
   \       0x44   0x2AFF             CMP      R2,#+255
   \       0x46   0xD904             BLS.N    ??HAL_I2C_Master_Seq_Transmit_DMA_1
   3266              {
   3267                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x48   0x21FF             MOVS     R1,#+255
   3268                xfermode = I2C_RELOAD_MODE;
   \       0x4A   0xF04F 0x7780      MOV      R7,#+16777216
   \       0x4E   0x8529             STRH     R1,[R5, #+40]
   \       0x50   0xE002             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_2
   3269              }
   3270              else
   3271              {
   3272                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_1: (+1)
   \       0x52   0x8D6A             LDRH     R2,[R5, #+42]
   \       0x54   0x852A             STRH     R2,[R5, #+40]
   3273                xfermode = hi2c->XferOptions;
   \       0x56   0x6AEF             LDR      R7,[R5, #+44]
   3274              }
   3275          
   3276              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3277              /* Mean Previous state is same as current state */
   3278              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_2: (+1)
   \       0x58   0x6B29             LDR      R1,[R5, #+48]
   \       0x5A   0x2911             CMP      R1,#+17
   \       0x5C   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_3
   \       0x5E   0x28AA             CMP      R0,#+170
   \       0x60   0xBF1C             ITT      NE 
   \       0x62   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x66   0x46F2             MOVNE    R10,LR
   3279              {
   3280                xferrequest = I2C_NO_STARTSTOP;
   \       0x68   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_4
   3281              }
   3282              else
   3283              {
   3284                /* Convert OTHER_xxx XferOptions if any */
   3285                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_3: (+1)
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x.... 0x....      BL       I2C_ConvertOtherXferOptions
   3286          
   3287                /* Update xfermode accordingly if no reload is necessary */
   3288                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x70   0x8D68             LDRH     R0,[R5, #+42]
   \       0x72   0x28FF             CMP      R0,#+255
   \       0x74   0xBF38             IT       CC 
   \       0x76   0x6AEF             LDRCC    R7,[R5, #+44]
   3289                {
   3290                  xfermode = hi2c->XferOptions;
   3291                }
   3292              }
   3293          
   3294              if (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_4: (+1)
   \       0x78   0x8D28             LDRH     R0,[R5, #+40]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD015             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_5
   3295              {
   3296                if (hi2c->hdmatx != NULL)
   \       0x7E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x80   0xB158             CBZ.N    R0,??HAL_I2C_Master_Seq_Transmit_DMA_6
   3297                {
   3298                  /* Set the I2C DMA transfer complete callback */
   3299                  hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x82   0x....             LDR.N    R1,??DataTable24
   \       0x84   0x.... 0x....      BL       ?Subroutine14
   3300          
   3301                  /* Set the DMA error callback */
   3302                  hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3303          
   3304                  /* Set the unused DMA callbacks to NULL */
   3305                  hi2c->hdmatx->XferHalfCpltCallback = NULL;
   3306                  hi2c->hdmatx->XferAbortCallback = NULL;
   3307          
   3308                  /* Enable the DMA stream */
   3309                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   3310                }
   3311                else
   3312                {
   3313                  /* Update I2C state */
   3314                  hi2c->State     = HAL_I2C_STATE_READY;
   3315                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3316          
   3317                  /* Update I2C error code */
   3318                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3319          
   3320                  /* Process Unlocked */
   3321                  __HAL_UNLOCK(hi2c);
   3322          
   3323                  return HAL_ERROR;
   3324                }
   3325          
   3326                if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x88   0xB950             CBNZ.N   R0,??HAL_I2C_Master_Seq_Transmit_DMA_7
   3327                {
   3328                  /* Send Slave Address and set NBYTES to write */
   3329                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \       0x8A   0x.... 0x....      BL       ?Subroutine74
   3330          
   3331                  /* Update XferCount value */
   3332                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_236: (+1)
   \       0x8E   0x.... 0x....      BL       ?Subroutine65
   3333          
   3334                  /* Process Unlocked */
   3335                  __HAL_UNLOCK(hi2c);
   3336          
   3337                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3338                            to avoid the risk of I2C interrupt handle execution before current
   3339                            process unlock */
   3340                  /* Enable ERR and NACK interrupts */
   3341                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   3342          
   3343                  /* Enable DMA Request */
   3344                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_148: (+1)
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x.... 0x....      BL       ?Subroutine34
   3345                }
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x98   0xE00B             B.N      ??CrossCallReturnLabel_99
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_6: (+1)
   \       0x9A   0x.... 0x....      BL       ?Subroutine44
   \                     ??CrossCallReturnLabel_92: (+1)
   \       0x9E   0xE001             B.N      ??CrossCallReturnLabel_157
   3346                else
   3347                {
   3348                  /* Update I2C state */
   3349                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_7: (+1)
   \       0xA0   0x.... 0x....      BL       ?Subroutine70
   3350                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3351          
   3352                  /* Update I2C error code */
   3353                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3354          
   3355                  /* Process Unlocked */
   3356                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_157: (+1)
   \       0xA4   0x7032             STRB     R2,[R6, #+0]
   3357          
   3358                  return HAL_ERROR;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE006             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_8
   3359                }
   3360              }
   3361              else
   3362              {
   3363                /* Update Transfer ISR function pointer */
   3364                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_5: (+1)
   \       0xAA   0x.... 0x....      BL       ?Subroutine69
   3365          
   3366                /* Send Slave Address */
   3367                /* Set NBYTES to write and generate START condition */
   3368                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   3369          
   3370                /* Process Unlocked */
   3371                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_156: (+1)
   \       0xAE   0x.... 0x....      BL       ?Subroutine47
   3372          
   3373                /* Note : The I2C interrupts must be enabled after unlocking current process
   3374                          to avoid the risk of I2C interrupt handle execution before current
   3375                          process unlock */
   3376                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   3377                /* possible to enable all of these */
   3378                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   3379                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   3380              }
   3381          
   3382              return HAL_OK;
   \                     ??CrossCallReturnLabel_99: (+1)
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_8
   3383            }
   3384            else
   3385            {
   3386              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_0: (+1)
   \       0xB6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_8: (+1)
   \       0xB8   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3387            }
   3388          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine70: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7071             STRB     R1,[R6, #+1]
   \        0x6   0x70B2             STRB     R2,[R6, #+2]
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6070             STR      R0,[R6, #+4]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine69: (+1)
   \        0x0   0x.... 0x....      ADR.W    R0,I2C_Master_ISR_IT
   \        0x4   0xF04F 0x7300      MOV      R3,#+33554432
   \        0x8   0x6368             STR      R0,[R5, #+52]
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x10   0x4649             MOV      R1,R9
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine65: (+1)
   \        0x0   0x8D69             LDRH     R1,[R5, #+42]
   \        0x2   0x8D28             LDRH     R0,[R5, #+40]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x1A09             SUBS     R1,R1,R0
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x8569             STRH     R1,[R5, #+42]
   \        0xC   0x2111             MOVS     R1,#+17
   \        0xE   0x7032             STRB     R2,[R6, #+0]
   \       0x10   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x7030             STRB     R0,[R6, #+0]
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7070             STRB     R0,[R6, #+1]
   \        0x6   0x70B2             STRB     R2,[R6, #+2]
   \        0x8   0x6871             LDR      R1,[R6, #+4]
   \        0xA   0xF041 0x0180      ORR      R1,R1,#0x80
   \        0xE   0x6071             STR      R1,[R6, #+4]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x63C1             STR      R1,[R0, #+60]
   \        0x2   0x6BAA             LDR      R2,[R5, #+56]
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable32
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x64D0             STR      R0,[R2, #+76]
   \        0xC   0x6BA8             LDR      R0,[R5, #+56]
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6401             STR      R1,[R0, #+64]
   \       0x12   0x6BA9             LDR      R1,[R5, #+56]
   \       0x14   0x650A             STR      R2,[R1, #+80]
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x1A   0x4621             MOV      R1,R4
   \       0x1C   0xF100 0x0228      ADD      R2,R0,#+40
   \       0x20   0x6BA8             LDR      R0,[R5, #+56]
   \       0x22   0x.... 0x....      B.W      HAL_DMA_Start_IT
   3389          
   3390          /**
   3391            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
   3392            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3393            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3394            *                the configuration information for the specified I2C.
   3395            * @param  DevAddress Target device address: The device 7 bits address value
   3396            *         in datasheet must be shifted to the left before calling the interface
   3397            * @param  pData Pointer to data buffer
   3398            * @param  Size Amount of data to be sent
   3399            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3400            * @retval HAL status
   3401            */

   \                                 In section .text, align 2, keep-with-next
   3402          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3403          {
   \                     HAL_I2C_Master_Seq_Receive_IT: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine83
   3404            uint32_t xfermode;
   3405            uint32_t xferrequest = I2C_GENERATE_START_READ;
   3406          
   3407            /* Check the parameters */
   3408            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3409          
   3410            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_190: (+1)
   \        0x8   0x....             LDR.N    R6,??DataTable25_1  ;; 0x80002400
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD124             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   3411            {
   3412              /* Process Locked */
   3413              __HAL_LOCK(hi2c);
   \        0xE   0x7839             LDRB     R1,[R7, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD021             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   \       0x14   0x9808             LDR      R0,[SP, #+32]
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x7039             STRB     R1,[R7, #+0]
   3414          
   3415              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x1A   0x2122             MOVS     R1,#+34
   \       0x1C   0x.... 0x....      BL       ?Subroutine62
   3416              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3417              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3418          
   3419              /* Prepare transfer parameters */
   3420              hi2c->pBuffPtr    = pData;
   3421              hi2c->XferCount   = Size;
   3422              hi2c->XferOptions = XferOptions;
   3423              hi2c->XferISR     = I2C_Master_ISR_IT;
   3424          
   3425              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3426              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3427              {
   3428                hi2c->XferSize = MAX_NBYTE_SIZE;
   3429                xfermode = I2C_RELOAD_MODE;
   3430              }
   3431              else
   3432              {
   3433                hi2c->XferSize = hi2c->XferCount;
   3434                xfermode = hi2c->XferOptions;
   3435              }
   3436          
   3437              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3438              /* Mean Previous state is same as current state */
   3439              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_142: (+1)
   \       0x20   0x2912             CMP      R1,#+18
   \       0x22   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_1
   \       0x24   0x28AA             CMP      R0,#+170
   \       0x26   0xBF1C             ITT      NE 
   \       0x28   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x2C   0x2600             MOVNE    R6,#+0
   3440              {
   3441                xferrequest = I2C_NO_STARTSTOP;
   \       0x2E   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_2
   3442              }
   3443              else
   3444              {
   3445                /* Convert OTHER_xxx XferOptions if any */
   3446                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_1: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x.... 0x....      BL       I2C_ConvertOtherXferOptions
   3447          
   3448                /* Update xfermode accordingly if no reload is necessary */
   3449                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x36   0x8D60             LDRH     R0,[R4, #+42]
   \       0x38   0x28FF             CMP      R0,#+255
   \       0x3A   0xBF38             IT       CC 
   \       0x3C   0x6AE5             LDRCC    R5,[R4, #+44]
   3450                {
   3451                  xfermode = hi2c->XferOptions;
   3452                }
   3453              }
   3454          
   3455              /* Send Slave Address and set NBYTES to read */
   3456              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_2: (+1)
   \       0x3E   0x9600             STR      R6,[SP, #+0]
   \       0x40   0x8D22             LDRH     R2,[R4, #+40]
   \       0x42   0x462B             MOV      R3,R5
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x.... 0x....      BL       ??Subroutine96_0
   3457          
   3458              /* Process Unlocked */
   3459              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_226: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   3460          
   3461              /* Note : The I2C interrupts must be enabled after unlocking current process
   3462                        to avoid the risk of I2C interrupt handle execution before current
   3463                        process unlock */
   3464              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x4C   0x2102             MOVS     R1,#+2
   \       0x4E   0x7038             STRB     R0,[R7, #+0]
   \       0x50   0x.... 0x....      BL       ??Subroutine25_1
   3465          
   3466              return HAL_OK;
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_IT_3
   3467            }
   3468            else
   3469            {
   3470              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_IT_0: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_IT_3: (+1)
   \       0x5A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3471            }
   3472          }
   3473          
   3474          /**
   3475            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with DMA
   3476            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3477            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3478            *                the configuration information for the specified I2C.
   3479            * @param  DevAddress Target device address: The device 7 bits address value
   3480            *         in datasheet must be shifted to the left before calling the interface
   3481            * @param  pData Pointer to data buffer
   3482            * @param  Size Amount of data to be sent
   3483            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3484            * @retval HAL status
   3485            */

   \                                 In section .text, align 2, keep-with-next
   3486          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3487          {
   \                     HAL_I2C_Master_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   3488            uint32_t xfermode;
   3489            uint32_t xferrequest = I2C_GENERATE_START_READ;
   3490            HAL_StatusTypeDef dmaxferstatus;
   3491          
   3492            /* Check the parameters */
   3493            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3494          
   3495            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x6   0xF105 0x0640      ADD      R6,R5,#+64
   \        0xA   0x7870             LDRB     R0,[R6, #+1]
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable25_1  ;; 0x80002400
   \       0x10   0x4689             MOV      R9,R1
   \       0x12   0x46C2             MOV      R10,R8
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xD150             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_0
   3496            {
   3497              /* Process Locked */
   3498              __HAL_LOCK(hi2c);
   \       0x18   0x7831             LDRB     R1,[R6, #+0]
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xD04D             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_0
   \       0x1E   0x4614             MOV      R4,R2
   \       0x20   0x980A             LDR      R0,[SP, #+40]
   \       0x22   0x2201             MOVS     R2,#+1
   3499          
   3500              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x24   0x2122             MOVS     R1,#+34
   \       0x26   0x7032             STRB     R2,[R6, #+0]
   3501              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3502              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x28   0xF04F 0x0E00      MOV      LR,#+0
   \       0x2C   0x7071             STRB     R1,[R6, #+1]
   \       0x2E   0x2110             MOVS     R1,#+16
   \       0x30   0x70B1             STRB     R1,[R6, #+2]
   3503          
   3504              /* Prepare transfer parameters */
   3505              hi2c->pBuffPtr    = pData;
   3506              hi2c->XferCount   = Size;
   3507              hi2c->XferOptions = XferOptions;
   3508              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x32   0x.... 0x....      ADR.W    R1,I2C_Master_ISR_DMA
   \       0x36   0xF8C6 0xE004      STR      LR,[R6, #+4]
   \       0x3A   0x626C             STR      R4,[R5, #+36]
   \       0x3C   0x856B             STRH     R3,[R5, #+42]
   \       0x3E   0x62E8             STR      R0,[R5, #+44]
   \       0x40   0x6369             STR      R1,[R5, #+52]
   3509          
   3510              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3511              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x42   0x8D6A             LDRH     R2,[R5, #+42]
   \       0x44   0x2AFF             CMP      R2,#+255
   \       0x46   0xD904             BLS.N    ??HAL_I2C_Master_Seq_Receive_DMA_1
   3512              {
   3513                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x48   0x21FF             MOVS     R1,#+255
   3514                xfermode = I2C_RELOAD_MODE;
   \       0x4A   0xF04F 0x7780      MOV      R7,#+16777216
   \       0x4E   0x8529             STRH     R1,[R5, #+40]
   \       0x50   0xE002             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_2
   3515              }
   3516              else
   3517              {
   3518                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_1: (+1)
   \       0x52   0x8D6A             LDRH     R2,[R5, #+42]
   \       0x54   0x852A             STRH     R2,[R5, #+40]
   3519                xfermode = hi2c->XferOptions;
   \       0x56   0x6AEF             LDR      R7,[R5, #+44]
   3520              }
   3521          
   3522              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3523              /* Mean Previous state is same as current state */
   3524              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_2: (+1)
   \       0x58   0x6B29             LDR      R1,[R5, #+48]
   \       0x5A   0x2912             CMP      R1,#+18
   \       0x5C   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_3
   \       0x5E   0x28AA             CMP      R0,#+170
   \       0x60   0xBF1C             ITT      NE 
   \       0x62   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x66   0x46F2             MOVNE    R10,LR
   3525              {
   3526                xferrequest = I2C_NO_STARTSTOP;
   \       0x68   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_4
   3527              }
   3528              else
   3529              {
   3530                /* Convert OTHER_xxx XferOptions if any */
   3531                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_3: (+1)
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x.... 0x....      BL       I2C_ConvertOtherXferOptions
   3532          
   3533                /* Update xfermode accordingly if no reload is necessary */
   3534                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x70   0x8D68             LDRH     R0,[R5, #+42]
   \       0x72   0x28FF             CMP      R0,#+255
   \       0x74   0xBF38             IT       CC 
   \       0x76   0x6AEF             LDRCC    R7,[R5, #+44]
   3535                {
   3536                  xfermode = hi2c->XferOptions;
   3537                }
   3538              }
   3539          
   3540              if (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_4: (+1)
   \       0x78   0x8D28             LDRH     R0,[R5, #+40]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD017             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_5
   3541              {
   3542                if (hi2c->hdmarx != NULL)
   \       0x7E   0x6BE8             LDR      R0,[R5, #+60]
   \       0x80   0xB168             CBZ.N    R0,??HAL_I2C_Master_Seq_Receive_DMA_6
   3543                {
   3544                  /* Set the I2C DMA transfer complete callback */
   3545                  hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x82   0x....             LDR.N    R1,??DataTable25
   \       0x84   0x.... 0x....      BL       ?Subroutine15
   3546          
   3547                  /* Set the DMA error callback */
   3548                  hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   3549          
   3550                  /* Set the unused DMA callbacks to NULL */
   3551                  hi2c->hdmarx->XferHalfCpltCallback = NULL;
   3552                  hi2c->hdmarx->XferAbortCallback = NULL;
   3553          
   3554                  /* Enable the DMA stream */
   3555                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   3556                }
   3557                else
   3558                {
   3559                  /* Update I2C state */
   3560                  hi2c->State     = HAL_I2C_STATE_READY;
   3561                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3562          
   3563                  /* Update I2C error code */
   3564                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3565          
   3566                  /* Process Unlocked */
   3567                  __HAL_UNLOCK(hi2c);
   3568          
   3569                  return HAL_ERROR;
   3570                }
   3571          
   3572                if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x88   0xB960             CBNZ.N   R0,??HAL_I2C_Master_Seq_Receive_DMA_7
   3573                {
   3574                  /* Send Slave Address and set NBYTES to read */
   3575                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \       0x8A   0x.... 0x....      BL       ?Subroutine74
   3576          
   3577                  /* Update XferCount value */
   3578                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_235: (+1)
   \       0x8E   0x.... 0x....      BL       ?Subroutine65
   3579          
   3580                  /* Process Unlocked */
   3581                  __HAL_UNLOCK(hi2c);
   3582          
   3583                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3584                            to avoid the risk of I2C interrupt handle execution before current
   3585                            process unlock */
   3586                  /* Enable ERR and NACK interrupts */
   3587                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   3588          
   3589                  /* Enable DMA Request */
   3590                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_147: (+1)
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x6801             LDR      R1,[R0, #+0]
   \       0x96   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x9A   0x6001             STR      R1,[R0, #+0]
   \       0x9C   0xE00B             B.N      ??CrossCallReturnLabel_98
   3591                }
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_6: (+1)
   \       0x9E   0x.... 0x....      BL       ?Subroutine44
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0xA2   0xE001             B.N      ??CrossCallReturnLabel_158
   3592                else
   3593                {
   3594                  /* Update I2C state */
   3595                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_7: (+1)
   \       0xA4   0x.... 0x....      BL       ?Subroutine70
   3596                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3597          
   3598                  /* Update I2C error code */
   3599                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3600          
   3601                  /* Process Unlocked */
   3602                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_158: (+1)
   \       0xA8   0x7032             STRB     R2,[R6, #+0]
   3603          
   3604                  return HAL_ERROR;
   \       0xAA   0x2001             MOVS     R0,#+1
   \       0xAC   0xE006             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_8
   3605                }
   3606              }
   3607              else
   3608              {
   3609                /* Update Transfer ISR function pointer */
   3610                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_5: (+1)
   \       0xAE   0x.... 0x....      BL       ?Subroutine69
   3611          
   3612                /* Send Slave Address */
   3613                /* Set NBYTES to read and generate START condition */
   3614                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   3615          
   3616                /* Process Unlocked */
   3617                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_155: (+1)
   \       0xB2   0x.... 0x....      BL       ?Subroutine47
   3618          
   3619                /* Note : The I2C interrupts must be enabled after unlocking current process
   3620                          to avoid the risk of I2C interrupt handle execution before current
   3621                          process unlock */
   3622                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   3623                /* possible to enable all of these */
   3624                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   3625                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   3626              }
   3627          
   3628              return HAL_OK;
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_8
   3629            }
   3630            else
   3631            {
   3632              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_0: (+1)
   \       0xBA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_8: (+1)
   \       0xBC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3633            }
   3634          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x63C1             STR      R1,[R0, #+60]
   \        0x2   0x6BEA             LDR      R2,[R5, #+60]
   \        0x4   0x.... 0x....      ADR.W    R0,I2C_DMAError
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x64D0             STR      R0,[R2, #+76]
   \        0xC   0x6BE8             LDR      R0,[R5, #+60]
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6401             STR      R1,[R0, #+64]
   \       0x12   0x6BE9             LDR      R1,[R5, #+60]
   \       0x14   0x650A             STR      R2,[R1, #+80]
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x1A   0x4622             MOV      R2,R4
   \       0x1C   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x20   0x6BE8             LDR      R0,[R5, #+60]
   \       0x22   0x.... 0x....      B.W      HAL_DMA_Start_IT
   3635          
   3636          /**
   3637            * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
   3638            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3639            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3640            *                the configuration information for the specified I2C.
   3641            * @param  pData Pointer to data buffer
   3642            * @param  Size Amount of data to be sent
   3643            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3644            * @retval HAL status
   3645            */

   \                                 In section .text, align 2, keep-with-next
   3646          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3647          {
   \                     HAL_I2C_Slave_Seq_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine80
   3648            /* Check the parameters */
   3649            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3650          
   3651            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_179: (+1)
   \        0x8   0xD133             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_0
   3652            {
   3653              if ((pData == NULL) || (Size == 0U))
   \        0xA   0xB10C             CBZ.N    R4,??HAL_I2C_Slave_Seq_Transmit_IT_1
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_2
   3654              {
   3655                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_1: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine82
   3656                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_185: (+1)
   \       0x14   0xE02D             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_0
   3657              }
   3658          
   3659              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3660              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_2: (+1)
   \       0x16   0x2105             MOVS     R1,#+5
   \       0x18   0x.... 0x....      BL       ??Subroutine89_0
   3661          
   3662              /* Process Locked */
   3663              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_208: (+1)
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xBF08             IT       EQ 
   \       0x22   0x2002             MOVEQ    R0,#+2
   \       0x24   0xD026             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_IT_3
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x7031             STRB     R1,[R6, #+0]
   3664          
   3665              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3666              /* and then toggle the HAL slave RX state to TX state */
   3667              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \       0x2A   0x7870             LDRB     R0,[R6, #+1]
   \       0x2C   0x282A             CMP      R0,#+42
   \       0x2E   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_4
   3668              {
   3669                /* Disable associated Interrupts */
   3670                I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x30   0x.... 0x....      BL       ?Subroutine89
   3671          
   3672                /* Abort DMA Xfer if any */
   3673                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??CrossCallReturnLabel_210: (+1)
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0x040A             LSLS     R2,R1,#+16
   \       0x3A   0xD50C             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_IT_4
   3674                {
   3675                  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x3C   0x.... 0x....      BL       ?Subroutine41
   3676          
   3677                  if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x40   0xB148             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_IT_4
   3678                  {
   3679                    /* Set the I2C DMA Abort callback :
   3680                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3681                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable37
   \       0x46   0x6501             STR      R1,[R0, #+80]
   3682          
   3683                    /* Abort DMA RX */
   3684                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x48   0x6BE8             LDR      R0,[R5, #+60]
   \       0x4A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x4E   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_IT_4
   3685                    {
   3686                      /* Call Directly XferAbortCallback function in case of error */
   3687                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x50   0x6BE8             LDR      R0,[R5, #+60]
   \       0x52   0x6D01             LDR      R1,[R0, #+80]
   \       0x54   0x4788             BLX      R1
   3688                    }
   3689                  }
   3690                }
   3691              }
   3692          
   3693              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_4: (+1)
   \       0x56   0x2029             MOVS     R0,#+41
   3694              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x.... 0x....      BL       ?Subroutine12
   3695              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3696          
   3697              /* Enable Address Acknowledge */
   3698              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3699          
   3700              /* Prepare transfer parameters */
   3701              hi2c->pBuffPtr    = pData;
   3702              hi2c->XferCount   = Size;
   3703              hi2c->XferSize    = hi2c->XferCount;
   3704              hi2c->XferOptions = XferOptions;
   3705              hi2c->XferISR     = I2C_Slave_ISR_IT;
   3706          
   3707              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x5C   0xBF44             ITT      MI 
   \       0x5E   0x2308             MOVMI    R3,#+8
   \       0x60   0x61C3             STRMI    R3,[R0, #+28]
   3708              {
   3709                /* Clear ADDR flag after prepare the transfer parameters */
   3710                /* This action will generate an acknowledge to the Master */
   3711                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3712              }
   3713          
   3714              /* Process Unlocked */
   3715              __HAL_UNLOCK(hi2c);
   \       0x62   0x2000             MOVS     R0,#+0
   3716          
   3717              /* Note : The I2C interrupts must be enabled after unlocking current process
   3718              to avoid the risk of I2C interrupt handle execution before current
   3719              process unlock */
   3720              /* REnable ADDR interrupt */
   3721              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
   \       0x64   0x2105             MOVS     R1,#+5
   \       0x66   0x7030             STRB     R0,[R6, #+0]
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x.... 0x....      BL       I2C_Enable_IRQ
   3722          
   3723              return HAL_OK;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE000             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_3
   3724            }
   3725            else
   3726            {
   3727              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_0: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_3: (+1)
   \       0x74   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3728            }
   3729          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine89: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \                     ??Subroutine89_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      I2C_Disable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine82: (+1)
   \        0x0   0xF44F 0x7000      MOV      R0,#+512
   \        0x4   0x6070             STR      R0,[R6, #+4]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine80: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x0640      ADD      R6,R5,#+64
   \        0x6   0x7870             LDRB     R0,[R6, #+1]
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF000 0x0028      AND      R0,R0,#0x28
   \       0x12   0x2828             CMP      R0,#+40
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x7070             STRB     R0,[R6, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B2             STRB     R2,[R6, #+2]
   \        0x8   0x6071             STR      R1,[R6, #+4]
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x.... 0x....      ADR.W    R1,I2C_Slave_ISR_IT
   \       0x10   0x6842             LDR      R2,[R0, #+4]
   \       0x12   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x16   0x6042             STR      R2,[R0, #+4]
   \       0x18   0x626C             STR      R4,[R5, #+36]
   \       0x1A   0x856F             STRH     R7,[R5, #+42]
   \       0x1C   0x8D68             LDRH     R0,[R5, #+42]
   \       0x1E   0x8528             STRH     R0,[R5, #+40]
   \       0x20   0xF8C5 0x802C      STR      R8,[R5, #+44]
   \       0x24   0x6369             STR      R1,[R5, #+52]
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6982             LDR      R2,[R0, #+24]
   \       0x2A   0x03D1             LSLS     R1,R2,#+15
   \       0x2C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \        0x0   0x6803             LDR      R3,[R0, #+0]
   \        0x2   0xF423 0x4300      BIC      R3,R3,#0x8000
   \        0x6   0x6003             STR      R3,[R0, #+0]
   \        0x8   0x6BE8             LDR      R0,[R5, #+60]
   \        0xA   0x4770             BX       LR
   3730          
   3731          /**
   3732            * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with DMA
   3733            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3734            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3735            *                the configuration information for the specified I2C.
   3736            * @param  pData Pointer to data buffer
   3737            * @param  Size Amount of data to be sent
   3738            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3739            * @retval HAL status
   3740            */

   \                                 In section .text, align 2, keep-with-next
   3741          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3742          {
   \                     HAL_I2C_Slave_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine80
   3743            HAL_StatusTypeDef dmaxferstatus;
   3744          
   3745            /* Check the parameters */
   3746            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3747          
   3748            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_180: (+1)
   \        0x8   0xD155             BNE.N    ??CrossCallReturnLabel_153
   3749            {
   3750              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE 
   \        0xE   0x2F00             CMPNE    R7,#+0
   \       0x10   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   3751              {
   3752                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x12   0x.... 0x....      BL       ?Subroutine82
   3753                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_186: (+1)
   \       0x16   0xE04E             B.N      ??CrossCallReturnLabel_153
   3754              }
   3755          
   3756              /* Process Locked */
   3757              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_0: (+1)
   \       0x18   0x7831             LDRB     R1,[R6, #+0]
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xBF08             IT       EQ 
   \       0x1E   0x2002             MOVEQ    R0,#+2
   \       0x20   0xD04A             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_1
   \       0x22   0x2001             MOVS     R0,#+1
   3758          
   3759              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3760              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
   \       0x24   0x2105             MOVS     R1,#+5
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   \       0x28   0x.... 0x....      BL       ??Subroutine89_0
   3761          
   3762              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3763              /* and then toggle the HAL slave RX state to TX state */
   3764              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??CrossCallReturnLabel_207: (+1)
   \       0x2C   0x7870             LDRB     R0,[R6, #+1]
   \       0x2E   0x.... 0x....      LDR.W    R9,??DataTable37
   \       0x32   0x282A             CMP      R0,#+42
   \       0x34   0xD111             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   3765              {
   3766                /* Disable associated Interrupts */
   3767                I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x36   0x.... 0x....      BL       ?Subroutine89
   3768          
   3769                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??CrossCallReturnLabel_209: (+1)
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x680A             LDR      R2,[R1, #+0]
   \       0x3E   0x0413             LSLS     R3,R2,#+16
   \       0x40   0xD51B             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3770                {
   3771                  /* Abort DMA Xfer if any */
   3772                  if (hi2c->hdmarx != NULL)
   \       0x42   0x6BE8             LDR      R0,[R5, #+60]
   \       0x44   0xB1C8             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3773                  {
   3774                    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x4C   0x600A             STR      R2,[R1, #+0]
   3775          
   3776                    /* Set the I2C DMA Abort callback :
   3777                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3778                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x4E   0x6BE8             LDR      R0,[R5, #+60]
   \       0x50   0x.... 0x....      BL       ?Subroutine92
   3779          
   3780                    /* Abort DMA RX */
   3781                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_217: (+1)
   \       0x54   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3782                    {
   3783                      /* Call Directly XferAbortCallback function in case of error */
   3784                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x56   0x6BE8             LDR      R0,[R5, #+60]
   \       0x58   0xE00D             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3785                    }
   3786                  }
   3787                }
   3788              }
   3789              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_2: (+1)
   \       0x5A   0x7870             LDRB     R0,[R6, #+1]
   \       0x5C   0x2829             CMP      R0,#+41
   \       0x5E   0xD10C             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3790              {
   3791                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \       0x60   0x6828             LDR      R0,[R5, #+0]
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x044A             LSLS     R2,R1,#+17
   \       0x66   0xD508             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3792                {
   3793                  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x68   0x.... 0x....      BL       ?Subroutine42
   3794          
   3795                  /* Abort DMA Xfer if any */
   3796                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x6C   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3797                  {
   3798                    /* Set the I2C DMA Abort callback :
   3799                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3800                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x6E   0x.... 0x....      BL       ?Subroutine93
   3801          
   3802                    /* Abort DMA TX */
   3803                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \                     ??CrossCallReturnLabel_219: (+1)
   \       0x72   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3804                    {
   3805                      /* Call Directly XferAbortCallback function in case of error */
   3806                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x74   0x6BA8             LDR      R0,[R5, #+56]
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_4: (+1)
   \       0x76   0x6D01             LDR      R1,[R0, #+80]
   \       0x78   0x4788             BLX      R1
   3807                    }
   3808                  }
   3809                }
   3810              }
   3811              else
   3812              {
   3813                /* Nothing to do */
   3814              }
   3815          
   3816              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_3: (+1)
   \       0x7A   0x2029             MOVS     R0,#+41
   3817              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x7C   0x.... 0x....      BL       ?Subroutine13
   3818              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3819          
   3820              /* Enable Address Acknowledge */
   3821              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3822          
   3823              /* Prepare transfer parameters */
   3824              hi2c->pBuffPtr    = pData;
   3825              hi2c->XferCount   = Size;
   3826              hi2c->XferSize    = hi2c->XferCount;
   3827              hi2c->XferOptions = XferOptions;
   3828              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   3829          
   3830              if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x80   0x6BA8             LDR      R0,[R5, #+56]
   \       0x82   0x6369             STR      R1,[R5, #+52]
   \       0x84   0xB190             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_5
   3831              {
   3832                /* Set the I2C DMA transfer complete callback */
   3833                hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \       0x86   0x....             LDR.N    R1,??DataTable27
   \       0x88   0x.... 0x....      BL       ?Subroutine14
   3834          
   3835                /* Set the DMA error callback */
   3836                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3837          
   3838                /* Set the unused DMA callbacks to NULL */
   3839                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   3840                hi2c->hdmatx->XferAbortCallback = NULL;
   3841          
   3842                /* Enable the DMA stream */
   3843                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   3844              }
   3845              else
   3846              {
   3847                /* Update I2C state */
   3848                hi2c->State     = HAL_I2C_STATE_LISTEN;
   3849                hi2c->Mode      = HAL_I2C_MODE_NONE;
   3850          
   3851                /* Update I2C error code */
   3852                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3853          
   3854                /* Process Unlocked */
   3855                __HAL_UNLOCK(hi2c);
   3856          
   3857                return HAL_ERROR;
   3858              }
   3859          
   3860              if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x8C   0xB988             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Transmit_DMA_6
   3861              {
   3862                /* Update XferCount value */
   3863                hi2c->XferCount -= hi2c->XferSize;
   \       0x8E   0x.... 0x....      BL       ?Subroutine71
   3864          
   3865                /* Reset XferSize */
   3866                hi2c->XferSize = 0;
   3867              }
   3868              else
   3869              {
   3870                /* Update I2C state */
   3871                hi2c->State     = HAL_I2C_STATE_LISTEN;
   3872                hi2c->Mode      = HAL_I2C_MODE_NONE;
   3873          
   3874                /* Update I2C error code */
   3875                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3876          
   3877                /* Process Unlocked */
   3878                __HAL_UNLOCK(hi2c);
   3879          
   3880                return HAL_ERROR;
   3881              }
   3882          
   3883              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
   \                     ??CrossCallReturnLabel_159: (+1)
   \       0x92   0xBF44             ITT      MI 
   \       0x94   0x2308             MOVMI    R3,#+8
   \       0x96   0x61C3             STRMI    R3,[R0, #+28]
   3884              {
   3885                /* Clear ADDR flag after prepare the transfer parameters */
   3886                /* This action will generate an acknowledge to the Master */
   3887                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3888              }
   3889          
   3890              /* Process Unlocked */
   3891              __HAL_UNLOCK(hi2c);
   \       0x98   0x2000             MOVS     R0,#+0
   3892          
   3893              /* Note : The I2C interrupts must be enabled after unlocking current process
   3894              to avoid the risk of I2C interrupt handle execution before current
   3895              process unlock */
   3896              /* Enable ERR, STOP, NACK, ADDR interrupts */
   3897              I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0x9A   0x2104             MOVS     R1,#+4
   \       0x9C   0x7030             STRB     R0,[R6, #+0]
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x.... 0x....      BL       I2C_Enable_IRQ
   3898          
   3899              /* Enable DMA Request */
   3900              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \       0xA4   0x6828             LDR      R0,[R5, #+0]
   \       0xA6   0x.... 0x....      BL       ?Subroutine33
   3901          
   3902              return HAL_OK;
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0xAA   0xE005             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_1
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_5: (+1)
   \       0xAC   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0xB0   0xE001             B.N      ??CrossCallReturnLabel_153
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_6: (+1)
   \       0xB2   0x.... 0x....      BL       ?Subroutine68
   3903            }
   3904            else
   3905            {
   3906              return HAL_ERROR;
   \                     ??CrossCallReturnLabel_153: (+1)
   \       0xB6   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_1: (+1)
   \       0xB8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   3907            }
   3908          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \        0x0   0x6803             LDR      R3,[R0, #+0]
   \        0x2   0xF423 0x4380      BIC      R3,R3,#0x4000
   \        0x6   0x6003             STR      R3,[R0, #+0]
   \        0x8   0x6BA8             LDR      R0,[R5, #+56]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine93: (+1)
   \        0x0   0xF8C0 0x9050      STR      R9,[R0, #+80]
   \        0x4   0x6BA8             LDR      R0,[R5, #+56]
   \        0x6   0x.... 0x....      B.W      HAL_DMA_Abort_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine92: (+1)
   \        0x0   0xF8C0 0x9050      STR      R9,[R0, #+80]
   \        0x4   0x6BE8             LDR      R0,[R5, #+60]
   \        0x6   0x.... 0x....      B.W      HAL_DMA_Abort_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine71: (+1)
   \        0x0   0x8D69             LDRH     R1,[R5, #+42]
   \        0x2   0x8D28             LDRH     R0,[R5, #+40]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x1A09             SUBS     R1,R1,R0
   \        0x8   0x8569             STRH     R1,[R5, #+42]
   \        0xA   0x852A             STRH     R2,[R5, #+40]
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x6981             LDR      R1,[R0, #+24]
   \       0x10   0x03CA             LSLS     R2,R1,#+15
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine68: (+1)
   \        0x0   0x2128             MOVS     R1,#+40
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x7071             STRB     R1,[R6, #+1]
   \        0x6   0x70B2             STRB     R2,[R6, #+2]
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6070             STR      R0,[R6, #+4]
   \       0x10   0x7032             STRB     R2,[R6, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x7070             STRB     R0,[R6, #+1]
   \        0x6   0x70B1             STRB     R1,[R6, #+2]
   \        0x8   0x6872             LDR      R2,[R6, #+4]
   \        0xA   0xF042 0x0280      ORR      R2,R2,#0x80
   \        0xE   0x6072             STR      R2,[R6, #+4]
   \       0x10   0x7031             STRB     R1,[R6, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x7070             STRB     R0,[R6, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B2             STRB     R2,[R6, #+2]
   \        0x8   0x6071             STR      R1,[R6, #+4]
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x.... 0x....      ADR.W    R1,I2C_Slave_ISR_DMA
   \       0x10   0x6842             LDR      R2,[R0, #+4]
   \       0x12   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x16   0x6042             STR      R2,[R0, #+4]
   \       0x18   0x626C             STR      R4,[R5, #+36]
   \       0x1A   0x856F             STRH     R7,[R5, #+42]
   \       0x1C   0x8D68             LDRH     R0,[R5, #+42]
   \       0x1E   0x8528             STRH     R0,[R5, #+40]
   \       0x20   0xF8C5 0x802C      STR      R8,[R5, #+44]
   \       0x24   0x4770             BX       LR
   3909          
   3910          /**
   3911            * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
   3912            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3913            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3914            *                the configuration information for the specified I2C.
   3915            * @param  pData Pointer to data buffer
   3916            * @param  Size Amount of data to be sent
   3917            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3918            * @retval HAL status
   3919            */

   \                                 In section .text, align 2, keep-with-next
   3920          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3921          {
   \                     HAL_I2C_Slave_Seq_Receive_IT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine80
   3922            /* Check the parameters */
   3923            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3924          
   3925            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_181: (+1)
   \        0x8   0xD12F             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_0
   3926            {
   3927              if ((pData == NULL) || (Size == 0U))
   \        0xA   0xB10C             CBZ.N    R4,??HAL_I2C_Slave_Seq_Receive_IT_1
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_2
   3928              {
   3929                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_1: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine82
   3930                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_187: (+1)
   \       0x14   0xE029             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_0
   3931              }
   3932          
   3933              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3934              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_2: (+1)
   \       0x16   0x2106             MOVS     R1,#+6
   \       0x18   0x.... 0x....      BL       ??Subroutine89_0
   3935          
   3936              /* Process Locked */
   3937              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_206: (+1)
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xBF08             IT       EQ 
   \       0x22   0x2002             MOVEQ    R0,#+2
   \       0x24   0xD022             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_IT_3
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x7031             STRB     R1,[R6, #+0]
   3938          
   3939              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3940              /* and then toggle the HAL slave TX state to RX state */
   3941              if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x2A   0x7870             LDRB     R0,[R6, #+1]
   \       0x2C   0x2829             CMP      R0,#+41
   \       0x2E   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_4
   3942              {
   3943                /* Disable associated Interrupts */
   3944                I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x30   0x.... 0x....      BL       ??Subroutine89_0
   3945          
   3946                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??CrossCallReturnLabel_205: (+1)
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0x044A             LSLS     R2,R1,#+17
   \       0x3A   0xD50C             BPL.N    ??HAL_I2C_Slave_Seq_Receive_IT_4
   3947                {
   3948                  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x3C   0x.... 0x....      BL       ?Subroutine42
   3949          
   3950                  /* Abort DMA Xfer if any */
   3951                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x40   0xB148             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_IT_4
   3952                  {
   3953                    /* Set the I2C DMA Abort callback :
   3954                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3955                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable38
   \       0x46   0x6501             STR      R1,[R0, #+80]
   3956          
   3957                    /* Abort DMA TX */
   3958                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x48   0x6BA8             LDR      R0,[R5, #+56]
   \       0x4A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x4E   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_IT_4
   3959                    {
   3960                      /* Call Directly XferAbortCallback function in case of error */
   3961                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x50   0x6BA8             LDR      R0,[R5, #+56]
   \       0x52   0x6D01             LDR      R1,[R0, #+80]
   \       0x54   0x4788             BLX      R1
   3962                    }
   3963                  }
   3964                }
   3965              }
   3966          
   3967              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_4: (+1)
   \       0x56   0x202A             MOVS     R0,#+42
   3968              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x.... 0x....      BL       ?Subroutine12
   3969              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3970          
   3971              /* Enable Address Acknowledge */
   3972              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3973          
   3974              /* Prepare transfer parameters */
   3975              hi2c->pBuffPtr    = pData;
   3976              hi2c->XferCount   = Size;
   3977              hi2c->XferSize    = hi2c->XferCount;
   3978              hi2c->XferOptions = XferOptions;
   3979              hi2c->XferISR     = I2C_Slave_ISR_IT;
   3980          
   3981              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x5C   0xBF5C             ITT      PL 
   \       0x5E   0x2308             MOVPL    R3,#+8
   \       0x60   0x61C3             STRPL    R3,[R0, #+28]
   3982              {
   3983                /* Clear ADDR flag after prepare the transfer parameters */
   3984                /* This action will generate an acknowledge to the Master */
   3985                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3986              }
   3987          
   3988              /* Process Unlocked */
   3989              __HAL_UNLOCK(hi2c);
   \       0x62   0x.... 0x....      BL       ?Subroutine48
   3990          
   3991              /* Note : The I2C interrupts must be enabled after unlocking current process
   3992              to avoid the risk of I2C interrupt handle execution before current
   3993              process unlock */
   3994              /* REnable ADDR interrupt */
   3995              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   3996          
   3997              return HAL_OK;
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE000             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_3
   3998            }
   3999            else
   4000            {
   4001              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_0: (+1)
   \       0x6A   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_3: (+1)
   \       0x6C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4002            }
   4003          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x2106             MOVS     R1,#+6
   \        0x4   0x7030             STRB     R0,[R6, #+0]
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      B.W      I2C_Enable_IRQ
   4004          
   4005          /**
   4006            * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with DMA
   4007            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4008            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4009            *                the configuration information for the specified I2C.
   4010            * @param  pData Pointer to data buffer
   4011            * @param  Size Amount of data to be sent
   4012            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   4013            * @retval HAL status
   4014            */

   \                                 In section .text, align 2, keep-with-next
   4015          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4016          {
   \                     HAL_I2C_Slave_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine80
   4017            HAL_StatusTypeDef dmaxferstatus;
   4018          
   4019            /* Check the parameters */
   4020            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4021          
   4022            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_182: (+1)
   \        0x8   0xD152             BNE.N    ??CrossCallReturnLabel_154
   4023            {
   4024              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE 
   \        0xE   0x2F00             CMPNE    R7,#+0
   \       0x10   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_0
   4025              {
   4026                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x12   0x.... 0x....      BL       ?Subroutine82
   4027                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_188: (+1)
   \       0x16   0xE04B             B.N      ??CrossCallReturnLabel_154
   4028              }
   4029          
   4030              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4031              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_0: (+1)
   \       0x18   0x2106             MOVS     R1,#+6
   \       0x1A   0x.... 0x....      BL       ??Subroutine89_0
   4032          
   4033              /* Process Locked */
   4034              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_204: (+1)
   \       0x1E   0x7830             LDRB     R0,[R6, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xBF08             IT       EQ 
   \       0x24   0x2002             MOVEQ    R0,#+2
   \       0x26   0xD044             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_1
   \       0x28   0x2101             MOVS     R1,#+1
   4035          
   4036              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4037              /* and then toggle the HAL slave TX state to RX state */
   4038              if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x2A   0x.... 0x....      LDR.W    R9,??DataTable38
   \       0x2E   0x7031             STRB     R1,[R6, #+0]
   \       0x30   0x7870             LDRB     R0,[R6, #+1]
   \       0x32   0x2829             CMP      R0,#+41
   \       0x34   0xD111             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   4039              {
   4040                /* Disable associated Interrupts */
   4041                I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x36   0x.... 0x....      BL       ??Subroutine89_0
   4042          
   4043                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??CrossCallReturnLabel_203: (+1)
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x680A             LDR      R2,[R1, #+0]
   \       0x3E   0x0453             LSLS     R3,R2,#+17
   \       0x40   0xD51B             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4044                {
   4045                  /* Abort DMA Xfer if any */
   4046                  if (hi2c->hdmatx != NULL)
   \       0x42   0x6BA8             LDR      R0,[R5, #+56]
   \       0x44   0xB1C8             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_3
   4047                  {
   4048                    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x4C   0x600A             STR      R2,[R1, #+0]
   4049          
   4050                    /* Set the I2C DMA Abort callback :
   4051                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4052                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x4E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x50   0x.... 0x....      BL       ?Subroutine93
   4053          
   4054                    /* Abort DMA TX */
   4055                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \                     ??CrossCallReturnLabel_218: (+1)
   \       0x54   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_3
   4056                    {
   4057                      /* Call Directly XferAbortCallback function in case of error */
   4058                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x56   0x6BA8             LDR      R0,[R5, #+56]
   \       0x58   0xE00D             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_4
   4059                    }
   4060                  }
   4061                }
   4062              }
   4063              else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_2: (+1)
   \       0x5A   0x7870             LDRB     R0,[R6, #+1]
   \       0x5C   0x282A             CMP      R0,#+42
   \       0x5E   0xD10C             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4064              {
   4065                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \       0x60   0x6828             LDR      R0,[R5, #+0]
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x040A             LSLS     R2,R1,#+16
   \       0x66   0xD508             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4066                {
   4067                  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x68   0x.... 0x....      BL       ?Subroutine41
   4068          
   4069                  /* Abort DMA Xfer if any */
   4070                  if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0x6C   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_3
   4071                  {
   4072                    /* Set the I2C DMA Abort callback :
   4073                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4074                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x6E   0x.... 0x....      BL       ?Subroutine92
   4075          
   4076                    /* Abort DMA RX */
   4077                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_216: (+1)
   \       0x72   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_3
   4078                    {
   4079                      /* Call Directly XferAbortCallback function in case of error */
   4080                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x74   0x6BE8             LDR      R0,[R5, #+60]
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_4: (+1)
   \       0x76   0x6D01             LDR      R1,[R0, #+80]
   \       0x78   0x4788             BLX      R1
   4081                    }
   4082                  }
   4083                }
   4084              }
   4085              else
   4086              {
   4087                /* Nothing to do */
   4088              }
   4089          
   4090              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_3: (+1)
   \       0x7A   0x202A             MOVS     R0,#+42
   4091              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x7C   0x.... 0x....      BL       ?Subroutine13
   4092              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4093          
   4094              /* Enable Address Acknowledge */
   4095              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   4096          
   4097              /* Prepare transfer parameters */
   4098              hi2c->pBuffPtr    = pData;
   4099              hi2c->XferCount   = Size;
   4100              hi2c->XferSize    = hi2c->XferCount;
   4101              hi2c->XferOptions = XferOptions;
   4102              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   4103          
   4104              if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x80   0x6BE8             LDR      R0,[R5, #+60]
   \       0x82   0x6369             STR      R1,[R5, #+52]
   \       0x84   0xB178             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_5
   4105              {
   4106                /* Set the I2C DMA transfer complete callback */
   4107                hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \       0x86   0x.... 0x....      ADR.W    R1,I2C_DMASlaveReceiveCplt
   \       0x8A   0x.... 0x....      BL       ?Subroutine15
   4108          
   4109                /* Set the DMA error callback */
   4110                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   4111          
   4112                /* Set the unused DMA callbacks to NULL */
   4113                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   4114                hi2c->hdmarx->XferAbortCallback = NULL;
   4115          
   4116                /* Enable the DMA stream */
   4117                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   4118              }
   4119              else
   4120              {
   4121                /* Update I2C state */
   4122                hi2c->State     = HAL_I2C_STATE_LISTEN;
   4123                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4124          
   4125                /* Update I2C error code */
   4126                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   4127          
   4128                /* Process Unlocked */
   4129                __HAL_UNLOCK(hi2c);
   4130          
   4131                return HAL_ERROR;
   4132              }
   4133          
   4134              if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x8E   0xB968             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Receive_DMA_6
   4135              {
   4136                /* Update XferCount value */
   4137                hi2c->XferCount -= hi2c->XferSize;
   \       0x90   0x.... 0x....      BL       ?Subroutine71
   4138          
   4139                /* Reset XferSize */
   4140                hi2c->XferSize = 0;
   4141              }
   4142              else
   4143              {
   4144                /* Update I2C state */
   4145                hi2c->State     = HAL_I2C_STATE_LISTEN;
   4146                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4147          
   4148                /* Update I2C error code */
   4149                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   4150          
   4151                /* Process Unlocked */
   4152                __HAL_UNLOCK(hi2c);
   4153          
   4154                return HAL_ERROR;
   4155              }
   4156          
   4157              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
   \                     ??CrossCallReturnLabel_160: (+1)
   \       0x94   0xBF5C             ITT      PL 
   \       0x96   0x2308             MOVPL    R3,#+8
   \       0x98   0x61C3             STRPL    R3,[R0, #+28]
   4158              {
   4159                /* Clear ADDR flag after prepare the transfer parameters */
   4160                /* This action will generate an acknowledge to the Master */
   4161                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   4162              }
   4163          
   4164              /* Process Unlocked */
   4165              __HAL_UNLOCK(hi2c);
   \       0x9A   0x.... 0x....      BL       ?Subroutine48
   4166          
   4167              /* Note : The I2C interrupts must be enabled after unlocking current process
   4168              to avoid the risk of I2C interrupt handle execution before current
   4169              process unlock */
   4170              /* REnable ADDR interrupt */
   4171              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   4172          
   4173              /* Enable DMA Request */
   4174              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_100: (+1)
   \       0x9E   0x6828             LDR      R0,[R5, #+0]
   \       0xA0   0x.... 0x....      BL       ?Subroutine35
   4175          
   4176              return HAL_OK;
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0xA4   0xE005             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_1
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_5: (+1)
   \       0xA6   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0xAA   0xE001             B.N      ??CrossCallReturnLabel_154
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_6: (+1)
   \       0xAC   0x.... 0x....      BL       ?Subroutine68
   4177            }
   4178            else
   4179            {
   4180              return HAL_ERROR;
   \                     ??CrossCallReturnLabel_154: (+1)
   \       0xB0   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_1: (+1)
   \       0xB2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   4181            }
   4182          }
   4183          
   4184          /**
   4185            * @brief  Enable the Address listen mode with Interrupt.
   4186            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4187            *                the configuration information for the specified I2C.
   4188            * @retval HAL status
   4189            */

   \                                 In section .text, align 2, keep-with-next
   4190          HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
   4191          {
   \                     HAL_I2C_EnableListen_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4192            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0134      ADD      R1,R0,#+52
   \        0x6   0x7B4A             LDRB     R2,[R1, #+13]
   \        0x8   0x2A20             CMP      R2,#+32
   \        0xA   0xD109             BNE.N    ??HAL_I2C_EnableListen_IT_0
   4193            {
   4194              hi2c->State = HAL_I2C_STATE_LISTEN;
   \        0xC   0x2328             MOVS     R3,#+40
   4195              hi2c->XferISR = I2C_Slave_ISR_IT;
   \        0xE   0x.... 0x....      ADR.W    R4,I2C_Slave_ISR_IT
   \       0x12   0x734B             STRB     R3,[R1, #+13]
   \       0x14   0x600C             STR      R4,[R1, #+0]
   4196          
   4197              /* Enable the Address Match interrupt */
   4198              I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x.... 0x....      BL       I2C_Enable_IRQ
   4199          
   4200              return HAL_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}
   4201            }
   4202            else
   4203            {
   4204              return HAL_BUSY;
   \                     ??HAL_I2C_EnableListen_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   4205            }
   4206          }
   4207          
   4208          /**
   4209            * @brief  Disable the Address listen mode with Interrupt.
   4210            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4211            *                the configuration information for the specified I2C
   4212            * @retval HAL status
   4213            */

   \                                 In section .text, align 2, keep-with-next
   4214          HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
   4215          {
   \                     HAL_I2C_DisableListen_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4216            /* Declaration of tmp to prevent undefined behavior of volatile usage */
   4217            uint32_t tmp;
   4218          
   4219            /* Disable Address listen mode only if a transfer is not ongoing */
   4220            if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \        0x2   0xF100 0x0241      ADD      R2,R0,#+65
   \        0x6   0x7811             LDRB     R1,[R2, #+0]
   \        0x8   0x2928             CMP      R1,#+40
   \        0xA   0xD10F             BNE.N    ??HAL_I2C_DisableListen_IT_0
   4221            {
   4222              tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
   \        0xC   0x7813             LDRB     R3,[R2, #+0]
   4223              hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
   \        0xE   0x7851             LDRB     R1,[R2, #+1]
   4224              hi2c->State = HAL_I2C_STATE_READY;
   4225              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x10   0x2400             MOVS     R4,#+0
   \       0x12   0xF003 0x0303      AND      R3,R3,#0x3
   \       0x16   0x430B             ORRS     R3,R1,R3
   4226              hi2c->XferISR = NULL;
   4227          
   4228              /* Disable the Address Match interrupt */
   4229              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0x18   0x2104             MOVS     R1,#+4
   \       0x1A   0x6303             STR      R3,[R0, #+48]
   \       0x1C   0x2320             MOVS     R3,#+32
   \       0x1E   0x7013             STRB     R3,[R2, #+0]
   \       0x20   0x7054             STRB     R4,[R2, #+1]
   \       0x22   0x6344             STR      R4,[R0, #+52]
   \       0x24   0x.... 0x....      BL       I2C_Disable_IRQ
   4230          
   4231              return HAL_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD10             POP      {R4,PC}
   4232            }
   4233            else
   4234            {
   4235              return HAL_BUSY;
   \                     ??HAL_I2C_DisableListen_IT_0: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
   4236            }
   4237          }
   4238          
   4239          /**
   4240            * @brief  Abort a master I2C IT or DMA process communication with Interrupt.
   4241            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4242            *                the configuration information for the specified I2C.
   4243            * @param  DevAddress Target device address: The device 7 bits address value
   4244            *         in datasheet must be shifted to the left before calling the interface
   4245            * @retval HAL status
   4246            */

   \                                 In section .text, align 2, keep-with-next
   4247          HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
   4248          {
   \                     HAL_I2C_Master_Abort_IT: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine84
   4249            if (hi2c->Mode == HAL_I2C_MODE_MASTER)
   \                     ??CrossCallReturnLabel_191: (+1)
   \        0x6   0x78A8             LDRB     R0,[R5, #+2]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD11C             BNE.N    ??HAL_I2C_Master_Abort_IT_0
   4250            {
   4251              /* Process Locked */
   4252              __HAL_LOCK(hi2c);
   \        0xE   0x7829             LDRB     R1,[R5, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD101             BNE.N    ??HAL_I2C_Master_Abort_IT_1
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??HAL_I2C_Master_Abort_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   4253          
   4254              /* Disable Interrupts */
   4255              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x1A   0x2102             MOVS     R1,#+2
   \       0x1C   0x7028             STRB     R0,[R5, #+0]
   \       0x1E   0x.... 0x....      BL       ??Subroutine20_0
   4256              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x.... 0x....      BL       ??Subroutine20_0
   4257          
   4258              /* Set State at HAL_I2C_STATE_ABORT */
   4259              hi2c->State = HAL_I2C_STATE_ABORT;
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x28   0x2060             MOVS     R0,#+96
   4260          
   4261              /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
   4262              /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
   4263              I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable41  ;; 0x80004000
   \       0x2E   0x7068             STRB     R0,[R5, #+1]
   \       0x30   0xF04F 0x7300      MOV      R3,#+33554432
   \       0x34   0x9100             STR      R1,[SP, #+0]
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x.... 0x....      BL       ??Subroutine95_0
   4264          
   4265              /* Process Unlocked */
   4266              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_223: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   4267          
   4268              /* Note : The I2C interrupts must be enabled after unlocking current process
   4269                        to avoid the risk of I2C interrupt handle execution before current
   4270                        process unlock */
   4271              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   \       0x3E   0x2112             MOVS     R1,#+18
   \       0x40   0x.... 0x....      BL       ??Subroutine25_0
   4272          
   4273              return HAL_OK;
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD76             POP      {R1,R2,R4-R6,PC}
   4274            }
   4275            else
   4276            {
   4277              /* Wrong usage of abort function */
   4278              /* This function should be used only in case of abort monitored by master device */
   4279              return HAL_ERROR;
   \                     ??HAL_I2C_Master_Abort_IT_0: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4280            }
   4281          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine84: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0540      ADD      R5,R4,#+64
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x2104             MOVS     R1,#+4
   \                     ??Subroutine20_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      I2C_Disable_IRQ
   4282          
   4283          /**
   4284            * @}
   4285            */
   4286          
   4287          /** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   4288           * @{
   4289           */
   4290          
   4291          /**
   4292            * @brief  This function handles I2C event interrupt request.
   4293            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4294            *                the configuration information for the specified I2C.
   4295            * @retval None
   4296            */

   \                                 In section .text, align 2, keep-with-next
   4297          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   4298          {
   4299            /* Get current IT Flags and IT sources value */
   4300            uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x6991             LDR      R1,[R2, #+24]
   4301            uint32_t itsources = READ_REG(hi2c->Instance->CR1);
   \        0x4   0x6812             LDR      R2,[R2, #+0]
   4302          
   4303            /* I2C events treatment -------------------------------------*/
   4304            if (hi2c->XferISR != NULL)
   \        0x6   0x6B43             LDR      R3,[R0, #+52]
   \        0x8   0x2B00             CMP      R3,#+0
   \        0xA   0xBF18             IT       NE 
   4305            {
   4306              hi2c->XferISR(hi2c, itflags, itsources);
   \        0xC   0x4718             BXNE     R3
   4307            }
   4308          }
   \        0xE   0x4770             BX       LR               ;; return
   4309          
   4310          /**
   4311            * @brief  This function handles I2C error interrupt request.
   4312            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4313            *                the configuration information for the specified I2C.
   4314            * @retval None
   4315            */

   \                                 In section .text, align 2, keep-with-next
   4316          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   4317          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4318            uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x698A             LDR      R2,[R1, #+24]
   4319            uint32_t itsources = READ_REG(hi2c->Instance->CR1);
   \        0x6   0x680B             LDR      R3,[R1, #+0]
   4320            uint32_t tmperror;
   4321          
   4322            /* I2C Bus error interrupt occurred ------------------------------------*/
   4323            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \        0x8   0x05D4             LSLS     R4,R2,#+23
   \        0xA   0xD508             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \        0xC   0x061D             LSLS     R5,R3,#+24
   \        0xE   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   4324            {
   4325              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \       0x10   0x6C44             LDR      R4,[R0, #+68]
   4326          
   4327              /* Clear BERR flag */
   4328              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \       0x12   0xF44F 0x7580      MOV      R5,#+256
   \       0x16   0xF044 0x0401      ORR      R4,R4,#0x1
   \       0x1A   0x6444             STR      R4,[R0, #+68]
   \       0x1C   0x61CD             STR      R5,[R1, #+28]
   4329            }
   4330          
   4331            /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
   4332            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \       0x1E   0x0551             LSLS     R1,R2,#+21
   \       0x20   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \       0x22   0x061C             LSLS     R4,R3,#+24
   \       0x24   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   4333            {
   4334              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \       0x26   0x6C41             LDR      R1,[R0, #+68]
   4335          
   4336              /* Clear OVR flag */
   4337              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \       0x28   0xF44F 0x6480      MOV      R4,#+1024
   \       0x2C   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0x30   0x6441             STR      R1,[R0, #+68]
   \       0x32   0x6805             LDR      R5,[R0, #+0]
   \       0x34   0x61EC             STR      R4,[R5, #+28]
   4338            }
   4339          
   4340            /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
   4341            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \       0x36   0x0591             LSLS     R1,R2,#+22
   \       0x38   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \       0x3A   0x061A             LSLS     R2,R3,#+24
   \       0x3C   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   4342            {
   4343              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \       0x3E   0x6C41             LDR      R1,[R0, #+68]
   4344          
   4345              /* Clear ARLO flag */
   4346              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \       0x40   0xF44F 0x7200      MOV      R2,#+512
   \       0x44   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x48   0x6441             STR      R1,[R0, #+68]
   \       0x4A   0x6803             LDR      R3,[R0, #+0]
   \       0x4C   0x61DA             STR      R2,[R3, #+28]
   4347            }
   4348          
   4349            /* Store current volatile hi2c->ErrorCode, misra rule */
   4350            tmperror = hi2c->ErrorCode;
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \       0x4E   0x6C41             LDR      R1,[R0, #+68]
   4351          
   4352            /* Call the Error Callback in case of Error detected */
   4353            if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
   \       0x50   0xF011 0x0F0B      TST      R1,#0xB
   \       0x54   0xD000             BEQ.N    ??HAL_I2C_ER_IRQHandler_3
   4354            {
   4355              I2C_ITError(hi2c, tmperror);
   \       0x56   0x....             B.N      ?Subroutine3
   4356            }
   4357          }
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \       0x58   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \        0x4   0x....             B.N      I2C_ITError
   4358          
   4359          /**
   4360            * @brief  Master Tx Transfer completed callback.
   4361            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4362            *                the configuration information for the specified I2C.
   4363            * @retval None
   4364            */

   \                                 In section .text, align 2
   4365          __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4366          {
   4367            /* Prevent unused argument(s) compilation warning */
   4368            UNUSED(hi2c);
   4369          
   4370            /* NOTE : This function should not be modified, when the callback is needed,
   4371                      the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   4372             */
   4373          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4374          
   4375          /**
   4376            * @brief  Master Rx Transfer completed callback.
   4377            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4378            *                the configuration information for the specified I2C.
   4379            * @retval None
   4380            */

   \                                 In section .text, align 2
   4381          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4382          {
   4383            /* Prevent unused argument(s) compilation warning */
   4384            UNUSED(hi2c);
   4385          
   4386            /* NOTE : This function should not be modified, when the callback is needed,
   4387                      the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   4388             */
   4389          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4390          
   4391          /** @brief  Slave Tx Transfer completed callback.
   4392            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4393            *                the configuration information for the specified I2C.
   4394            * @retval None
   4395            */

   \                                 In section .text, align 2
   4396          __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4397          {
   4398            /* Prevent unused argument(s) compilation warning */
   4399            UNUSED(hi2c);
   4400          
   4401            /* NOTE : This function should not be modified, when the callback is needed,
   4402                      the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   4403             */
   4404          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4405          
   4406          /**
   4407            * @brief  Slave Rx Transfer completed callback.
   4408            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4409            *                the configuration information for the specified I2C.
   4410            * @retval None
   4411            */

   \                                 In section .text, align 2
   4412          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4413          {
   4414            /* Prevent unused argument(s) compilation warning */
   4415            UNUSED(hi2c);
   4416          
   4417            /* NOTE : This function should not be modified, when the callback is needed,
   4418                      the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   4419             */
   4420          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4421          
   4422          /**
   4423            * @brief  Slave Address Match callback.
   4424            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4425            *                the configuration information for the specified I2C.
   4426            * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
   4427            * @param  AddrMatchCode Address Match Code
   4428            * @retval None
   4429            */

   \                                 In section .text, align 2
   4430          __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
   4431          {
   4432            /* Prevent unused argument(s) compilation warning */
   4433            UNUSED(hi2c);
   4434            UNUSED(TransferDirection);
   4435            UNUSED(AddrMatchCode);
   4436          
   4437            /* NOTE : This function should not be modified, when the callback is needed,
   4438                      the HAL_I2C_AddrCallback() could be implemented in the user file
   4439             */
   4440          }
   \                     HAL_I2C_AddrCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4441          
   4442          /**
   4443            * @brief  Listen Complete callback.
   4444            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4445            *                the configuration information for the specified I2C.
   4446            * @retval None
   4447            */

   \                                 In section .text, align 2
   4448          __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
   4449          {
   4450            /* Prevent unused argument(s) compilation warning */
   4451            UNUSED(hi2c);
   4452          
   4453            /* NOTE : This function should not be modified, when the callback is needed,
   4454                      the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   4455             */
   4456          }
   \                     HAL_I2C_ListenCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4457          
   4458          /**
   4459            * @brief  Memory Tx Transfer completed callback.
   4460            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4461            *                the configuration information for the specified I2C.
   4462            * @retval None
   4463            */

   \                                 In section .text, align 2
   4464          __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4465          {
   4466            /* Prevent unused argument(s) compilation warning */
   4467            UNUSED(hi2c);
   4468          
   4469            /* NOTE : This function should not be modified, when the callback is needed,
   4470                      the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   4471             */
   4472          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4473          
   4474          /**
   4475            * @brief  Memory Rx Transfer completed callback.
   4476            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4477            *                the configuration information for the specified I2C.
   4478            * @retval None
   4479            */

   \                                 In section .text, align 2
   4480          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4481          {
   4482            /* Prevent unused argument(s) compilation warning */
   4483            UNUSED(hi2c);
   4484          
   4485            /* NOTE : This function should not be modified, when the callback is needed,
   4486                      the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   4487             */
   4488          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4489          
   4490          /**
   4491            * @brief  I2C error callback.
   4492            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4493            *                the configuration information for the specified I2C.
   4494            * @retval None
   4495            */

   \                                 In section .text, align 2
   4496          __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   4497          {
   4498            /* Prevent unused argument(s) compilation warning */
   4499            UNUSED(hi2c);
   4500          
   4501            /* NOTE : This function should not be modified, when the callback is needed,
   4502                      the HAL_I2C_ErrorCallback could be implemented in the user file
   4503             */
   4504          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4505          
   4506          /**
   4507            * @brief  I2C abort callback.
   4508            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4509            *                the configuration information for the specified I2C.
   4510            * @retval None
   4511            */

   \                                 In section .text, align 2
   4512          __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
   4513          {
   4514            /* Prevent unused argument(s) compilation warning */
   4515            UNUSED(hi2c);
   4516          
   4517            /* NOTE : This function should not be modified, when the callback is needed,
   4518                      the HAL_I2C_AbortCpltCallback could be implemented in the user file
   4519             */
   4520          }
   \                     HAL_I2C_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4521          
   4522          /**
   4523            * @}
   4524            */
   4525          
   4526          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
   4527           *  @brief   Peripheral State, Mode and Error functions
   4528           *
   4529          @verbatim
   4530           ===============================================================================
   4531                      ##### Peripheral State, Mode and Error functions #####
   4532           ===============================================================================
   4533              [..]
   4534              This subsection permit to get in run-time the status of the peripheral
   4535              and the data flow.
   4536          
   4537          @endverbatim
   4538            * @{
   4539            */
   4540          
   4541          /**
   4542            * @brief  Return the I2C handle state.
   4543            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4544            *                the configuration information for the specified I2C.
   4545            * @retval HAL state
   4546            */

   \                                 In section .text, align 2, keep-with-next
   4547          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   4548          {
   4549            /* Return I2C handle state */
   4550            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \        0x0   0xF890 0x0041      LDRB     R0,[R0, #+65]
   \        0x4   0x4770             BX       LR               ;; return
   4551          }
   4552          
   4553          /**
   4554            * @brief  Returns the I2C Master, Slave, Memory or no mode.
   4555            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4556            *         the configuration information for I2C module
   4557            * @retval HAL mode
   4558            */

   \                                 In section .text, align 2, keep-with-next
   4559          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   4560          {
   4561            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \        0x0   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \        0x4   0x4770             BX       LR               ;; return
   4562          }
   4563          
   4564          /**
   4565          * @brief  Return the I2C error code.
   4566            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4567            *              the configuration information for the specified I2C.
   4568          * @retval I2C Error Code
   4569          */

   \                                 In section .text, align 2, keep-with-next
   4570          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   4571          {
   4572            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \        0x0   0x6C40             LDR      R0,[R0, #+68]
   \        0x2   0x4770             BX       LR               ;; return
   4573          }
   4574          
   4575          /**
   4576            * @}
   4577            */
   4578          
   4579          /**
   4580            * @}
   4581            */
   4582          
   4583          /** @addtogroup I2C_Private_Functions
   4584            * @{
   4585            */
   4586          
   4587          /**
   4588            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with Interrupt.
   4589            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4590            *                the configuration information for the specified I2C.
   4591            * @param  ITFlags Interrupt flags to handle.
   4592            * @param  ITSources Interrupt sources enabled.
   4593            * @retval HAL status
   4594            */

   \                                 In section .text, align 4, keep-with-next
   4595          static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4596          {
   \                     I2C_Master_ISR_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine84
   4597            uint16_t devaddress;
   4598            uint32_t tmpITFlags = ITFlags;
   4599          
   4600            /* Process Locked */
   4601            __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_192: (+1)
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??I2C_Master_ISR_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??I2C_Master_ISR_IT_0: (+1)
   \       0x14   0x2101             MOVS     R1,#+1
   4602          
   4603            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x16   0x06F0             LSLS     R0,R6,#+27
   \       0x18   0x7029             STRB     R1,[R5, #+0]
   \       0x1A   0xD50C             BPL.N    ??I2C_Master_ISR_IT_1
   \       0x1C   0x06FA             LSLS     R2,R7,#+27
   \       0x1E   0xD50A             BPL.N    ??I2C_Master_ISR_IT_1
   4604            {
   4605              /* Clear NACK Flag */
   4606              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x61C1             STR      R1,[R0, #+28]
   4607          
   4608              /* Set corresponding Error Code */
   4609              /* No need to generate STOP, it is automatically done */
   4610              /* Error callback will be send during stop flag treatment */
   4611              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x26   0x686A             LDR      R2,[R5, #+4]
   4612          
   4613              /* Flush TX register */
   4614              I2C_Flush_TXDR(hi2c);
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x2E   0x606A             STR      R2,[R5, #+4]
   \       0x30   0x.... 0x....      BL       I2C_Flush_TXDR
   \       0x34   0xE06C             B.N      ??I2C_Master_ISR_IT_2
   4615            }
   4616            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
   \                     ??I2C_Master_ISR_IT_1: (+1)
   \       0x36   0x0770             LSLS     R0,R6,#+29
   \       0x38   0xD511             BPL.N    ??I2C_Master_ISR_IT_3
   \       0x3A   0x0779             LSLS     R1,R7,#+29
   \       0x3C   0xD50F             BPL.N    ??I2C_Master_ISR_IT_3
   4617            {
   4618              /* Remove RXNE flag on temporary variable as read done */
   4619              tmpITFlags &= ~I2C_FLAG_RXNE;
   4620          
   4621              /* Read data from RXDR */
   4622              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0xF026 0x0604      BIC      R6,R6,#0x4
   \       0x44   0x6A42             LDR      R2,[R0, #+36]
   \       0x46   0x6A61             LDR      R1,[R4, #+36]
   \       0x48   0x700A             STRB     R2,[R1, #+0]
   4623          
   4624              /* Increment Buffer pointer */
   4625              hi2c->pBuffPtr++;
   4626          
   4627              hi2c->XferSize--;
   \       0x4A   0x8D21             LDRH     R1,[R4, #+40]
   \       0x4C   0x6A60             LDR      R0,[R4, #+36]
   \       0x4E   0x1C43             ADDS     R3,R0,#+1
   \       0x50   0x6263             STR      R3,[R4, #+36]
   \       0x52   0x1E4A             SUBS     R2,R1,#+1
   \       0x54   0x8522             STRH     R2,[R4, #+40]
   4628              hi2c->XferCount--;
   \       0x56   0x8D60             LDRH     R0,[R4, #+42]
   \       0x58   0x1E43             SUBS     R3,R0,#+1
   \       0x5A   0x8563             STRH     R3,[R4, #+42]
   \       0x5C   0xE058             B.N      ??I2C_Master_ISR_IT_2
   4629            }
   4630            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
   \                     ??I2C_Master_ISR_IT_3: (+1)
   \       0x5E   0x07B1             LSLS     R1,R6,#+30
   \       0x60   0xD50F             BPL.N    ??I2C_Master_ISR_IT_4
   \       0x62   0x07B8             LSLS     R0,R7,#+30
   \       0x64   0xD50D             BPL.N    ??I2C_Master_ISR_IT_4
   4631            {
   4632              /* Write data to TXDR */
   4633              hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0x66   0x6A61             LDR      R1,[R4, #+36]
   \       0x68   0x6823             LDR      R3,[R4, #+0]
   \       0x6A   0x780A             LDRB     R2,[R1, #+0]
   \       0x6C   0x629A             STR      R2,[R3, #+40]
   4634          
   4635              /* Increment Buffer pointer */
   4636              hi2c->pBuffPtr++;
   4637          
   4638              hi2c->XferSize--;
   \       0x6E   0x8D22             LDRH     R2,[R4, #+40]
   \       0x70   0x6A60             LDR      R0,[R4, #+36]
   \       0x72   0x1C41             ADDS     R1,R0,#+1
   \       0x74   0x6261             STR      R1,[R4, #+36]
   \       0x76   0x1E53             SUBS     R3,R2,#+1
   \       0x78   0x8523             STRH     R3,[R4, #+40]
   4639              hi2c->XferCount--;
   \       0x7A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x7C   0x1E41             SUBS     R1,R0,#+1
   \       0x7E   0x8561             STRH     R1,[R4, #+42]
   \       0x80   0xE046             B.N      ??I2C_Master_ISR_IT_2
   4640            }
   4641            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_IT_4: (+1)
   \       0x82   0x0630             LSLS     R0,R6,#+24
   \       0x84   0x.... 0x....      LDR.W    R3,??DataTable44  ;; 0xffff0000
   \       0x88   0xD52A             BPL.N    ??I2C_Master_ISR_IT_5
   \       0x8A   0x067A             LSLS     R2,R7,#+25
   \       0x8C   0xD528             BPL.N    ??I2C_Master_ISR_IT_5
   4642            {
   4643              if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \       0x8E   0x8D61             LDRH     R1,[R4, #+42]
   \       0x90   0xB309             CBZ.N    R1,??I2C_Master_ISR_IT_6
   \       0x92   0x8D20             LDRH     R0,[R4, #+40]
   \       0x94   0xB9F8             CBNZ.N   R0,??I2C_Master_ISR_IT_6
   4644              {
   4645                devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6849             LDR      R1,[R1, #+4]
   4646          
   4647                if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x9A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x9C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0xA0   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \       0xA4   0xD306             BCC.N    ??I2C_Master_ISR_IT_7
   4648                {
   4649                  hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0xA6   0x22FF             MOVS     R2,#+255
   4650                  I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0xA8   0x2300             MOVS     R3,#+0
   \       0xAA   0x8522             STRH     R2,[R4, #+40]
   \       0xAC   0x9300             STR      R3,[SP, #+0]
   \       0xAE   0xF04F 0x7380      MOV      R3,#+16777216
   \       0xB2   0xE00D             B.N      ??I2C_Master_ISR_IT_8
   4651                }
   4652                else
   4653                {
   4654                  hi2c->XferSize = hi2c->XferCount;
   \                     ??I2C_Master_ISR_IT_7: (+1)
   \       0xB4   0x8D62             LDRH     R2,[R4, #+42]
   \       0xB6   0x8522             STRH     R2,[R4, #+40]
   4655                  if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \       0xB8   0x6AE0             LDR      R0,[R4, #+44]
   \       0xBA   0x4298             CMP      R0,R3
   \       0xBC   0xD003             BEQ.N    ??I2C_Master_ISR_IT_9
   4656                  {
   4657                    I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
   \       0xBE   0x2300             MOVS     R3,#+0
   \       0xC0   0x9300             STR      R3,[SP, #+0]
   \       0xC2   0x6AE3             LDR      R3,[R4, #+44]
   \       0xC4   0xE003             B.N      ??I2C_Master_ISR_IT_10
   4658                  }
   4659                  else
   4660                  {
   4661                    I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_Master_ISR_IT_9: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xF04F 0x7300      MOV      R3,#+33554432
   \       0xCC   0x9000             STR      R0,[SP, #+0]
   \                     ??I2C_Master_ISR_IT_10: (+1)
   \       0xCE   0xB2D2             UXTB     R2,R2
   4662                  }
   4663                }
   4664              }
   \                     ??I2C_Master_ISR_IT_8: (+1)
   \       0xD0   0x.... 0x....      BL       ??Subroutine95_1
   \                     ??CrossCallReturnLabel_222: (+1)
   \       0xD4   0xE01C             B.N      ??I2C_Master_ISR_IT_2
   4665              else
   4666              {
   4667                /* Call TxCpltCallback() if no stop mode is set */
   4668                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \                     ??I2C_Master_ISR_IT_6: (+1)
   \       0xD6   0x6821             LDR      R1,[R4, #+0]
   \       0xD8   0x6848             LDR      R0,[R1, #+4]
   \       0xDA   0x0182             LSLS     R2,R0,#+6
   \       0xDC   0xD414             BMI.N    ??I2C_Master_ISR_IT_11
   4669                {
   4670                  /* Call I2C Master Sequential complete process */
   4671                  I2C_ITMasterSeqCplt(hi2c);
   \       0xDE   0xE00F             B.N      ??I2C_Master_ISR_IT_12
   4672                }
   4673                else
   4674                {
   4675                  /* Wrong size Status regarding TCR flag event */
   4676                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4677                  I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   4678                }
   4679              }
   4680            }
   4681            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_IT_5: (+1)
   \       0xE0   0x0670             LSLS     R0,R6,#+25
   \       0xE2   0xD515             BPL.N    ??I2C_Master_ISR_IT_2
   \       0xE4   0x0679             LSLS     R1,R7,#+25
   \       0xE6   0xD513             BPL.N    ??I2C_Master_ISR_IT_2
   4682            {
   4683              if (hi2c->XferCount == 0U)
   \       0xE8   0x8D60             LDRH     R0,[R4, #+42]
   \       0xEA   0xB968             CBNZ.N   R0,??I2C_Master_ISR_IT_11
   4684              {
   4685                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x6841             LDR      R1,[R0, #+4]
   \       0xF0   0x018A             LSLS     R2,R1,#+6
   \       0xF2   0xD40D             BMI.N    ??I2C_Master_ISR_IT_2
   4686                {
   4687                  /* Generate a stop condition in case of no transfer option */
   4688                  if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
   \       0xF4   0x6AE1             LDR      R1,[R4, #+44]
   \       0xF6   0x4299             CMP      R1,R3
   \       0xF8   0xD102             BNE.N    ??I2C_Master_ISR_IT_12
   4689                  {
   4690                    /* Generate Stop */
   4691                    hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \       0xFA   0x.... 0x....      BL       ?Subroutine40
   4692                  }
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0xFE   0xE007             B.N      ??I2C_Master_ISR_IT_2
   4693                  else
   4694                  {
   4695                    /* Call I2C Master Sequential complete process */
   4696                    I2C_ITMasterSeqCplt(hi2c);
   \                     ??I2C_Master_ISR_IT_12: (+1)
   \      0x100   0x4620             MOV      R0,R4
   \      0x102   0x.... 0x....      BL       I2C_ITMasterSeqCplt
   \      0x106   0xE003             B.N      ??I2C_Master_ISR_IT_2
   4697                  }
   4698                }
   4699              }
   4700              else
   4701              {
   4702                /* Wrong size Status regarding TC flag event */
   4703                /* Call the corresponding callback to inform upper layer of End of Transfer */
   4704                I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   \                     ??I2C_Master_ISR_IT_11: (+1)
   \      0x108   0x2140             MOVS     R1,#+64
   \      0x10A   0x4620             MOV      R0,R4
   \      0x10C   0x.... 0x....      BL       I2C_ITError
   4705              }
   4706            }
   4707            else
   4708            {
   4709              /* Nothing to do */
   4710            }
   4711          
   4712            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Master_ISR_IT_2: (+1)
   \      0x110   0x06B0             LSLS     R0,R6,#+26
   \      0x112   0xD505             BPL.N    ??I2C_Master_ISR_IT_13
   \      0x114   0x06B9             LSLS     R1,R7,#+26
   \      0x116   0xD503             BPL.N    ??I2C_Master_ISR_IT_13
   4713            {
   4714              /* Call I2C Master complete process */
   4715              I2C_ITMasterCplt(hi2c, tmpITFlags);
   \      0x118   0x4631             MOV      R1,R6
   \      0x11A   0x4620             MOV      R0,R4
   \      0x11C   0x.... 0x....      BL       I2C_ITMasterCplt
   4716            }
   4717          
   4718            /* Process Unlocked */
   4719            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Master_ISR_IT_13: (+1)
   \      0x120   0x....             B.N      ?Subroutine2
   4720          
   4721            return HAL_OK;
   4722          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7028             STRB     R0,[R5, #+0]
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4723          
   4724          /**
   4725            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with Interrupt.
   4726            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4727            *                the configuration information for the specified I2C.
   4728            * @param  ITFlags Interrupt flags to handle.
   4729            * @param  ITSources Interrupt sources enabled.
   4730            * @retval HAL status
   4731            */

   \                                 In section .text, align 4, keep-with-next
   4732          static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4733          {
   \                     I2C_Slave_ISR_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   4734            uint32_t tmpoptions = hi2c->XferOptions;
   \        0x6   0x6AE0             LDR      R0,[R4, #+44]
   4735            uint32_t tmpITFlags = ITFlags;
   4736          
   4737            /* Process locked */
   4738            __HAL_LOCK(hi2c);
   \        0x8   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xC   0x7829             LDRB     R1,[R5, #+0]
   \        0xE   0x4617             MOV      R7,R2
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD101             BNE.N    ??I2C_Slave_ISR_IT_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??I2C_Slave_ISR_IT_0: (+1)
   \       0x18   0x2201             MOVS     R2,#+1
   4739          
   4740            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x1A   0x06F1             LSLS     R1,R6,#+27
   \       0x1C   0x702A             STRB     R2,[R5, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R2,??DataTable44  ;; 0xffff0000
   \       0x22   0xD52F             BPL.N    ??I2C_Slave_ISR_IT_1
   \       0x24   0x06FB             LSLS     R3,R7,#+27
   \       0x26   0xD52D             BPL.N    ??I2C_Slave_ISR_IT_1
   4741            {
   4742              /* Check that I2C transfer finished */
   4743              /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
   4744              /* Mean XferCount == 0*/
   4745              /* So clear Flag NACKF only */
   4746              if (hi2c->XferCount == 0U)
   \       0x28   0x8D61             LDRH     R1,[R4, #+42]
   \       0x2A   0xB9D1             CBNZ.N   R1,??I2C_Slave_ISR_IT_2
   4747              {
   4748                if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
   \       0x2C   0x786B             LDRB     R3,[R5, #+1]
   \       0x2E   0x2B28             CMP      R3,#+40
   \       0x30   0xBF08             IT       EQ 
   \       0x32   0xF1B0 0x7F00      CMPEQ    R0,#+33554432
   \       0x36   0xD104             BNE.N    ??I2C_Slave_ISR_IT_3
   4749                {
   4750                  /* Call I2C Listen complete process */
   4751                  I2C_ITListenCplt(hi2c, tmpITFlags);
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x.... 0x....      BL       I2C_ITListenCplt
   \       0x40   0xE05F             B.N      ??I2C_Slave_ISR_IT_4
   4752                }
   4753                else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_IT_3: (+1)
   \       0x42   0x7869             LDRB     R1,[R5, #+1]
   \       0x44   0x2929             CMP      R1,#+41
   \       0x46   0xD108             BNE.N    ??I2C_Slave_ISR_IT_5
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD006             BEQ.N    ??I2C_Slave_ISR_IT_5
   4754                {
   4755                  /* Clear NACK Flag */
   4756                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x4C   0x6822             LDR      R2,[R4, #+0]
   \       0x4E   0x2010             MOVS     R0,#+16
   \       0x50   0x61D0             STR      R0,[R2, #+28]
   4757          
   4758                  /* Flush TX register */
   4759                  I2C_Flush_TXDR(hi2c);
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x.... 0x....      BL       I2C_Flush_TXDR
   4760          
   4761                  /* Last Byte is Transmitted */
   4762                  /* Call I2C Slave Sequential complete process */
   4763                  I2C_ITSlaveSeqCplt(hi2c);
   \       0x58   0xE050             B.N      ??I2C_Slave_ISR_IT_6
   4764                }
   4765                else
   4766                {
   4767                  /* Clear NACK Flag */
   4768                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_IT_5: (+1)
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x2010             MOVS     R0,#+16
   \       0x5E   0x61C8             STR      R0,[R1, #+28]
   \       0x60   0xE04F             B.N      ??I2C_Slave_ISR_IT_4
   4769                }
   4770              }
   4771              else
   4772              {
   4773                /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
   4774                /* Clear NACK Flag */
   4775                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_IT_2: (+1)
   \       0x62   0x6823             LDR      R3,[R4, #+0]
   \       0x64   0x2210             MOVS     R2,#+16
   4776          
   4777                /* Set ErrorCode corresponding to a Non-Acknowledge */
   4778                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   4779          
   4780                if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0x61DA             STR      R2,[R3, #+28]
   \       0x6A   0x6869             LDR      R1,[R5, #+4]
   \       0x6C   0xBF18             IT       NE 
   \       0x6E   0xF1B0 0x7F80      CMPNE    R0,#+16777216
   \       0x72   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x76   0x6069             STR      R1,[R5, #+4]
   \       0x78   0xD143             BNE.N    ??I2C_Slave_ISR_IT_4
   4781                {
   4782                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4783                  I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0x7A   0x6869             LDR      R1,[R5, #+4]
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0x.... 0x....      BL       I2C_ITError
   \       0x82   0xE03E             B.N      ??I2C_Slave_ISR_IT_4
   4784                }
   4785              }
   4786            }
   4787            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
   \                     ??I2C_Slave_ISR_IT_1: (+1)
   \       0x84   0x0771             LSLS     R1,R6,#+29
   \       0x86   0xD517             BPL.N    ??I2C_Slave_ISR_IT_7
   \       0x88   0x077B             LSLS     R3,R7,#+29
   \       0x8A   0xD515             BPL.N    ??I2C_Slave_ISR_IT_7
   4788            {
   4789              if (hi2c->XferCount > 0U)
   \       0x8C   0x8D61             LDRH     R1,[R4, #+42]
   \       0x8E   0xB171             CBZ.N    R1,??I2C_Slave_ISR_IT_8
   4790              {
   4791                /* Remove RXNE flag on temporary variable as read done */
   4792                tmpITFlags &= ~I2C_FLAG_RXNE;
   4793          
   4794                /* Read data from RXDR */
   4795                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x90   0x6823             LDR      R3,[R4, #+0]
   \       0x92   0xF026 0x0604      BIC      R6,R6,#0x4
   \       0x96   0x6A59             LDR      R1,[R3, #+36]
   \       0x98   0x6A63             LDR      R3,[R4, #+36]
   \       0x9A   0x7019             STRB     R1,[R3, #+0]
   4796          
   4797                /* Increment Buffer pointer */
   4798                hi2c->pBuffPtr++;
   \       0x9C   0x6A63             LDR      R3,[R4, #+36]
   \       0x9E   0x1C59             ADDS     R1,R3,#+1
   \       0xA0   0x6261             STR      R1,[R4, #+36]
   4799          
   4800                hi2c->XferSize--;
   \       0xA2   0x8D21             LDRH     R1,[R4, #+40]
   \       0xA4   0x1E49             SUBS     R1,R1,#+1
   \       0xA6   0x8521             STRH     R1,[R4, #+40]
   4801                hi2c->XferCount--;
   \       0xA8   0x8D63             LDRH     R3,[R4, #+42]
   \       0xAA   0x1E59             SUBS     R1,R3,#+1
   \       0xAC   0x8561             STRH     R1,[R4, #+42]
   4802              }
   4803          
   4804              if ((hi2c->XferCount == 0U) && \
   4805                  (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_IT_8: (+1)
   \       0xAE   0x8D61             LDRH     R1,[R4, #+42]
   \       0xB0   0xBB39             CBNZ.N   R1,??I2C_Slave_ISR_IT_4
   \       0xB2   0x4290             CMP      R0,R2
   \       0xB4   0xD025             BEQ.N    ??I2C_Slave_ISR_IT_4
   4806              {
   4807                /* Call I2C Slave Sequential complete process */
   4808                I2C_ITSlaveSeqCplt(hi2c);
   \       0xB6   0xE021             B.N      ??I2C_Slave_ISR_IT_6
   4809              }
   4810            }
   4811            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
   \                     ??I2C_Slave_ISR_IT_7: (+1)
   \       0xB8   0x0731             LSLS     R1,R6,#+28
   \       0xBA   0xD506             BPL.N    ??I2C_Slave_ISR_IT_9
   \       0xBC   0x073A             LSLS     R2,R7,#+28
   \       0xBE   0xD504             BPL.N    ??I2C_Slave_ISR_IT_9
   4812            {
   4813              I2C_ITAddrCplt(hi2c, tmpITFlags);
   \       0xC0   0x4631             MOV      R1,R6
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x.... 0x....      BL       I2C_ITAddrCplt
   \       0xC8   0xE01B             B.N      ??I2C_Slave_ISR_IT_4
   4814            }
   4815            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
   \                     ??I2C_Slave_ISR_IT_9: (+1)
   \       0xCA   0x07B1             LSLS     R1,R6,#+30
   \       0xCC   0xD519             BPL.N    ??I2C_Slave_ISR_IT_4
   \       0xCE   0x07BA             LSLS     R2,R7,#+30
   \       0xD0   0xD517             BPL.N    ??I2C_Slave_ISR_IT_4
   4816            {
   4817              /* Write data to TXDR only if XferCount not reach "0" */
   4818              /* A TXIS flag can be set, during STOP treatment      */
   4819              /* Check if all Datas have already been sent */
   4820              /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
   4821              if (hi2c->XferCount > 0U)
   \       0xD2   0x8D61             LDRH     R1,[R4, #+42]
   \       0xD4   0xB169             CBZ.N    R1,??I2C_Slave_ISR_IT_10
   4822              {
   4823                /* Write data to TXDR */
   4824                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0xD6   0x6A60             LDR      R0,[R4, #+36]
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x7802             LDRB     R2,[R0, #+0]
   \       0xDC   0x628A             STR      R2,[R1, #+40]
   4825          
   4826                /* Increment Buffer pointer */
   4827                hi2c->pBuffPtr++;
   \       0xDE   0x6A63             LDR      R3,[R4, #+36]
   \       0xE0   0x1C58             ADDS     R0,R3,#+1
   \       0xE2   0x6260             STR      R0,[R4, #+36]
   4828          
   4829                hi2c->XferCount--;
   \       0xE4   0x8D61             LDRH     R1,[R4, #+42]
   \       0xE6   0x1E4A             SUBS     R2,R1,#+1
   \       0xE8   0x8562             STRH     R2,[R4, #+42]
   4830                hi2c->XferSize--;
   \       0xEA   0x8D20             LDRH     R0,[R4, #+40]
   \       0xEC   0x1E43             SUBS     R3,R0,#+1
   \       0xEE   0x8523             STRH     R3,[R4, #+40]
   \       0xF0   0xE007             B.N      ??I2C_Slave_ISR_IT_4
   4831              }
   4832              else
   4833              {
   4834                if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
   \                     ??I2C_Slave_ISR_IT_10: (+1)
   \       0xF2   0xF1B0 0x7F80      CMP      R0,#+16777216
   \       0xF6   0xBF18             IT       NE 
   \       0xF8   0x2800             CMPNE    R0,#+0
   \       0xFA   0xD102             BNE.N    ??I2C_Slave_ISR_IT_4
   4835                {
   4836                  /* Last Byte is Transmitted */
   4837                  /* Call I2C Slave Sequential complete process */
   4838                  I2C_ITSlaveSeqCplt(hi2c);
   \                     ??I2C_Slave_ISR_IT_6: (+1)
   \       0xFC   0x4620             MOV      R0,R4
   \       0xFE   0x.... 0x....      BL       I2C_ITSlaveSeqCplt
   4839                }
   4840              }
   4841            }
   4842            else
   4843            {
   4844              /* Nothing to do */
   4845            }
   4846          
   4847            /* Check if STOPF is set */
   4848            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Slave_ISR_IT_4: (+1)
   \      0x102   0x06B0             LSLS     R0,R6,#+26
   \      0x104   0xD505             BPL.N    ??I2C_Slave_ISR_IT_11
   \      0x106   0x06B9             LSLS     R1,R7,#+26
   \      0x108   0xD503             BPL.N    ??I2C_Slave_ISR_IT_11
   4849            {
   4850              /* Call I2C Slave complete process */
   4851              I2C_ITSlaveCplt(hi2c, tmpITFlags);
   \      0x10A   0x4631             MOV      R1,R6
   \      0x10C   0x4620             MOV      R0,R4
   \      0x10E   0x.... 0x....      BL       I2C_ITSlaveCplt
   4852            }
   4853          
   4854            /* Process Unlocked */
   4855            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Slave_ISR_IT_11: (+1)
   \      0x112   0xBF00             Nop      
   \      0x114                      REQUIRE ?Subroutine2
   \      0x114                      ;; // Fall through to label ?Subroutine2
   4856          
   4857            return HAL_OK;
   4858          }
   4859          
   4860          /**
   4861            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with DMA.
   4862            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4863            *                the configuration information for the specified I2C.
   4864            * @param  ITFlags Interrupt flags to handle.
   4865            * @param  ITSources Interrupt sources enabled.
   4866            * @retval HAL status
   4867            */

   \                                 In section .text, align 4, keep-with-next
   4868          static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4869          {
   \                     I2C_Master_ISR_DMA: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   4870            uint16_t devaddress;
   4871            uint32_t xfermode;
   4872          
   4873            /* Process Locked */
   4874            __HAL_LOCK(hi2c);
   \        0x4   0xF105 0x0440      ADD      R4,R5,#+64
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??I2C_Master_ISR_DMA_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??I2C_Master_ISR_DMA_0: (+1)
   \       0x12   0x2301             MOVS     R3,#+1
   4875          
   4876            if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x14   0x06C8             LSLS     R0,R1,#+27
   \       0x16   0x7023             STRB     R3,[R4, #+0]
   \       0x18   0xD510             BPL.N    ??I2C_Master_ISR_DMA_1
   \       0x1A   0x06D6             LSLS     R6,R2,#+27
   \       0x1C   0xD50E             BPL.N    ??I2C_Master_ISR_DMA_1
   4877            {
   4878              /* Clear NACK Flag */
   4879              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x2110             MOVS     R1,#+16
   \       0x22   0x61C1             STR      R1,[R0, #+28]
   4880          
   4881              /* Set corresponding Error Code */
   4882              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x24   0x6862             LDR      R2,[R4, #+4]
   4883          
   4884              /* No need to generate STOP, it is automatically done */
   4885              /* But enable STOP interrupt, to treat it */
   4886              /* Error callback will be send during stop flag treatment */
   4887              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   \       0x26   0x2112             MOVS     R1,#+18
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x2E   0x6062             STR      R2,[R4, #+4]
   \       0x30   0x.... 0x....      BL       I2C_Enable_IRQ
   4888          
   4889              /* Flush TX register */
   4890              I2C_Flush_TXDR(hi2c);
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       I2C_Flush_TXDR
   \       0x3A   0xE05A             B.N      ??I2C_Master_ISR_DMA_2
   4891            }
   4892            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_DMA_1: (+1)
   \       0x3C   0x0608             LSLS     R0,R1,#+24
   \       0x3E   0x.... 0x....      LDR.W    R3,??DataTable44  ;; 0xffff0000
   \       0x42   0xD536             BPL.N    ??I2C_Master_ISR_DMA_3
   \       0x44   0x0656             LSLS     R6,R2,#+25
   \       0x46   0xD534             BPL.N    ??I2C_Master_ISR_DMA_3
   4893            {
   4894              /* Disable TC interrupt */
   4895              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF021 0x0140      BIC      R1,R1,#0x40
   \       0x50   0x6001             STR      R1,[R0, #+0]
   4896          
   4897              if (hi2c->XferCount != 0U)
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x8D68             LDRH     R0,[R5, #+42]
   \       0x56   0xB340             CBZ.N    R0,??I2C_Master_ISR_DMA_4
   4898              {
   4899                /* Recover Slave address */
   4900                devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
   \       0x58   0x6849             LDR      R1,[R1, #+4]
   4901          
   4902                /* Prepare the new XferSize to transfer */
   4903                if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x5A   0x8D68             LDRH     R0,[R5, #+42]
   \       0x5C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x60   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \       0x64   0xD304             BCC.N    ??I2C_Master_ISR_DMA_5
   4904                {
   4905                  hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x66   0x22FF             MOVS     R2,#+255
   4906                  xfermode = I2C_RELOAD_MODE;
   \       0x68   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x6C   0x852A             STRH     R2,[R5, #+40]
   \       0x6E   0xE007             B.N      ??I2C_Master_ISR_DMA_6
   4907                }
   4908                else
   4909                {
   4910                  hi2c->XferSize = hi2c->XferCount;
   \                     ??I2C_Master_ISR_DMA_5: (+1)
   \       0x70   0x8D68             LDRH     R0,[R5, #+42]
   \       0x72   0x8528             STRH     R0,[R5, #+40]
   4911                  if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \       0x74   0x6AEA             LDR      R2,[R5, #+44]
   \       0x76   0x429A             CMP      R2,R3
   \       0x78   0xBF14             ITE      NE 
   \       0x7A   0x6AEB             LDRNE    R3,[R5, #+44]
   \       0x7C   0xF04F 0x7300      MOVEQ    R3,#+33554432
   4912                  {
   4913                    xfermode = hi2c->XferOptions;
   4914                  }
   4915                  else
   4916                  {
   4917                    xfermode = I2C_AUTOEND_MODE;
   4918                  }
   4919                }
   4920          
   4921                /* Set the new XferSize in Nbytes register */
   4922                I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \                     ??I2C_Master_ISR_DMA_6: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0x8D2A             LDRH     R2,[R5, #+40]
   \       0x86   0x.... 0x....      BL       ??Subroutine97_0
   4923          
   4924                /* Update XferCount value */
   4925                hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_234: (+1)
   \       0x8A   0x8D69             LDRH     R1,[R5, #+42]
   \       0x8C   0x8D28             LDRH     R0,[R5, #+40]
   \       0x8E   0x1A09             SUBS     R1,R1,R0
   \       0x90   0x8569             STRH     R1,[R5, #+42]
   4926          
   4927                /* Enable DMA Request */
   4928                if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x7861             LDRB     R1,[R4, #+1]
   \       0x96   0x2922             CMP      R1,#+34
   \       0x98   0xD104             BNE.N    ??I2C_Master_ISR_DMA_7
   4929                {
   4930                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \       0x9A   0x6802             LDR      R2,[R0, #+0]
   \       0x9C   0xF442 0x4200      ORR      R2,R2,#0x8000
   \       0xA0   0x6002             STR      R2,[R0, #+0]
   \       0xA2   0xE026             B.N      ??I2C_Master_ISR_DMA_2
   4931                }
   4932                else
   4933                {
   4934                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_Master_ISR_DMA_7: (+1)
   \       0xA4   0x.... 0x....      BL       ?Subroutine34
   4935                }
   4936              }
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0xA8   0xE023             B.N      ??I2C_Master_ISR_DMA_2
   4937              else
   4938              {
   4939                /* Call TxCpltCallback() if no stop mode is set */
   4940                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \                     ??I2C_Master_ISR_DMA_4: (+1)
   \       0xAA   0x6848             LDR      R0,[R1, #+4]
   \       0xAC   0x0181             LSLS     R1,R0,#+6
   \       0xAE   0xD414             BMI.N    ??I2C_Master_ISR_DMA_8
   4941                {
   4942                  /* Call I2C Master Sequential complete process */
   4943                  I2C_ITMasterSeqCplt(hi2c);
   \       0xB0   0xE00F             B.N      ??I2C_Master_ISR_DMA_9
   4944                }
   4945                else
   4946                {
   4947                  /* Wrong size Status regarding TCR flag event */
   4948                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4949                  I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   4950                }
   4951              }
   4952            }
   4953            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_DMA_3: (+1)
   \       0xB2   0x0648             LSLS     R0,R1,#+25
   \       0xB4   0xD516             BPL.N    ??I2C_Master_ISR_DMA_10
   \       0xB6   0x0656             LSLS     R6,R2,#+25
   \       0xB8   0xD514             BPL.N    ??I2C_Master_ISR_DMA_10
   4954            {
   4955              if (hi2c->XferCount == 0U)
   \       0xBA   0x8D68             LDRH     R0,[R5, #+42]
   \       0xBC   0xB968             CBNZ.N   R0,??I2C_Master_ISR_DMA_8
   4956              {
   4957                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6841             LDR      R1,[R0, #+4]
   \       0xC2   0x018A             LSLS     R2,R1,#+6
   \       0xC4   0xD415             BMI.N    ??I2C_Master_ISR_DMA_2
   4958                {
   4959                  /* Generate a stop condition in case of no transfer option */
   4960                  if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
   \       0xC6   0x6AEE             LDR      R6,[R5, #+44]
   \       0xC8   0x429E             CMP      R6,R3
   \       0xCA   0xD102             BNE.N    ??I2C_Master_ISR_DMA_9
   4961                  {
   4962                    /* Generate Stop */
   4963                    hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \       0xCC   0x.... 0x....      BL       ?Subroutine40
   4964                  }
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0xD0   0xE00F             B.N      ??I2C_Master_ISR_DMA_2
   4965                  else
   4966                  {
   4967                    /* Call I2C Master Sequential complete process */
   4968                    I2C_ITMasterSeqCplt(hi2c);
   \                     ??I2C_Master_ISR_DMA_9: (+1)
   \       0xD2   0x4628             MOV      R0,R5
   \       0xD4   0x.... 0x....      BL       I2C_ITMasterSeqCplt
   \       0xD8   0xE00B             B.N      ??I2C_Master_ISR_DMA_2
   4969                  }
   4970                }
   4971              }
   4972              else
   4973              {
   4974                /* Wrong size Status regarding TC flag event */
   4975                /* Call the corresponding callback to inform upper layer of End of Transfer */
   4976                I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   \                     ??I2C_Master_ISR_DMA_8: (+1)
   \       0xDA   0x2140             MOVS     R1,#+64
   \       0xDC   0x4628             MOV      R0,R5
   \       0xDE   0x.... 0x....      BL       I2C_ITError
   \       0xE2   0xE006             B.N      ??I2C_Master_ISR_DMA_2
   4977              }
   4978            }
   4979            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Master_ISR_DMA_10: (+1)
   \       0xE4   0x0688             LSLS     R0,R1,#+26
   \       0xE6   0xD504             BPL.N    ??I2C_Master_ISR_DMA_2
   \       0xE8   0x0692             LSLS     R2,R2,#+26
   \       0xEA   0xBF44             ITT      MI 
   4980            {
   4981              /* Call I2C Master complete process */
   4982              I2C_ITMasterCplt(hi2c, ITFlags);
   \       0xEC   0x4628             MOVMI    R0,R5
   \       0xEE   0x.... 0x....      BLMI     I2C_ITMasterCplt
   4983            }
   4984            else
   4985            {
   4986              /* Nothing to do */
   4987            }
   4988          
   4989            /* Process Unlocked */
   4990            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Master_ISR_DMA_2: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0x7020             STRB     R0,[R4, #+0]
   4991          
   4992            return HAL_OK;
   \       0xF6   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4993          }
   4994          
   4995          /**
   4996            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with DMA.
   4997            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4998            *                the configuration information for the specified I2C.
   4999            * @param  ITFlags Interrupt flags to handle.
   5000            * @param  ITSources Interrupt sources enabled.
   5001            * @retval HAL status
   5002            */

   \                                 In section .text, align 4, keep-with-next
   5003          static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   5004          {
   \                     I2C_Slave_ISR_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   5005            uint32_t tmpoptions = hi2c->XferOptions;
   5006            uint32_t treatdmanack = 0U;
   5007          
   5008            /* Process locked */
   5009            __HAL_LOCK(hi2c);
   \        0x4   0xF105 0x0640      ADD      R6,R5,#+64
   \        0x8   0x6AE8             LDR      R0,[R5, #+44]
   \        0xA   0x7834             LDRB     R4,[R6, #+0]
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xD101             BNE.N    ??I2C_Slave_ISR_DMA_0
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??I2C_Slave_ISR_DMA_0: (+1)
   \       0x16   0x2701             MOVS     R7,#+1
   5010          
   5011            if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x18   0x06CC             LSLS     R4,R1,#+27
   \       0x1A   0x7037             STRB     R7,[R6, #+0]
   \       0x1C   0xD544             BPL.N    ??I2C_Slave_ISR_DMA_1
   \       0x1E   0x06D4             LSLS     R4,R2,#+27
   \       0x20   0xD542             BPL.N    ??I2C_Slave_ISR_DMA_1
   5012            {
   5013              /* Check that I2C transfer finished */
   5014              /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
   5015              /* Mean XferCount == 0 */
   5016              /* So clear Flag NACKF only */
   5017              if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
   5018                  (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
   \       0x22   0xF412 0x4F40      TST      R2,#0xC000
   \       0x26   0xD03B             BEQ.N    ??I2C_Slave_ISR_DMA_2
   5019              {
   5020                /* Split check of hdmarx, for MISRA compliance */
   5021                if (hi2c->hdmarx != NULL)
   \       0x28   0x6BEC             LDR      R4,[R5, #+60]
   \       0x2A   0xB12C             CBZ.N    R4,??I2C_Slave_ISR_DMA_3
   5022                {
   5023                  if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
   \       0x2C   0x0417             LSLS     R7,R2,#+16
   \       0x2E   0xD503             BPL.N    ??I2C_Slave_ISR_DMA_3
   5024                  {
   5025                    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
   \       0x30   0x6827             LDR      R7,[R4, #+0]
   \       0x32   0x687C             LDR      R4,[R7, #+4]
   \       0x34   0xB904             CBNZ.N   R4,??I2C_Slave_ISR_DMA_3
   5026                    {
   5027                      treatdmanack = 1U;
   \       0x36   0x2301             MOVS     R3,#+1
   5028                    }
   5029                  }
   5030                }
   5031          
   5032                /* Split check of hdmatx, for MISRA compliance  */
   5033                if (hi2c->hdmatx != NULL)
   \                     ??I2C_Slave_ISR_DMA_3: (+1)
   \       0x38   0x6BAC             LDR      R4,[R5, #+56]
   \       0x3A   0xB124             CBZ.N    R4,??I2C_Slave_ISR_DMA_4
   5034                {
   5035                  if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
   \       0x3C   0x0457             LSLS     R7,R2,#+17
   \       0x3E   0xD502             BPL.N    ??I2C_Slave_ISR_DMA_4
   5036                  {
   5037                    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
   \       0x40   0x6824             LDR      R4,[R4, #+0]
   \       0x42   0x6862             LDR      R2,[R4, #+4]
   \       0x44   0xB102             CBZ.N    R2,??I2C_Slave_ISR_DMA_5
   5038                    {
   5039                      treatdmanack = 1U;
   5040                    }
   5041                  }
   5042                }
   5043          
   5044                if (treatdmanack == 1U)
   \                     ??I2C_Slave_ISR_DMA_4: (+1)
   \       0x46   0xB1D3             CBZ.N    R3,??I2C_Slave_ISR_DMA_6
   5045                {
   5046                  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
   \                     ??I2C_Slave_ISR_DMA_5: (+1)
   \       0x48   0x7872             LDRB     R2,[R6, #+1]
   \       0x4A   0x2A28             CMP      R2,#+40
   \       0x4C   0xBF08             IT       EQ 
   \       0x4E   0xF1B0 0x7F00      CMPEQ    R0,#+33554432
   \       0x52   0xD103             BNE.N    ??I2C_Slave_ISR_DMA_7
   5047                  {
   5048                    /* Call I2C Listen complete process */
   5049                    I2C_ITListenCplt(hi2c, ITFlags);
   \       0x54   0x4628             MOV      R0,R5
   \       0x56   0x.... 0x....      BL       I2C_ITListenCplt
   \       0x5A   0xE034             B.N      ??I2C_Slave_ISR_DMA_8
   5050                  }
   5051                  else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_DMA_7: (+1)
   \       0x5C   0x7871             LDRB     R1,[R6, #+1]
   \       0x5E   0x2929             CMP      R1,#+41
   \       0x60   0xD11E             BNE.N    ??I2C_Slave_ISR_DMA_2
   \       0x62   0x.... 0x....      LDR.W    R2,??DataTable44  ;; 0xffff0000
   \       0x66   0x4290             CMP      R0,R2
   \       0x68   0xD01A             BEQ.N    ??I2C_Slave_ISR_DMA_2
   5052                  {
   5053                    /* Clear NACK Flag */
   5054                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x6A   0x6829             LDR      R1,[R5, #+0]
   \       0x6C   0x2010             MOVS     R0,#+16
   \       0x6E   0x61C8             STR      R0,[R1, #+28]
   5055          
   5056                    /* Flush TX register */
   5057                    I2C_Flush_TXDR(hi2c);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x.... 0x....      BL       I2C_Flush_TXDR
   5058          
   5059                    /* Last Byte is Transmitted */
   5060                    /* Call I2C Slave Sequential complete process */
   5061                    I2C_ITSlaveSeqCplt(hi2c);
   \       0x76   0x4628             MOV      R0,R5
   \       0x78   0x.... 0x....      BL       I2C_ITSlaveSeqCplt
   \       0x7C   0xE023             B.N      ??I2C_Slave_ISR_DMA_8
   5062                  }
   5063                  else
   5064                  {
   5065                    /* Clear NACK Flag */
   5066                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   5067                  }
   5068                }
   5069                else
   5070                {
   5071                  /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
   5072                  /* Clear NACK Flag */
   5073                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_DMA_6: (+1)
   \       0x7E   0x682A             LDR      R2,[R5, #+0]
   \       0x80   0x2110             MOVS     R1,#+16
   5074          
   5075                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   5076                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5077          
   5078                  if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0x61D1             STR      R1,[R2, #+28]
   \       0x86   0x6873             LDR      R3,[R6, #+4]
   \       0x88   0xBF18             IT       NE 
   \       0x8A   0xF1B0 0x7F80      CMPNE    R0,#+16777216
   \       0x8E   0xF043 0x0304      ORR      R3,R3,#0x4
   \       0x92   0x6073             STR      R3,[R6, #+4]
   \       0x94   0xD117             BNE.N    ??I2C_Slave_ISR_DMA_8
   5079                  {
   5080                    /* Call the corresponding callback to inform upper layer of End of Transfer */
   5081                    I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0x96   0x6871             LDR      R1,[R6, #+4]
   \       0x98   0x4628             MOV      R0,R5
   \       0x9A   0x.... 0x....      BL       I2C_ITError
   \       0x9E   0xE012             B.N      ??I2C_Slave_ISR_DMA_8
   5082                  }
   5083                }
   5084              }
   5085              else
   5086              {
   5087                /* Only Clear NACK Flag, no DMA treatment is pending */
   5088                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_DMA_2: (+1)
   \       0xA0   0x6829             LDR      R1,[R5, #+0]
   \       0xA2   0x2010             MOVS     R0,#+16
   \       0xA4   0x61C8             STR      R0,[R1, #+28]
   \       0xA6   0xE00E             B.N      ??I2C_Slave_ISR_DMA_8
   5089              }
   5090            }
   5091            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
   \                     ??I2C_Slave_ISR_DMA_1: (+1)
   \       0xA8   0x070B             LSLS     R3,R1,#+28
   \       0xAA   0xD505             BPL.N    ??I2C_Slave_ISR_DMA_9
   \       0xAC   0x0710             LSLS     R0,R2,#+28
   \       0xAE   0xD503             BPL.N    ??I2C_Slave_ISR_DMA_9
   5092            {
   5093              I2C_ITAddrCplt(hi2c, ITFlags);
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0x.... 0x....      BL       I2C_ITAddrCplt
   \       0xB6   0xE006             B.N      ??I2C_Slave_ISR_DMA_8
   5094            }
   5095            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Slave_ISR_DMA_9: (+1)
   \       0xB8   0x068B             LSLS     R3,R1,#+26
   \       0xBA   0xD504             BPL.N    ??I2C_Slave_ISR_DMA_8
   \       0xBC   0x0690             LSLS     R0,R2,#+26
   \       0xBE   0xBF44             ITT      MI 
   5096            {
   5097              /* Call I2C Slave complete process */
   5098              I2C_ITSlaveCplt(hi2c, ITFlags);
   \       0xC0   0x4628             MOVMI    R0,R5
   \       0xC2   0x.... 0x....      BLMI     I2C_ITSlaveCplt
   5099            }
   5100            else
   5101            {
   5102              /* Nothing to do */
   5103            }
   5104          
   5105            /* Process Unlocked */
   5106            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Slave_ISR_DMA_8: (+1)
   \       0xC6   0x2100             MOVS     R1,#+0
   5107          
   5108            return HAL_OK;
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x7031             STRB     R1,[R6, #+0]
   \       0xCC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   5109          }
   5110          
   5111          /**
   5112            * @brief  Master sends target device address followed by internal memory address for write request.
   5113            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5114            *                the configuration information for the specified I2C.
   5115            * @param  DevAddress Target device address: The device 7 bits address value
   5116            *         in datasheet must be shifted to the left before calling the interface
   5117            * @param  MemAddress Internal memory address
   5118            * @param  MemAddSize Size of internal memory address
   5119            * @param  Timeout Timeout duration
   5120            * @param  Tickstart Tick start value
   5121            * @retval HAL status
   5122            */

   \                                 In section .text, align 2, keep-with-next
   5123          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   5124          {
   \                     I2C_RequestMemoryWrite: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine91
   5125            I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_214: (+1)
   \        0x8   0xF04F 0x7380      MOV      R3,#+16777216
   \        0xC   0xB2EA             UXTB     R2,R5
   \        0xE   0x.... 0x....      BL       I2C_TransferConfig
   5126          
   5127            /* Wait until TXIS flag is set */
   5128            if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x12   0x4632             MOV      R2,R6
   \       0x14   0x.... 0x....      BL       ??Subroutine98_0
   \                     ??CrossCallReturnLabel_238: (+1)
   \       0x18   0xB960             CBNZ.N   R0,??I2C_RequestMemoryWrite_0
   5129            {
   5130              return HAL_ERROR;
   5131            }
   5132          
   5133            /* If Memory address size is 8Bit */
   5134            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x1A   0x2D01             CMP      R5,#+1
   \       0x1C   0xD002             BEQ.N    ??I2C_RequestMemoryWrite_1
   5135            {
   5136              /* Send Memory Address */
   5137              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   5138            }
   5139            /* If Memory address size is 16Bit */
   5140            else
   5141            {
   5142              /* Send MSB of Memory Address */
   5143              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x1E   0x.... 0x....      BL       ?Subroutine27
   5144          
   5145              /* Wait until TXIS flag is set */
   5146              if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_240: (+1)
   \       0x22   0xB938             CBNZ.N   R0,??I2C_RequestMemoryWrite_0
   5147              {
   5148                return HAL_ERROR;
   5149              }
   5150          
   5151              /* Send LSB of Memory Address */
   5152              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xB2FF             UXTB     R7,R7
   5153            }
   5154          
   5155            /* Wait until TCR flag is set */
   5156            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x28   0x4643             MOV      R3,R8
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2180             MOVS     R1,#+128
   \       0x2E   0x.... 0x....      BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_140: (+1)
   \       0x32   0xB100             CBZ.N    R0,??I2C_RequestMemoryWrite_2
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   5157            {
   5158              return HAL_ERROR;
   5159            }
   5160          
   5161            return HAL_OK;
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \       0x36   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   5162          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine91: (+1)
   \        0x0   0x4617             MOV      R7,R2
   \        0x2   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \        0x6   0x9E09             LDR      R6,[SP, #+36]
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable44_1  ;; 0x80002000
   \        0xC   0x461D             MOV      R5,R3
   \        0xE   0x9200             STR      R2,[SP, #+0]
   \       0x10   0x4604             MOV      R4,R0
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine61: (+1)
   \        0x0   0x6287             STR      R7,[R0, #+40]
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x9600             STR      R6,[SP, #+0]
   \        0x6   0x....             B.N      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0x6821             LDR      R1,[R4, #+0]
   \        0x2   0x0A38             LSRS     R0,R7,#+8
   \        0x4   0x4632             MOV      R2,R6
   \        0x6   0x6288             STR      R0,[R1, #+40]
   \        0x8                      REQUIRE ??Subroutine98_0
   \        0x8                      ;; // Fall through to label ??Subroutine98_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine98_0: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      I2C_WaitOnTXISFlagUntilTimeout
   5163          
   5164          /**
   5165            * @brief  Master sends target device address followed by internal memory address for read request.
   5166            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5167            *                the configuration information for the specified I2C.
   5168            * @param  DevAddress Target device address: The device 7 bits address value
   5169            *         in datasheet must be shifted to the left before calling the interface
   5170            * @param  MemAddress Internal memory address
   5171            * @param  MemAddSize Size of internal memory address
   5172            * @param  Timeout Timeout duration
   5173            * @param  Tickstart Tick start value
   5174            * @retval HAL status
   5175            */

   \                                 In section .text, align 2, keep-with-next
   5176          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   5177          {
   \                     I2C_RequestMemoryRead: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine91
   5178            I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_215: (+1)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xB2EA             UXTB     R2,R5
   \        0xC   0x.... 0x....      BL       I2C_TransferConfig
   5179          
   5180            /* Wait until TXIS flag is set */
   5181            if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x4632             MOV      R2,R6
   \       0x12   0x.... 0x....      BL       ??Subroutine98_0
   \                     ??CrossCallReturnLabel_237: (+1)
   \       0x16   0xB960             CBNZ.N   R0,??I2C_RequestMemoryRead_0
   5182            {
   5183              return HAL_ERROR;
   5184            }
   5185          
   5186            /* If Memory address size is 8Bit */
   5187            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x18   0x2D01             CMP      R5,#+1
   \       0x1A   0xD002             BEQ.N    ??I2C_RequestMemoryRead_1
   5188            {
   5189              /* Send Memory Address */
   5190              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   5191            }
   5192            /* If Memory address size is 16Bit */
   5193            else
   5194            {
   5195              /* Send MSB of Memory Address */
   5196              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x1C   0x.... 0x....      BL       ?Subroutine27
   5197          
   5198              /* Wait until TXIS flag is set */
   5199              if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_239: (+1)
   \       0x20   0xB938             CBNZ.N   R0,??I2C_RequestMemoryRead_0
   5200              {
   5201                return HAL_ERROR;
   5202              }
   5203          
   5204              /* Send LSB of Memory Address */
   5205              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0xB2FF             UXTB     R7,R7
   5206            }
   5207          
   5208            /* Wait until TC flag is set */
   5209            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x26   0x4643             MOV      R3,R8
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2140             MOVS     R1,#+64
   \       0x2C   0x.... 0x....      BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_139: (+1)
   \       0x30   0xB100             CBZ.N    R0,??I2C_RequestMemoryRead_2
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   5210            {
   5211              return HAL_ERROR;
   5212            }
   5213          
   5214            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \       0x34   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   5215          }
   5216          
   5217          /**
   5218            * @brief  I2C Address complete process callback.
   5219            * @param  hi2c I2C handle.
   5220            * @param  ITFlags Interrupt flags to handle.
   5221            * @retval None
   5222            */

   \                                 In section .text, align 2, keep-with-next
   5223          static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5224          {
   \                     I2C_ITAddrCplt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine84
   5225            uint8_t transferdirection;
   5226            uint16_t slaveaddrcode;
   5227            uint16_t ownadd1code;
   5228            uint16_t ownadd2code;
   5229          
   5230            /* Prevent unused argument(s) compilation warning */
   5231            UNUSED(ITFlags);
   5232          
   5233            /* In case of Listen state, need to inform upper layer of address match code event */
   5234            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_193: (+1)
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0xF001 0x0128      AND      R1,R1,#0x28
   \       0x10   0x2928             CMP      R1,#+40
   \       0x12   0xD133             BNE.N    ??I2C_ITAddrCplt_0
   5235            {
   5236              transferdirection = I2C_GET_DIR(hi2c);
   \       0x14   0x6986             LDR      R6,[R0, #+24]
   5237              slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
   \       0x16   0x6981             LDR      R1,[R0, #+24]
   5238              ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
   \       0x18   0x6882             LDR      R2,[R0, #+8]
   5239              ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
   \       0x1A   0x68C7             LDR      R7,[R0, #+12]
   \       0x1C   0x0C09             LSRS     R1,R1,#+16
   \       0x1E   0xF001 0x08FE      AND      R8,R1,#0xFE
   5240          
   5241              /* If 10bits addressing mode is selected */
   5242              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x22   0x68E1             LDR      R1,[R4, #+12]
   \       0x24   0x0C36             LSRS     R6,R6,#+16
   \       0x26   0xF006 0x0601      AND      R6,R6,#0x1
   \       0x2A   0xF3C2 0x0209      UBFX     R2,R2,#+0,#+10
   \       0x2E   0xF007 0x07FE      AND      R7,R7,#0xFE
   \       0x32   0x2902             CMP      R1,#+2
   \       0x34   0xD117             BNE.N    ??I2C_ITAddrCplt_1
   5243              {
   5244                if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
   \       0x36   0x09D3             LSRS     R3,R2,#+7
   \       0x38   0xF008 0x0106      AND      R1,R8,#0x6
   \       0x3C   0xF003 0x0306      AND      R3,R3,#0x6
   \       0x40   0x4299             CMP      R1,R3
   \       0x42   0xD10B             BNE.N    ??I2C_ITAddrCplt_2
   5245                {
   5246                  slaveaddrcode = ownadd1code;
   5247                  hi2c->AddrEventCount++;
   \       0x44   0x68A9             LDR      R1,[R5, #+8]
   \       0x46   0x1C49             ADDS     R1,R1,#+1
   \       0x48   0x60A9             STR      R1,[R5, #+8]
   5248                  if (hi2c->AddrEventCount == 2U)
   \       0x4A   0x68AB             LDR      R3,[R5, #+8]
   \       0x4C   0x2B02             CMP      R3,#+2
   \       0x4E   0xD119             BNE.N    ??I2C_ITAddrCplt_3
   5249                  {
   5250                    /* Reset Address Event counter */
   5251                    hi2c->AddrEventCount = 0U;
   \       0x50   0x2700             MOVS     R7,#+0
   5252          
   5253                    /* Clear ADDR flag */
   5254                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x52   0x2108             MOVS     R1,#+8
   \       0x54   0x60AF             STR      R7,[R5, #+8]
   \       0x56   0x61C1             STR      R1,[R0, #+28]
   5255          
   5256                    /* Process Unlocked */
   5257                    __HAL_UNLOCK(hi2c);
   \       0x58   0x702F             STRB     R7,[R5, #+0]
   5258          
   5259                    /* Call Slave Addr callback */
   5260          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5261                    hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5262          #else
   5263                    HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x5A   0xE009             B.N      ??I2C_ITAddrCplt_4
   5264          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5265                  }
   5266                }
   5267                else
   5268                {
   5269                  slaveaddrcode = ownadd2code;
   5270          
   5271                  /* Disable ADDR Interrupts */
   5272                  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \                     ??I2C_ITAddrCplt_2: (+1)
   \       0x5C   0x.... 0x....      BL       ?Subroutine20
   5273          
   5274                  /* Process Unlocked */
   5275                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   5276          
   5277                  /* Call Slave Addr callback */
   5278          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5279                  hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5280          #else
   5281                  HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x62   0x463A             MOV      R2,R7
   \       0x64   0xE003             B.N      ??I2C_ITAddrCplt_5
   5282          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5283                }
   5284              }
   5285              /* else 7 bits addressing mode is selected */
   5286              else
   5287              {
   5288                /* Disable ADDR Interrupts */
   5289                I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \                     ??I2C_ITAddrCplt_1: (+1)
   \       0x66   0x.... 0x....      BL       ?Subroutine20
   5290          
   5291                /* Process Unlocked */
   5292                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   5293          
   5294                /* Call Slave Addr callback */
   5295          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5296                hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5297          #else
   5298                HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x6C   0x4642             MOV      R2,R8
   \                     ??I2C_ITAddrCplt_5: (+1)
   \       0x6E   0x7028             STRB     R0,[R5, #+0]
   \                     ??I2C_ITAddrCplt_4: (+1)
   \       0x70   0x4631             MOV      R1,R6
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x78   0x.... 0x....      B.W      HAL_I2C_AddrCallback
   5299          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5300              }
   5301            }
   5302            /* Else clear address flag only */
   5303            else
   5304            {
   5305              /* Clear ADDR flag */
   5306              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??I2C_ITAddrCplt_0: (+1)
   \       0x7C   0x2108             MOVS     R1,#+8
   5307          
   5308              /* Process Unlocked */
   5309              __HAL_UNLOCK(hi2c);
   \       0x7E   0x2200             MOVS     R2,#+0
   \       0x80   0x61C1             STR      R1,[R0, #+28]
   \       0x82   0x702A             STRB     R2,[R5, #+0]
   5310            }
   5311          }
   \                     ??I2C_ITAddrCplt_3: (+1)
   \       0x84   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   5312          
   5313          /**
   5314            * @brief  I2C Master sequential complete process.
   5315            * @param  hi2c I2C handle.
   5316            * @retval None
   5317            */

   \                                 In section .text, align 2, keep-with-next
   5318          static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
   5319          {
   \                     I2C_ITMasterSeqCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine84
   5320            /* Reset I2C handle mode */
   5321            hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??CrossCallReturnLabel_194: (+1)
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x70A8             STRB     R0,[R5, #+2]
   5322          
   5323            /* No Generate Stop, to permit restart mode */
   5324            /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
   5325            if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0x2921             CMP      R1,#+33
   \        0xE   0xD10C             BNE.N    ??I2C_ITMasterSeqCplt_0
   5326            {
   5327              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x10   0x2020             MOVS     R0,#+32
   5328              hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \       0x12   0x2211             MOVS     R2,#+17
   \       0x14   0x7068             STRB     R0,[R5, #+1]
   5329              hi2c->XferISR       = NULL;
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0x6322             STR      R2,[R4, #+48]
   5330          
   5331              /* Disable Interrupts */
   5332              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x6363             STR      R3,[R4, #+52]
   \       0x1E   0x.... 0x....      BL       ??Subroutine20_0
   5333          
   5334              /* Process Unlocked */
   5335              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x22   0x2200             MOVS     R2,#+0
   5336          
   5337              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5338          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5339              hi2c->MasterTxCpltCallback(hi2c);
   5340          #else
   5341              HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x702A             STRB     R2,[R5, #+0]
   \       0x28   0x....             B.N      ?Subroutine5
   5342          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5343            }
   5344            /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
   5345            else
   5346            {
   5347              hi2c->State         = HAL_I2C_STATE_READY;
   \                     ??I2C_ITMasterSeqCplt_0: (+1)
   \       0x2A   0x2020             MOVS     R0,#+32
   5348              hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \       0x2C   0x2112             MOVS     R1,#+18
   \       0x2E   0x7068             STRB     R0,[R5, #+1]
   5349              hi2c->XferISR       = NULL;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x6321             STR      R1,[R4, #+48]
   5350          
   5351              /* Disable Interrupts */
   5352              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x34   0x2102             MOVS     R1,#+2
   \       0x36   0x6362             STR      R2,[R4, #+52]
   \       0x38   0x.... 0x....      BL       ??Subroutine20_0
   5353          
   5354              /* Process Unlocked */
   5355              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E                      REQUIRE ?Subroutine4
   \       0x3E                      ;; // Fall through to label ?Subroutine4
   5356          
   5357              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5358          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5359              hi2c->MasterRxCpltCallback(hi2c);
   5360          #else
   5361              HAL_I2C_MasterRxCpltCallback(hi2c);
   5362          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5363            }
   5364          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x7028             STRB     R0,[R5, #+0]
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0x8   0x.... 0x....      B.W      HAL_I2C_MasterRxCpltCallback

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0x4   0x.... 0x....      B.W      HAL_I2C_MasterTxCpltCallback
   5365          
   5366          /**
   5367            * @brief  I2C Slave sequential complete process.
   5368            * @param  hi2c I2C handle.
   5369            * @retval None
   5370            */

   \                                 In section .text, align 2, keep-with-next
   5371          static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
   5372          {
   \                     I2C_ITSlaveSeqCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5373            /* Reset I2C handle mode */
   5374            hi2c->Mode = HAL_I2C_MODE_NONE;
   \        0x4   0xF104 0x0530      ADD      R5,R4,#+48
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x74A8             STRB     R0,[R5, #+18]
   5375          
   5376            if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \        0xC   0x7C69             LDRB     R1,[R5, #+17]
   \        0xE   0x2929             CMP      R1,#+41
   \       0x10   0xD10D             BNE.N    ??I2C_ITSlaveSeqCplt_0
   5377            {
   5378              /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
   5379              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \       0x12   0x2228             MOVS     R2,#+40
   5380              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x14   0x2321             MOVS     R3,#+33
   \       0x16   0x746A             STRB     R2,[R5, #+17]
   5381          
   5382              /* Disable Interrupts */
   5383              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x602B             STR      R3,[R5, #+0]
   \       0x1C   0x.... 0x....      BL       ??Subroutine20_0
   5384          
   5385              /* Process Unlocked */
   5386              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   5387          
   5388              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5389          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5390              hi2c->SlaveTxCpltCallback(hi2c);
   5391          #else
   5392              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x742A             STRB     R2,[R5, #+16]
   \       0x26   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x2A   0x.... 0x....      B.W      HAL_I2C_SlaveTxCpltCallback
   5393          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5394            }
   5395          
   5396            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??I2C_ITSlaveSeqCplt_0: (+1)
   \       0x2E   0x7C68             LDRB     R0,[R5, #+17]
   \       0x30   0x282A             CMP      R0,#+42
   \       0x32   0xD10D             BNE.N    ??I2C_ITSlaveSeqCplt_1
   5397            {
   5398              /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */
   5399              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \       0x34   0x2128             MOVS     R1,#+40
   5400              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \       0x36   0x2222             MOVS     R2,#+34
   \       0x38   0x7469             STRB     R1,[R5, #+17]
   5401          
   5402              /* Disable Interrupts */
   5403              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x3A   0x2102             MOVS     R1,#+2
   \       0x3C   0x602A             STR      R2,[R5, #+0]
   \       0x3E   0x.... 0x....      BL       ??Subroutine20_0
   5404          
   5405              /* Process Unlocked */
   5406              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x7428             STRB     R0,[R5, #+16]
   5407          
   5408              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5409          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5410              hi2c->SlaveRxCpltCallback(hi2c);
   5411          #else
   5412              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x4C   0x.... 0x....      B.W      HAL_I2C_SlaveRxCpltCallback
   5413          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5414            }
   5415            else
   5416            {
   5417              /* Nothing to do */
   5418            }
   5419          }
   \                     ??I2C_ITSlaveSeqCplt_1: (+1)
   \       0x50   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5420          
   5421          /**
   5422            * @brief  I2C Master complete process.
   5423            * @param  hi2c I2C handle.
   5424            * @param  ITFlags Interrupt flags to handle.
   5425            * @retval None
   5426            */

   \                                 In section .text, align 2, keep-with-next
   5427          static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5428          {
   \                     I2C_ITMasterCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5429            uint32_t tmperror;
   5430          
   5431            /* Clear STOP Flag */
   5432            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x6822             LDR      R2,[R4, #+0]
   5433          
   5434            /* Clear Configuration Register 2 */
   5435            I2C_RESET_CR2(hi2c);
   5436          
   5437            /* Reset handle parameters */
   5438            hi2c->PreviousState = I2C_STATE_NONE;
   5439            hi2c->XferISR       = NULL;
   5440            hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   5441          
   5442            if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET)
   \        0x8   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xC   0x61D0             STR      R0,[R2, #+28]
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0xfe00e800
   \       0x14   0x6853             LDR      R3,[R2, #+4]
   \       0x16   0x4003             ANDS     R3,R0,R3
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0xffff0000
   \       0x1C   0x6053             STR      R3,[R2, #+4]
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x6322             STR      R2,[R4, #+48]
   \       0x22   0x06C9             LSLS     R1,R1,#+27
   \       0x24   0x6362             STR      R2,[R4, #+52]
   \       0x26   0x62E0             STR      R0,[R4, #+44]
   \       0x28   0xD506             BPL.N    ??I2C_ITMasterCplt_0
   5443            {
   5444              /* Clear NACK Flag */
   5445              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x2A   0x6822             LDR      R2,[R4, #+0]
   \       0x2C   0x2010             MOVS     R0,#+16
   \       0x2E   0x61D0             STR      R0,[R2, #+28]
   5446          
   5447              /* Set acknowledge error code */
   5448              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x30   0x6869             LDR      R1,[R5, #+4]
   \       0x32   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x36   0x6069             STR      R1,[R5, #+4]
   5449            }
   5450          
   5451            /* Flush TX register */
   5452            I2C_Flush_TXDR(hi2c);
   \                     ??I2C_ITMasterCplt_0: (+1)
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       I2C_Flush_TXDR
   5453          
   5454            /* Disable Interrupts */
   5455            I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_RX_IT);
   \       0x3E   0x2103             MOVS     R1,#+3
   \       0x40   0x.... 0x....      BL       ??Subroutine20_0
   5456          
   5457            /* Store current volatile hi2c->ErrorCode, misra rule */
   5458            tmperror = hi2c->ErrorCode;
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x44   0x6868             LDR      R0,[R5, #+4]
   \       0x46   0x7869             LDRB     R1,[R5, #+1]
   \       0x48   0x2960             CMP      R1,#+96
   \       0x4A   0xD000             BEQ.N    ??I2C_ITMasterCplt_1
   \       0x4C   0xB110             CBZ.N    R0,??I2C_ITMasterCplt_2
   5459          
   5460            /* Call the corresponding callback to inform upper layer of End of Transfer */
   5461            if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
   5462            {
   5463              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5464              I2C_ITError(hi2c, hi2c->ErrorCode);
   \                     ??I2C_ITMasterCplt_1: (+1)
   \       0x4E   0x6869             LDR      R1,[R5, #+4]
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x....             B.N      ?Subroutine3
   5465            }
   5466            /* hi2c->State == HAL_I2C_STATE_BUSY_TX */
   5467            else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_ITMasterCplt_2: (+1)
   \       0x54   0x7868             LDRB     R0,[R5, #+1]
   \       0x56   0x2821             CMP      R0,#+33
   \       0x58   0xD111             BNE.N    ??I2C_ITMasterCplt_3
   5468            {
   5469              hi2c->State = HAL_I2C_STATE_READY;
   \       0x5A   0x2120             MOVS     R1,#+32
   \       0x5C   0x7069             STRB     R1,[R5, #+1]
   5470          
   5471              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x5E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x60   0x2840             CMP      R0,#+64
   \       0x62   0xD107             BNE.N    ??I2C_ITMasterCplt_4
   5472              {
   5473                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x64   0x2100             MOVS     R1,#+0
   5474          
   5475                /* Process Unlocked */
   5476                __HAL_UNLOCK(hi2c);
   5477          
   5478                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5479          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5480                hi2c->MemTxCpltCallback(hi2c);
   5481          #else
   5482                HAL_I2C_MemTxCpltCallback(hi2c);
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x70A9             STRB     R1,[R5, #+2]
   \       0x6A   0x7029             STRB     R1,[R5, #+0]
   \       0x6C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x70   0x.... 0x....      B.W      HAL_I2C_MemTxCpltCallback
   5483          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5484              }
   5485              else
   5486              {
   5487                hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_ITMasterCplt_4: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x70A8             STRB     R0,[R5, #+2]
   5488          
   5489                /* Process Unlocked */
   5490                __HAL_UNLOCK(hi2c);
   \       0x78   0x7028             STRB     R0,[R5, #+0]
   5491          
   5492                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5493          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5494                hi2c->MasterTxCpltCallback(hi2c);
   5495          #else
   5496                HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....             B.N      ?Subroutine5
   5497          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5498              }
   5499            }
   5500            /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
   5501            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \                     ??I2C_ITMasterCplt_3: (+1)
   \       0x7E   0x7868             LDRB     R0,[R5, #+1]
   \       0x80   0x2822             CMP      R0,#+34
   \       0x82   0xD10F             BNE.N    ??I2C_ITMasterCplt_5
   5502            {
   5503              hi2c->State = HAL_I2C_STATE_READY;
   \       0x84   0x2120             MOVS     R1,#+32
   \       0x86   0x7069             STRB     R1,[R5, #+1]
   5504          
   5505              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x88   0x78A8             LDRB     R0,[R5, #+2]
   \       0x8A   0x2840             CMP      R0,#+64
   \       0x8C   0xD107             BNE.N    ??I2C_ITMasterCplt_6
   5506              {
   5507                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x8E   0x2100             MOVS     R1,#+0
   5508          
   5509                /* Process Unlocked */
   5510                __HAL_UNLOCK(hi2c);
   5511          
   5512                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5513          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5514                hi2c->MemRxCpltCallback(hi2c);
   5515          #else
   5516                HAL_I2C_MemRxCpltCallback(hi2c);
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0x70A9             STRB     R1,[R5, #+2]
   \       0x94   0x7029             STRB     R1,[R5, #+0]
   \       0x96   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x9A   0x.... 0x....      B.W      HAL_I2C_MemRxCpltCallback
   5517          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5518              }
   5519              else
   5520              {
   5521                hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_ITMasterCplt_6: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x70A8             STRB     R0,[R5, #+2]
   5522          
   5523                /* Process Unlocked */
   5524                __HAL_UNLOCK(hi2c);
   \       0xA2   0x....             B.N      ?Subroutine4
   5525          
   5526                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5527          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5528                hi2c->MasterRxCpltCallback(hi2c);
   5529          #else
   5530                HAL_I2C_MasterRxCpltCallback(hi2c);
   5531          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5532              }
   5533            }
   5534            else
   5535            {
   5536              /* Nothing to do */
   5537            }
   5538          }
   \                     ??I2C_ITMasterCplt_5: (+1)
   \       0xA4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5539          
   5540          /**
   5541            * @brief  I2C Slave complete process.
   5542            * @param  hi2c I2C handle.
   5543            * @param  ITFlags Interrupt flags to handle.
   5544            * @retval None
   5545            */

   \                                 In section .text, align 2, keep-with-next
   5546          static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5547          {
   \                     I2C_ITSlaveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   5548            uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   5549            uint32_t tmpITFlags = ITFlags;
   5550          
   5551            /* Clear STOP Flag */
   5552            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \        0x8   0x2220             MOVS     R2,#+32
   5553          
   5554            /* Disable all interrupts */
   5555            I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
   \        0xA   0x2107             MOVS     R1,#+7
   \        0xC   0x6806             LDR      R6,[R0, #+0]
   \        0xE   0x61C2             STR      R2,[R0, #+28]
   \       0x10   0x.... 0x....      BL       ??Subroutine20_0
   5556          
   5557            /* Disable Address Acknowledge */
   5558            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6842             LDR      R2,[R0, #+4]
   \       0x18   0xF442 0x4200      ORR      R2,R2,#0x8000
   \       0x1C   0x6042             STR      R2,[R0, #+4]
   5559          
   5560            /* Clear Configuration Register 2 */
   5561            I2C_RESET_CR2(hi2c);
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0xfe00e800
   \       0x24   0x684B             LDR      R3,[R1, #+4]
   \       0x26   0x4003             ANDS     R3,R0,R3
   5562          
   5563            /* Flush TX register */
   5564            I2C_Flush_TXDR(hi2c);
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x604B             STR      R3,[R1, #+4]
   \       0x2C   0x.... 0x....      BL       I2C_Flush_TXDR
   5565          
   5566            /* If a DMA is ongoing, Update handle size context */
   5567            if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
   \       0x30   0x0471             LSLS     R1,R6,#+17
   \       0x32   0xBF48             IT       MI 
   \       0x34   0x6BA0             LDRMI    R0,[R4, #+56]
   5568            {
   5569              if (hi2c->hdmatx != NULL)
   \       0x36   0xD402             BMI.N    ??I2C_ITSlaveCplt_0
   5570              {
   5571                hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
   5572              }
   5573            }
   5574            else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
   \       0x38   0x0430             LSLS     R0,R6,#+16
   \       0x3A   0xD504             BPL.N    ??I2C_ITSlaveCplt_1
   5575            {
   5576              if (hi2c->hdmarx != NULL)
   \       0x3C   0x6BE0             LDR      R0,[R4, #+60]
   \                     ??I2C_ITSlaveCplt_0: (+1)
   \       0x3E   0xB110             CBZ.N    R0,??I2C_ITSlaveCplt_1
   5577              {
   5578                hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x6841             LDR      R1,[R0, #+4]
   \       0x44   0x8561             STRH     R1,[R4, #+42]
   5579              }
   5580            }
   5581            else
   5582            {
   5583              /* Do nothing */
   5584            }
   5585          
   5586            /* Store Last receive data if any */
   5587            if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
   \                     ??I2C_ITSlaveCplt_1: (+1)
   \       0x46   0x0768             LSLS     R0,R5,#+29
   \       0x48   0xD50C             BPL.N    ??CrossCallReturnLabel_220
   5588            {
   5589              /* Remove RXNE flag on temporary variable as read done */
   5590              tmpITFlags &= ~I2C_FLAG_RXNE;
   5591          
   5592              /* Read data from RXDR */
   5593              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0xF025 0x0504      BIC      R5,R5,#0x4
   \       0x50   0x6A4A             LDR      R2,[R1, #+36]
   \       0x52   0x6A60             LDR      R0,[R4, #+36]
   \       0x54   0x7002             STRB     R2,[R0, #+0]
   5594          
   5595              /* Increment Buffer pointer */
   5596              hi2c->pBuffPtr++;
   \       0x56   0x6A61             LDR      R1,[R4, #+36]
   5597          
   5598              if ((hi2c->XferSize > 0U))
   \       0x58   0x8D20             LDRH     R0,[R4, #+40]
   \       0x5A   0x1C4B             ADDS     R3,R1,#+1
   \       0x5C   0x6263             STR      R3,[R4, #+36]
   \       0x5E   0xB108             CBZ.N    R0,??CrossCallReturnLabel_220
   5599              {
   5600                hi2c->XferSize--;
   \       0x60   0x.... 0x....      BL       ?Subroutine94
   5601                hi2c->XferCount--;
   5602              }
   5603            }
   5604          
   5605            /* All data are not transferred, so set error code accordingly */
   5606            if (hi2c->XferCount != 0U)
   \                     ??CrossCallReturnLabel_220: (+1)
   \       0x64   0x8D60             LDRH     R0,[R4, #+42]
   \       0x66   0xF104 0x0640      ADD      R6,R4,#+64
   \       0x6A   0xB118             CBZ.N    R0,??I2C_ITSlaveCplt_2
   5607            {
   5608              /* Set ErrorCode corresponding to a Non-Acknowledge */
   5609              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x6C   0x6871             LDR      R1,[R6, #+4]
   \       0x6E   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x72   0x6071             STR      R1,[R6, #+4]
   5610            }
   5611          
   5612            hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITSlaveCplt_2: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   5613            hi2c->Mode = HAL_I2C_MODE_NONE;
   5614            hi2c->XferISR = NULL;
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0x6320             STR      R0,[R4, #+48]
   \       0x7A   0x70B0             STRB     R0,[R6, #+2]
   \       0x7C   0x6362             STR      R2,[R4, #+52]
   \       0x7E   0x6870             LDR      R0,[R6, #+4]
   \       0x80   0xB158             CBZ.N    R0,??I2C_ITSlaveCplt_3
   5615          
   5616            if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   5617            {
   5618              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5619              I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0x82   0x6871             LDR      R1,[R6, #+4]
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x.... 0x....      BL       I2C_ITError
   5620          
   5621              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5622              if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \       0x8A   0x7870             LDRB     R0,[R6, #+1]
   \       0x8C   0x2828             CMP      R0,#+40
   \       0x8E   0xD129             BNE.N    ??I2C_ITSlaveCplt_4
   5623              {
   5624                /* Call I2C Listen complete process */
   5625                I2C_ITListenCplt(hi2c, tmpITFlags);
   \       0x90   0x4629             MOV      R1,R5
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x98   0x....             B.N      I2C_ITListenCplt
   5626              }
   5627            }
   5628            else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \                     ??I2C_ITSlaveCplt_3: (+1)
   \       0x9A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x9C   0x.... 0x....      LDR.W    R5,??DataTable44  ;; 0xffff0000
   \       0xA0   0x42A8             CMP      R0,R5
   \       0xA2   0xD00C             BEQ.N    ??I2C_ITSlaveCplt_5
   5629            {
   5630              /* Call the Sequential Complete callback, to inform upper layer of the end of Tranfer */
   5631              I2C_ITSlaveSeqCplt(hi2c);
   \       0xA4   0x4620             MOV      R0,R4
   \       0xA6   0x.... 0x....      BL       I2C_ITSlaveSeqCplt
   5632          
   5633              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xAA   0x62E5             STR      R5,[R4, #+44]
   5634              hi2c->State = HAL_I2C_STATE_READY;
   \       0xAC   0x2120             MOVS     R1,#+32
   \       0xAE   0x7071             STRB     R1,[R6, #+1]
   5635          
   5636              /* Process Unlocked */
   5637              __HAL_UNLOCK(hi2c);
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x7030             STRB     R0,[R6, #+0]
   5638          
   5639              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5640          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5641              hi2c->ListenCpltCallback(hi2c);
   5642          #else
   5643              HAL_I2C_ListenCpltCallback(hi2c);
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xBA   0x.... 0x....      B.W      HAL_I2C_ListenCpltCallback
   5644          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5645            }
   5646            /* Call the corresponding callback to inform upper layer of End of Transfer */
   5647            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \                     ??I2C_ITSlaveCplt_5: (+1)
   \       0xBE   0x7871             LDRB     R1,[R6, #+1]
   \       0xC0   0x2922             CMP      R1,#+34
   \       0xC2   0xD107             BNE.N    ??I2C_ITSlaveCplt_6
   5648            {
   5649              hi2c->State = HAL_I2C_STATE_READY;
   \       0xC4   0x2020             MOVS     R0,#+32
   \       0xC6   0x7070             STRB     R0,[R6, #+1]
   5650          
   5651              /* Process Unlocked */
   5652              __HAL_UNLOCK(hi2c);
   5653          
   5654              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5655          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5656              hi2c->SlaveRxCpltCallback(hi2c);
   5657          #else
   5658              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0xC8   0x4620             MOV      R0,R4
   \       0xCA   0x7032             STRB     R2,[R6, #+0]
   \       0xCC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xD0   0x.... 0x....      B.W      HAL_I2C_SlaveRxCpltCallback
   5659          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5660            }
   5661            else
   5662            {
   5663              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_ITSlaveCplt_6: (+1)
   \       0xD4   0x2120             MOVS     R1,#+32
   5664          
   5665              /* Process Unlocked */
   5666              __HAL_UNLOCK(hi2c);
   5667          
   5668              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5669          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5670              hi2c->SlaveTxCpltCallback(hi2c);
   5671          #else
   5672              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0xD6   0x4620             MOV      R0,R4
   \       0xD8   0x7071             STRB     R1,[R6, #+1]
   \       0xDA   0x7032             STRB     R2,[R6, #+0]
   \       0xDC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xE0   0x.... 0x....      B.W      HAL_I2C_SlaveTxCpltCallback
   5673          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5674            }
   5675          }
   \                     ??I2C_ITSlaveCplt_4: (+1)
   \       0xE4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine94: (+1)
   \        0x0   0x1E40             SUBS     R0,R0,#+1
   \        0x2   0x8520             STRH     R0,[R4, #+40]
   \        0x4   0x8D61             LDRH     R1,[R4, #+42]
   \        0x6   0x1E4A             SUBS     R2,R1,#+1
   \        0x8   0x8562             STRH     R2,[R4, #+42]
   \        0xA   0x4770             BX       LR
   5676          
   5677          /**
   5678            * @brief  I2C Listen complete process.
   5679            * @param  hi2c I2C handle.
   5680            * @param  ITFlags Interrupt flags to handle.
   5681            * @retval None
   5682            */

   \                                 In section .text, align 2, keep-with-next
   5683          static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5684          {
   \                     I2C_ITListenCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5685            /* Reset handle parameters */
   5686            hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0xffff0000
   \        0x8   0x62E0             STR      R0,[R4, #+44]
   5687            hi2c->PreviousState = I2C_STATE_NONE;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6322             STR      R2,[R4, #+48]
   5688            hi2c->State = HAL_I2C_STATE_READY;
   \        0xE   0xF104 0x0540      ADD      R5,R4,#+64
   \       0x12   0x2320             MOVS     R3,#+32
   5689            hi2c->Mode = HAL_I2C_MODE_NONE;
   5690            hi2c->XferISR = NULL;
   5691          
   5692            /* Store Last receive data if any */
   5693            if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
   \       0x14   0x0749             LSLS     R1,R1,#+29
   \       0x16   0x706B             STRB     R3,[R5, #+1]
   \       0x18   0x70AA             STRB     R2,[R5, #+2]
   \       0x1A   0x6362             STR      R2,[R4, #+52]
   \       0x1C   0xD50E             BPL.N    ??I2C_ITListenCplt_0
   5694            {
   5695              /* Read data from RXDR */
   5696              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6A42             LDR      R2,[R0, #+36]
   \       0x22   0x6A61             LDR      R1,[R4, #+36]
   \       0x24   0x700A             STRB     R2,[R1, #+0]
   5697          
   5698              /* Increment Buffer pointer */
   5699              hi2c->pBuffPtr++;
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x1C43             ADDS     R3,R0,#+1
   5700          
   5701              if ((hi2c->XferSize > 0U))
   \       0x2A   0x8D20             LDRH     R0,[R4, #+40]
   \       0x2C   0x6263             STR      R3,[R4, #+36]
   \       0x2E   0xB128             CBZ.N    R0,??I2C_ITListenCplt_0
   5702              {
   5703                hi2c->XferSize--;
   \       0x30   0x.... 0x....      BL       ?Subroutine94
   5704                hi2c->XferCount--;
   5705          
   5706                /* Set ErrorCode corresponding to a Non-Acknowledge */
   5707                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??CrossCallReturnLabel_221: (+1)
   \       0x34   0x686B             LDR      R3,[R5, #+4]
   \       0x36   0xF043 0x0304      ORR      R3,R3,#0x4
   \       0x3A   0x606B             STR      R3,[R5, #+4]
   5708              }
   5709            }
   5710          
   5711            /* Disable all Interrupts*/
   5712            I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \                     ??I2C_ITListenCplt_0: (+1)
   \       0x3C   0x2107             MOVS     R1,#+7
   \       0x3E   0x.... 0x....      BL       ??Subroutine20_0
   5713          
   5714            /* Clear NACK Flag */
   5715            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x42   0x6823             LDR      R3,[R4, #+0]
   \       0x44   0x2210             MOVS     R2,#+16
   5716          
   5717            /* Process Unlocked */
   5718            __HAL_UNLOCK(hi2c);
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x61DA             STR      R2,[R3, #+28]
   \       0x4A   0x7028             STRB     R0,[R5, #+0]
   5719          
   5720            /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5721          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5722            hi2c->ListenCpltCallback(hi2c);
   5723          #else
   5724            HAL_I2C_ListenCpltCallback(hi2c);
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x52   0x.... 0x....      B.W      HAL_I2C_ListenCpltCallback
   5725          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5726          }
   5727          
   5728          /**
   5729            * @brief  I2C interrupts error process.
   5730            * @param  hi2c I2C handle.
   5731            * @param  ErrorCode Error code to handle.
   5732            * @retval None
   5733            */

   \                                 In section .text, align 2, keep-with-next
   5734          static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
   5735          {
   \                     I2C_ITError: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
   5736            HAL_I2C_StateTypeDef tmpstate = hi2c->State;
   5737          
   5738            /* Reset handle parameters */
   5739            hi2c->Mode          = HAL_I2C_MODE_NONE;
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x70AA             STRB     R2,[R5, #+2]
   5740            hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   \        0xA   0x.... 0x....      LDR.W    R3,??DataTable44  ;; 0xffff0000
   \        0xE   0x62E3             STR      R3,[R4, #+44]
   5741            hi2c->XferCount     = 0U;
   \       0x10   0x2600             MOVS     R6,#+0
   \       0x12   0x8566             STRH     R6,[R4, #+42]
   5742          
   5743            /* Set new error code */
   5744            hi2c->ErrorCode |= ErrorCode;
   \       0x14   0x686A             LDR      R2,[R5, #+4]
   \       0x16   0x4311             ORRS     R1,R1,R2
   5745          
   5746            /* Disable Interrupts */
   5747            if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
   5748                (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
   5749                (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \       0x18   0x2828             CMP      R0,#+40
   \       0x1A   0x6069             STR      R1,[R5, #+4]
   \       0x1C   0xBF1C             ITT      NE 
   \       0x1E   0x2829             CMPNE    R0,#+41
   \       0x20   0x282A             CMPNE    R0,#+42
   \       0x22   0xD109             BNE.N    ??I2C_ITError_0
   5750            {
   5751              /* Disable all interrupts, except interrupts related to LISTEN state */
   5752              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \       0x24   0x2103             MOVS     R1,#+3
   \       0x26   0x.... 0x....      BL       ??Subroutine20_0
   5753          
   5754              /* keep HAL_I2C_STATE_LISTEN if set */
   5755              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x2A   0x2228             MOVS     R2,#+40
   5756              hi2c->PreviousState = I2C_STATE_NONE;
   5757              hi2c->XferISR       = I2C_Slave_ISR_IT;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable44_3
   \       0x30   0x706A             STRB     R2,[R5, #+1]
   \       0x32   0x6326             STR      R6,[R4, #+48]
   \       0x34   0x6360             STR      R0,[R4, #+52]
   \       0x36   0xE009             B.N      ??I2C_ITError_1
   5758            }
   5759            else
   5760            {
   5761              /* Disable all interrupts */
   5762              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \                     ??I2C_ITError_0: (+1)
   \       0x38   0x2107             MOVS     R1,#+7
   \       0x3A   0x.... 0x....      BL       ??Subroutine20_0
   5763          
   5764              /* If state is an abort treatment on goind, don't change state */
   5765              /* This change will be do later */
   5766              if (hi2c->State != HAL_I2C_STATE_ABORT)
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x3E   0x7868             LDRB     R0,[R5, #+1]
   \       0x40   0x2860             CMP      R0,#+96
   \       0x42   0xBF1C             ITT      NE 
   \       0x44   0x2120             MOVNE    R1,#+32
   \       0x46   0x7069             STRBNE   R1,[R5, #+1]
   5767              {
   5768                /* Set HAL_I2C_STATE_READY */
   5769                hi2c->State         = HAL_I2C_STATE_READY;
   5770              }
   5771              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x48   0x6326             STR      R6,[R4, #+48]
   5772              hi2c->XferISR       = NULL;
   \       0x4A   0x6366             STR      R6,[R4, #+52]
   5773            }
   5774          
   5775            /* Abort DMA TX transfer if any */
   5776            if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??I2C_ITError_1: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x.... 0x....      ADR.W    R1,I2C_DMAAbort
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0x045A             LSLS     R2,R3,#+17
   \       0x56   0xD50E             BPL.N    ??I2C_ITError_2
   5777            {
   5778              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x58   0x6806             LDR      R6,[R0, #+0]
   \       0x5A   0xF426 0x4680      BIC      R6,R6,#0x4000
   \       0x5E   0x6006             STR      R6,[R0, #+0]
   5779          
   5780              if (hi2c->hdmatx != NULL)
   \       0x60   0x6BA0             LDR      R0,[R4, #+56]
   \       0x62   0xB370             CBZ.N    R0,??I2C_ITError_3
   5781              {
   5782                /* Set the I2C DMA Abort callback :
   5783                 will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5784                hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x64   0x6501             STR      R1,[R0, #+80]
   5785          
   5786                /* Process Unlocked */
   5787                __HAL_UNLOCK(hi2c);
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x7028             STRB     R0,[R5, #+0]
   5788          
   5789                /* Abort DMA TX */
   5790                if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x6A   0x6BA0             LDR      R0,[R4, #+56]
   \       0x6C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x70   0xB338             CBZ.N    R0,??I2C_ITError_3
   5791                {
   5792                  /* Call Directly XferAbortCallback function in case of error */
   5793                  hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x72   0x6BA0             LDR      R0,[R4, #+56]
   \       0x74   0xE010             B.N      ??I2C_ITError_4
   5794                }
   5795              }
   5796            }
   5797            /* Abort DMA RX transfer if any */
   5798            else if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??I2C_ITError_2: (+1)
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x0413             LSLS     R3,R2,#+16
   \       0x7A   0xD511             BPL.N    ??I2C_ITError_5
   5799            {
   5800              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x7C   0x6806             LDR      R6,[R0, #+0]
   \       0x7E   0xF426 0x4600      BIC      R6,R6,#0x8000
   \       0x82   0x6006             STR      R6,[R0, #+0]
   5801          
   5802              if (hi2c->hdmarx != NULL)
   \       0x84   0x6BE0             LDR      R0,[R4, #+60]
   \       0x86   0xB1E0             CBZ.N    R0,??I2C_ITError_3
   5803              {
   5804                /* Set the I2C DMA Abort callback :
   5805                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5806                hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x88   0x6501             STR      R1,[R0, #+80]
   5807          
   5808                /* Process Unlocked */
   5809                __HAL_UNLOCK(hi2c);
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x7028             STRB     R0,[R5, #+0]
   5810          
   5811                /* Abort DMA RX */
   5812                if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x8E   0x6BE0             LDR      R0,[R4, #+60]
   \       0x90   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x94   0xB1A8             CBZ.N    R0,??I2C_ITError_3
   5813                {
   5814                  /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
   5815                  hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x96   0x6BE0             LDR      R0,[R4, #+60]
   \                     ??I2C_ITError_4: (+1)
   \       0x98   0x6D01             LDR      R1,[R0, #+80]
   \       0x9A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x9E   0x4708             BX       R1
   5816                }
   5817              }
   5818            }
   5819            else if (hi2c->State == HAL_I2C_STATE_ABORT)
   \                     ??I2C_ITError_5: (+1)
   \       0xA0   0x7868             LDRB     R0,[R5, #+1]
   \       0xA2   0x2860             CMP      R0,#+96
   \       0xA4   0xD107             BNE.N    ??I2C_ITError_6
   5820            {
   5821              hi2c->State = HAL_I2C_STATE_READY;
   \       0xA6   0x2120             MOVS     R1,#+32
   5822          
   5823              /* Process Unlocked */
   5824              __HAL_UNLOCK(hi2c);
   5825          
   5826              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5827          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5828              hi2c->AbortCpltCallback(hi2c);
   5829          #else
   5830              HAL_I2C_AbortCpltCallback(hi2c);
   \       0xA8   0x4620             MOV      R0,R4
   \       0xAA   0x7069             STRB     R1,[R5, #+1]
   \       0xAC   0x702E             STRB     R6,[R5, #+0]
   \       0xAE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xB2   0x.... 0x....      B.W      HAL_I2C_AbortCpltCallback
   5831          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5832            }
   5833            else
   5834            {
   5835              /* Process Unlocked */
   5836              __HAL_UNLOCK(hi2c);
   \                     ??I2C_ITError_6: (+1)
   \       0xB6   0x702E             STRB     R6,[R5, #+0]
   5837          
   5838              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5839          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5840              hi2c->ErrorCallback(hi2c);
   5841          #else
   5842              HAL_I2C_ErrorCallback(hi2c);
   \       0xB8   0x4620             MOV      R0,R4
   \       0xBA   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xBE   0x.... 0x....      B.W      HAL_I2C_ErrorCallback
   5843          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5844            }
   5845          }
   \                     ??I2C_ITError_3: (+1)
   \       0xC2   0xBD70             POP      {R4-R6,PC}       ;; return
   5846          
   5847          /**
   5848            * @brief  I2C Tx data register flush process.
   5849            * @param  hi2c I2C handle.
   5850            * @retval None
   5851            */

   \                                 In section .text, align 2, keep-with-next
   5852          static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
   5853          {
   5854            /* If a pending TXIS flag is set */
   5855            /* Write a dummy data in TXDR to clear it */
   5856            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
   \                     I2C_Flush_TXDR: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0x078A             LSLS     R2,R1,#+30
   \        0x6   0xBF44             ITT      MI 
   \        0x8   0x2300             MOVMI    R3,#+0
   \        0xA   0x6283             STRMI    R3,[R0, #+40]
   5857            {
   5858              hi2c->Instance->TXDR = 0x00U;
   5859            }
   5860          
   5861            /* Flush TX register if not empty */
   5862            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \        0xC   0x6981             LDR      R1,[R0, #+24]
   \        0xE   0x07CA             LSLS     R2,R1,#+31
   \       0x10   0xD403             BMI.N    ??I2C_Flush_TXDR_0
   5863            {
   5864              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   \       0x12   0x6983             LDR      R3,[R0, #+24]
   \       0x14   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x18   0x6183             STR      R3,[R0, #+24]
   5865            }
   5866          }
   \                     ??I2C_Flush_TXDR_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   5867          
   5868          /**
   5869            * @brief  DMA I2C master transmit process complete callback.
   5870            * @param  hdma DMA handle
   5871            * @retval None
   5872            */

   \                                 In section .text, align 2, keep-with-next
   5873          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
   5874          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5875            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   5876          
   5877            /* Disable DMA Request */
   5878            hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xF422 0x4280      BIC      R2,R2,#0x4000
   \        0xC   0x6002             STR      R2,[R0, #+0]
   5879          
   5880            /* If last transfer, enable STOP interrupt */
   5881            if (hi2c->XferCount == 0U)
   \        0xE   0x8D61             LDRH     R1,[R4, #+42]
   \       0x10   0xB179             CBZ.N    R1,??I2C_DMAMasterTransmitCplt_0
   5882            {
   5883              /* Enable STOP interrupt */
   5884              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   5885            }
   5886            /* else prepare a new DMA transfer and enable TCReload interrupt */
   5887            else
   5888            {
   5889              /* Update Buffer pointer */
   5890              hi2c->pBuffPtr += hi2c->XferSize;
   \       0x12   0x8D20             LDRH     R0,[R4, #+40]
   \       0x14   0x6A62             LDR      R2,[R4, #+36]
   \       0x16   0x1811             ADDS     R1,R2,R0
   \       0x18   0x6261             STR      R1,[R4, #+36]
   5891          
   5892              /* Set the XferSize to transfer */
   5893              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x1A   0x8D63             LDRH     R3,[R4, #+42]
   \       0x1C   0xF5B3 0x7F80      CMP      R3,#+256
   \       0x20   0xBF27             ITTEE    CS 
   \       0x22   0x20FF             MOVCS    R0,#+255
   \       0x24   0x8520             STRHCS   R0,[R4, #+40]
   \       0x26   0x8D62             LDRHCC   R2,[R4, #+42]
   \       0x28   0x8522             STRHCC   R2,[R4, #+40]
   5894              {
   5895                hi2c->XferSize = MAX_NBYTE_SIZE;
   5896              }
   5897              else
   5898              {
   5899                hi2c->XferSize = hi2c->XferCount;
   5900              }
   5901          
   5902              /* Enable the DMA stream */
   5903              if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
   \       0x2A   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x2E   0xB100             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_0
   5904              {
   5905                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5906                I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \       0x30   0x....             B.N      ?Subroutine7
   5907              }
   5908              else
   5909              {
   5910                /* Enable TC interrupts */
   5911                I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \       0x32   0x....             B.N      ?Subroutine6
   5912              }
   5913            }
   5914          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0xE8BD 0x4010      POP      {R4,LR}
   \        0x8   0x....             B.N      I2C_ITError

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x2112             MOVS     R1,#+18
   \        0x4   0xE8BD 0x4010      POP      {R4,LR}
   \        0x8   0x....             B.N      I2C_Enable_IRQ
   5915          
   5916          /**
   5917            * @brief  DMA I2C slave transmit process complete callback.
   5918            * @param  hdma DMA handle
   5919            * @retval None
   5920            */

   \                                 In section .text, align 2, keep-with-next
   5921          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
   5922          {
   5923            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5924            uint32_t tmpoptions = hi2c->XferOptions;
   \        0x2   0x6AC1             LDR      R1,[R0, #+44]
   5925          
   5926            if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
   \        0x4   0xF1B1 0x7F80      CMP      R1,#+16777216
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD105             BNE.N    ??I2C_DMASlaveTransmitCplt_0
   5927            {
   5928              /* Disable DMA Request */
   5929              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x16   0x600A             STR      R2,[R1, #+0]
   5930          
   5931              /* Last Byte is Transmitted */
   5932              /* Call I2C Slave Sequential complete process */
   5933              I2C_ITSlaveSeqCplt(hi2c);
   \       0x18   0x....             B.N      I2C_ITSlaveSeqCplt
   5934            }
   5935            else
   5936            {
   5937              /* No specific action, Master fully manage the generation of STOP condition */
   5938              /* Mean that this generation can arrive at any time, at the end or during DMA process */
   5939              /* So STOP condition should be manage through Interrupt treatment */
   5940            }
   5941          }
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   5942          
   5943          /**
   5944            * @brief DMA I2C master receive process complete callback.
   5945            * @param  hdma DMA handle
   5946            * @retval None
   5947            */

   \                                 In section .text, align 2, keep-with-next
   5948          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
   5949          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5950            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   5951          
   5952            /* Disable DMA Request */
   5953            hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xF422 0x4200      BIC      R2,R2,#0x8000
   \        0xC   0x6002             STR      R2,[R0, #+0]
   5954          
   5955            /* If last transfer, enable STOP interrupt */
   5956            if (hi2c->XferCount == 0U)
   \        0xE   0x8D61             LDRH     R1,[R4, #+42]
   \       0x10   0xB179             CBZ.N    R1,??I2C_DMAMasterReceiveCplt_0
   5957            {
   5958              /* Enable STOP interrupt */
   5959              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   5960            }
   5961            /* else prepare a new DMA transfer and enable TCReload interrupt */
   5962            else
   5963            {
   5964              /* Update Buffer pointer */
   5965              hi2c->pBuffPtr += hi2c->XferSize;
   \       0x12   0x8D20             LDRH     R0,[R4, #+40]
   \       0x14   0x6A62             LDR      R2,[R4, #+36]
   \       0x16   0x4402             ADD      R2,R2,R0
   \       0x18   0x6262             STR      R2,[R4, #+36]
   5966          
   5967              /* Set the XferSize to transfer */
   5968              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x1A   0x8D61             LDRH     R1,[R4, #+42]
   \       0x1C   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x20   0xBF27             ITTEE    CS 
   \       0x22   0x20FF             MOVCS    R0,#+255
   \       0x24   0x8520             STRHCS   R0,[R4, #+40]
   \       0x26   0x8D61             LDRHCC   R1,[R4, #+42]
   \       0x28   0x8521             STRHCC   R1,[R4, #+40]
   5969              {
   5970                hi2c->XferSize = MAX_NBYTE_SIZE;
   5971              }
   5972              else
   5973              {
   5974                hi2c->XferSize = hi2c->XferCount;
   5975              }
   5976          
   5977              /* Enable the DMA stream */
   5978              if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
   \       0x2A   0x.... 0x....      BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x2E   0xB100             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_0
   5979              {
   5980                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5981                I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \       0x30   0x....             B.N      ?Subroutine7
   5982              }
   5983              else
   5984              {
   5985                /* Enable TC interrupts */
   5986                I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \       0x32   0x....             B.N      ?Subroutine6
   5987              }
   5988            }
   5989          }
   5990          
   5991          /**
   5992            * @brief  DMA I2C slave receive process complete callback.
   5993            * @param  hdma DMA handle
   5994            * @retval None
   5995            */

   \                                 In section .text, align 4, keep-with-next
   5996          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
   5997          {
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5998            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   5999            uint32_t tmpoptions = hi2c->XferOptions;
   \        0x4   0x6AC2             LDR      R2,[R0, #+44]
   6000          
   6001            if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
   6002                (tmpoptions != I2C_NO_OPTION_FRAME))
   \        0x6   0x6BC3             LDR      R3,[R0, #+60]
   \        0x8   0x681C             LDR      R4,[R3, #+0]
   \        0xA   0x6861             LDR      R1,[R4, #+4]
   \        0xC   0xB951             CBNZ.N   R1,??I2C_DMASlaveReceiveCplt_0
   \        0xE   0x....             LDR.N    R3,??DataTable44  ;; 0xffff0000
   \       0x10   0x429A             CMP      R2,R3
   \       0x12   0xD007             BEQ.N    ??I2C_DMASlaveReceiveCplt_0
   6003            {
   6004              /* Disable DMA Request */
   6005              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x1C   0x600A             STR      R2,[R1, #+0]
   6006          
   6007              /* Call I2C Slave Sequential complete process */
   6008              I2C_ITSlaveSeqCplt(hi2c);
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x....             B.N      I2C_ITSlaveSeqCplt
   6009            }
   6010            else
   6011            {
   6012              /* No specific action, Master fully manage the generation of STOP condition */
   6013              /* Mean that this generation can arrive at any time, at the end or during DMA process */
   6014              /* So STOP condition should be manage through Interrupt treatment */
   6015            }
   6016          }
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
   6017          
   6018          /**
   6019            * @brief  DMA I2C communication error callback.
   6020            * @param hdma DMA handle
   6021            * @retval None
   6022            */

   \                                 In section .text, align 4, keep-with-next
   6023          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   6024          {
   \                     I2C_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   6025            uint32_t treatdmaerror = 0U;
   6026            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B85             LDR      R5,[R0, #+56]
   \        0x4   0x2400             MOVS     R4,#+0
   6027          
   6028            if (hi2c->hdmatx != NULL)
   \        0x6   0x6BA9             LDR      R1,[R5, #+56]
   \        0x8   0x.... 0x....      BL       ?Subroutine88
   6029            {
   6030              if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
   6031              {
   6032                treatdmaerror = 1U;
   6033              }
   6034            }
   6035          
   6036            if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_201: (+1)
   \        0xC   0x6BE9             LDR      R1,[R5, #+60]
   \        0xE   0x.... 0x....      BL       ?Subroutine88
   6037            {
   6038              if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
   6039              {
   6040                treatdmaerror = 1U;
   6041              }
   6042            }
   6043          
   6044            /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
   6045            if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
   \                     ??CrossCallReturnLabel_202: (+1)
   \       0x12   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xBF18             IT       NE 
   \       0x1A   0x2C00             CMPNE    R4,#+0
   \       0x1C   0xD007             BEQ.N    ??I2C_DMAError_0
   6046            {
   6047              /* Disable Acknowledge */
   6048              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x.... 0x....      BL       ??Subroutine37_1
   6049          
   6050              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6051              I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x2110             MOVS     R1,#+16
   \       0x28   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2C   0x....             B.N      I2C_ITError
   6052            }
   6053          }
   \                     ??I2C_DMAError_0: (+1)
   \       0x2E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine88: (+1)
   \        0x0   0xB119             CBZ.N    R1,??Subroutine88_0
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x6851             LDR      R1,[R2, #+4]
   \        0x6   0xB901             CBNZ.N   R1,??Subroutine88_0
   \        0x8   0x2401             MOVS     R4,#+1
   \                     ??Subroutine88_0: (+1)
   \        0xA   0x4770             BX       LR
   6054          
   6055          /**
   6056            * @brief DMA I2C communication abort callback
   6057            *        (To be called at end of DMA Abort procedure).
   6058            * @param hdma DMA handle.
   6059            * @retval None
   6060            */

   \                                 In section .text, align 4, keep-with-next
   6061          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
   6062          {
   6063            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \                     I2C_DMAAbort: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   6064          
   6065            /* Reset AbortCpltCallback */
   6066            hi2c->hdmatx->XferAbortCallback = NULL;
   \        0x2   0x2100             MOVS     R1,#+0
   6067            hi2c->hdmarx->XferAbortCallback = NULL;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x6B82             LDR      R2,[R0, #+56]
   \        0x8   0x6511             STR      R1,[R2, #+80]
   \        0xA   0x6BC1             LDR      R1,[R0, #+60]
   \        0xC   0x650B             STR      R3,[R1, #+80]
   6068          
   6069            /* Check if come from abort from user */
   6070            if (hi2c->State == HAL_I2C_STATE_ABORT)
   \        0xE   0xF890 0x2041      LDRB     R2,[R0, #+65]
   \       0x12   0x2A60             CMP      R2,#+96
   \       0x14   0xBF18             IT       NE 
   6071            {
   6072              hi2c->State = HAL_I2C_STATE_READY;
   6073          
   6074              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6075          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6076              hi2c->AbortCpltCallback(hi2c);
   6077          #else
   6078              HAL_I2C_AbortCpltCallback(hi2c);
   6079          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6080            }
   6081            else
   6082            {
   6083              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6084          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6085              hi2c->ErrorCallback(hi2c);
   6086          #else
   6087              HAL_I2C_ErrorCallback(hi2c);
   \       0x16   0x.... 0x....      BNE.W    HAL_I2C_ErrorCallback
   6088          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6089            }
   \       0x1A   0x2120             MOVS     R1,#+32
   \       0x1C   0xF880 0x1041      STRB     R1,[R0, #+65]
   \       0x20   0x.... 0x....      B.W      HAL_I2C_AbortCpltCallback
   6090          }
   6091          
   6092          /**
   6093            * @brief  This function handles I2C Communication Timeout.
   6094            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6095            *                the configuration information for the specified I2C.
   6096            * @param  Flag Specifies the I2C flag to check.
   6097            * @param  Status The new Flag status (SET or RESET).
   6098            * @param  Timeout Timeout duration
   6099            * @param  Tickstart Tick start value
   6100            * @retval HAL status
   6101            */

   \                                 In section .text, align 2, keep-with-next
   6102          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
   6103          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461C             MOV      R4,R3
   \        0xC   0x9F06             LDR      R7,[SP, #+24]
   6104            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6981             LDR      R1,[R0, #+24]
   \       0x12   0x4031             ANDS     R1,R6,R1
   \       0x14   0x42B1             CMP      R1,R6
   \       0x16   0xBF0C             ITE      EQ 
   \       0x18   0x2001             MOVEQ    R0,#+1
   \       0x1A   0x2000             MOVNE    R0,#+0
   \       0x1C   0x4540             CMP      R0,R8
   \       0x1E   0xD10D             BNE.N    ??I2C_WaitOnFlagUntilTimeout_1
   6105            {
   6106              /* Check for the Timeout */
   6107              if (Timeout != HAL_MAX_DELAY)
   \       0x20   0xF114 0x0F01      CMN      R4,#+1
   \       0x24   0xD0F3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   6108              {
   6109                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x26   0x.... 0x....      BL       HAL_GetTick
   \       0x2A   0x1BC0             SUBS     R0,R0,R7
   \       0x2C   0x4284             CMP      R4,R0
   \       0x2E   0xD301             BCC.N    ??I2C_WaitOnFlagUntilTimeout_2
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD1EC             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   6110                {
   6111                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \       0x34   0x.... 0x....      BL       ?Subroutine38
   6112                  hi2c->State = HAL_I2C_STATE_READY;
   6113                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6114          
   6115                  /* Process Unlocked */
   6116                  __HAL_UNLOCK(hi2c);
   6117                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   6118                }
   6119              }
   6120            }
   6121            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   6122          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \        0x0   0xF105 0x0040      ADD      R0,R5,#+64
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xE   0x6041             STR      R1,[R0, #+4]
   \       0x10   0x7042             STRB     R2,[R0, #+1]
   \       0x12   0x7083             STRB     R3,[R0, #+2]
   \       0x14   0x7003             STRB     R3,[R0, #+0]
   \       0x16   0x4770             BX       LR
   6123          
   6124          /**
   6125            * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
   6126            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6127            *                the configuration information for the specified I2C.
   6128            * @param  Timeout Timeout duration
   6129            * @param  Tickstart Tick start value
   6130            * @retval HAL status
   6131            */

   \                                 In section .text, align 2, keep-with-next
   6132          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6133          {
   \                     I2C_WaitOnTXISFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6134            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x078A             LSLS     R2,R1,#+30
   \        0xE   0xD410             BMI.N    ??I2C_WaitOnTXISFlagUntilTimeout_1
   6135            {
   6136              /* Check if a NACK is detected */
   6137              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x.... 0x....      BL       ?Subroutine90
   \                     ??CrossCallReturnLabel_213: (+1)
   \       0x14   0xB958             CBNZ.N   R0,??CrossCallReturnLabel_79
   6138              {
   6139                return HAL_ERROR;
   6140              }
   6141          
   6142              /* Check for the Timeout */
   6143              if (Timeout != HAL_MAX_DELAY)
   \       0x16   0xF114 0x0F01      CMN      R4,#+1
   \       0x1A   0xD0F5             BEQ.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   6144              {
   6145                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC.N    ??I2C_WaitOnTXISFlagUntilTimeout_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1EE             BNE.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   6146                {
   6147                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_2: (+1)
   \       0x2A   0x.... 0x....      BL       ?Subroutine38
   6148                  hi2c->State = HAL_I2C_STATE_READY;
   6149                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6150          
   6151                  /* Process Unlocked */
   6152                  __HAL_UNLOCK(hi2c);
   6153          
   6154                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBD70             POP      {R4-R6,PC}
   6155                }
   6156              }
   6157            }
   6158            return HAL_OK;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD70             POP      {R4-R6,PC}       ;; return
   6159          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine90: (+1)
   \        0x0   0x4632             MOV      R2,R6
   \        0x2   0x4621             MOV      R1,R4
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....             B.N      I2C_IsAcknowledgeFailed
   6160          
   6161          /**
   6162            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   6163            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6164            *                the configuration information for the specified I2C.
   6165            * @param  Timeout Timeout duration
   6166            * @param  Tickstart Tick start value
   6167            * @retval HAL status
   6168            */

   \                                 In section .text, align 2, keep-with-next
   6169          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6170          {
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6171            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x068A             LSLS     R2,R1,#+26
   \        0xE   0xD40D             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   6172            {
   6173              /* Check if a NACK is detected */
   6174              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x.... 0x....      BL       ?Subroutine90
   \                     ??CrossCallReturnLabel_212: (+1)
   \       0x14   0xB940             CBNZ.N   R0,??CrossCallReturnLabel_80
   6175              {
   6176                return HAL_ERROR;
   6177              }
   6178          
   6179              /* Check for the Timeout */
   6180              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x1B80             SUBS     R0,R0,R6
   \       0x1C   0x4284             CMP      R4,R0
   \       0x1E   0xD301             BCC.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD1F1             BNE.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   6181              {
   6182                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \       0x24   0x.... 0x....      BL       ?Subroutine38
   6183                hi2c->State = HAL_I2C_STATE_READY;
   6184                hi2c->Mode = HAL_I2C_MODE_NONE;
   6185          
   6186                /* Process Unlocked */
   6187                __HAL_UNLOCK(hi2c);
   6188          
   6189                return HAL_ERROR;
   6190              }
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   6191            }
   6192            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
   6193          }
   6194          
   6195          /**
   6196            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   6197            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6198            *                the configuration information for the specified I2C.
   6199            * @param  Timeout Timeout duration
   6200            * @param  Tickstart Tick start value
   6201            * @retval HAL status
   6202            */

   \                                 In section .text, align 2, keep-with-next
   6203          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6204          {
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6205            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x074A             LSLS     R2,R1,#+29
   \        0xE   0xD42D             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   6206            {
   6207              /* Check if a NACK is detected */
   6208              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x.... 0x....      BL       ?Subroutine90
   \                     ??CrossCallReturnLabel_211: (+1)
   \       0x14   0xBB40             CBNZ.N   R0,??I2C_WaitOnRXNEFlagUntilTimeout_2
   6209              {
   6210                return HAL_ERROR;
   6211              }
   6212          
   6213              /* Check if a STOPF is detected */
   6214              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \       0x16   0x6829             LDR      R1,[R5, #+0]
   \       0x18   0x6988             LDR      R0,[R1, #+24]
   \       0x1A   0x0682             LSLS     R2,R0,#+26
   \       0x1C   0xD411             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   6215              {
   6216                /* Check if an RXNE is pending */
   6217                /* Store Last receive data if any */
   6218                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
   6219                {
   6220                  /* Return HAL_OK */
   6221                  /* The Reading of data from RXDR will be done in caller function */
   6222                  return HAL_OK;
   6223                }
   6224                else
   6225                {
   6226                  /* Clear STOP Flag */
   6227                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   6228          
   6229                  /* Clear Configuration Register 2 */
   6230                  I2C_RESET_CR2(hi2c);
   6231          
   6232                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   6233                  hi2c->State = HAL_I2C_STATE_READY;
   6234                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6235          
   6236                  /* Process Unlocked */
   6237                  __HAL_UNLOCK(hi2c);
   6238          
   6239                  return HAL_ERROR;
   6240                }
   6241              }
   6242          
   6243              /* Check for the Timeout */
   6244              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x1E   0x.... 0x....      BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD301             BCC.N    ??I2C_WaitOnRXNEFlagUntilTimeout_4
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD1ED             BNE.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   6245              {
   6246                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_4: (+1)
   \       0x2C   0xF105 0x0040      ADD      R0,R5,#+64
   6247                hi2c->State = HAL_I2C_STATE_READY;
   \       0x30   0x2220             MOVS     R2,#+32
   \       0x32   0x6841             LDR      R1,[R0, #+4]
   6248          
   6249                /* Process Unlocked */
   6250                __HAL_UNLOCK(hi2c);
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x3A   0x6041             STR      R1,[R0, #+4]
   \       0x3C   0x7042             STRB     R2,[R0, #+1]
   \       0x3E   0x7003             STRB     R3,[R0, #+0]
   6251          
   6252                return HAL_ERROR;
   \       0x40   0xE012             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_2
   6253              }
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \       0x42   0x698A             LDR      R2,[R1, #+24]
   \       0x44   0x0753             LSLS     R3,R2,#+29
   \       0x46   0xD501             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_5
   \       0x48   0x8D28             LDRH     R0,[R5, #+40]
   \       0x4A   0xB978             CBNZ.N   R0,??I2C_WaitOnRXNEFlagUntilTimeout_1
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_5: (+1)
   \       0x4C   0x2220             MOVS     R2,#+32
   \       0x4E   0x....             LDR.N    R0,??DataTable44_2  ;; 0xfe00e800
   \       0x50   0x61CA             STR      R2,[R1, #+28]
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x684B             LDR      R3,[R1, #+4]
   \       0x56   0x4003             ANDS     R3,R0,R3
   \       0x58   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x5C   0x604B             STR      R3,[R1, #+4]
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x6041             STR      R1,[R0, #+4]
   \       0x62   0x7042             STRB     R2,[R0, #+1]
   \       0x64   0x7081             STRB     R1,[R0, #+2]
   \       0x66   0x7001             STRB     R1,[R0, #+0]
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   6254            }
   6255            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
   6256          }
   6257          
   6258          /**
   6259            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   6260            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6261            *                the configuration information for the specified I2C.
   6262            * @param  Timeout Timeout duration
   6263            * @param  Tickstart Tick start value
   6264            * @retval HAL status
   6265            */

   \                                 In section .text, align 2, keep-with-next
   6266          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6267          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   6268            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x06CA             LSLS     R2,R1,#+27
   \        0xE   0xD51A             BPL.N    ??I2C_IsAcknowledgeFailed_0
   6269            {
   6270              /* Wait until STOP Flag is reset */
   6271              /* AutoEnd should be initiate after AF */
   6272              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x6981             LDR      R1,[R0, #+24]
   \       0x14   0x068A             LSLS     R2,R1,#+26
   \       0x16   0xD418             BMI.N    ??I2C_IsAcknowledgeFailed_2
   6273              {
   6274                /* Check for the Timeout */
   6275                if (Timeout != HAL_MAX_DELAY)
   \       0x18   0xF114 0x0F01      CMN      R4,#+1
   \       0x1C   0xD0F8             BEQ.N    ??I2C_IsAcknowledgeFailed_1
   6276                {
   6277                  if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x1E   0x.... 0x....      BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD301             BCC.N    ??I2C_IsAcknowledgeFailed_3
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD1F1             BNE.N    ??I2C_IsAcknowledgeFailed_1
   6278                  {
   6279                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_IsAcknowledgeFailed_3: (+1)
   \       0x2C   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x30   0x6841             LDR      R1,[R0, #+4]
   \       0x32   0xF041 0x0120      ORR      R1,R1,#0x20
   \                     ??I2C_IsAcknowledgeFailed_4: (+1)
   \       0x36   0x6041             STR      R1,[R0, #+4]
   6280                    hi2c->State = HAL_I2C_STATE_READY;
   \       0x38   0x2220             MOVS     R2,#+32
   \       0x3A   0x7042             STRB     R2,[R0, #+1]
   6281                    hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x3C   0x2300             MOVS     R3,#+0
   \       0x3E   0x7083             STRB     R3,[R0, #+2]
   6282          
   6283                    /* Process Unlocked */
   6284                    __HAL_UNLOCK(hi2c);
   \       0x40   0x7003             STRB     R3,[R0, #+0]
   6285          
   6286                    return HAL_ERROR;
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xBD70             POP      {R4-R6,PC}
   6287                  }
   6288                }
   6289              }
   6290          
   6291              /* Clear NACKF Flag */
   6292              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   6293          
   6294              /* Clear STOP Flag */
   6295              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   6296          
   6297              /* Flush TX register */
   6298              I2C_Flush_TXDR(hi2c);
   6299          
   6300              /* Clear Configuration Register 2 */
   6301              I2C_RESET_CR2(hi2c);
   6302          
   6303              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   6304              hi2c->State = HAL_I2C_STATE_READY;
   6305              hi2c->Mode = HAL_I2C_MODE_NONE;
   6306          
   6307              /* Process Unlocked */
   6308              __HAL_UNLOCK(hi2c);
   6309          
   6310              return HAL_ERROR;
   6311            }
   6312            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??I2C_IsAcknowledgeFailed_2: (+1)
   \       0x4A   0x2210             MOVS     R2,#+16
   \       0x4C   0x61C2             STR      R2,[R0, #+28]
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0x61C8             STR      R0,[R1, #+28]
   \       0x54   0x4628             MOV      R0,R5
   \       0x56   0x.... 0x....      BL       I2C_Flush_TXDR
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x....             LDR.N    R0,??DataTable44_2  ;; 0xfe00e800
   \       0x5E   0x684A             LDR      R2,[R1, #+4]
   \       0x60   0x4002             ANDS     R2,R0,R2
   \       0x62   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x66   0x604A             STR      R2,[R1, #+4]
   \       0x68   0x6841             LDR      R1,[R0, #+4]
   \       0x6A   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x6E   0xE7E2             B.N      ??I2C_IsAcknowledgeFailed_4
   6313          }
   6314          
   6315          /**
   6316            * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
   6317            * @param  hi2c I2C handle.
   6318            * @param  DevAddress Specifies the slave address to be programmed.
   6319            * @param  Size Specifies the number of bytes to be programmed.
   6320            *   This parameter must be a value between 0 and 255.
   6321            * @param  Mode New state of the I2C START condition generation.
   6322            *   This parameter can be one of the following values:
   6323            *     @arg @ref I2C_RELOAD_MODE Enable Reload mode .
   6324            *     @arg @ref I2C_AUTOEND_MODE Enable Automatic end mode.
   6325            *     @arg @ref I2C_SOFTEND_MODE Enable Software end mode.
   6326            * @param  Request New state of the I2C START condition generation.
   6327            *   This parameter can be one of the following values:
   6328            *     @arg @ref I2C_NO_STARTSTOP Don't Generate stop and start condition.
   6329            *     @arg @ref I2C_GENERATE_STOP Generate stop condition (Size should be set to 0).
   6330            *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
   6331            *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
   6332            * @retval None
   6333            */

   \                                 In section .text, align 2, keep-with-next
   6334          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
   6335          {
   \                     I2C_TransferConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6336            /* Check the parameters */
   6337            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
   6338            assert_param(IS_TRANSFER_MODE(Mode));
   6339            assert_param(IS_TRANSFER_REQUEST(Request));
   6340          
   6341            /* update CR2 register */
   6342            MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
   6343                       (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x9C04             LDR      R4,[SP, #+16]
   \        0x6   0x....             LDR.N    R6,??DataTable44_4  ;; 0x3ff63ff
   \        0x8   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \        0xC   0xEA46 0x5654      ORR      R6,R6,R4, LSR #+21
   \       0x10   0x6845             LDR      R5,[R0, #+4]
   \       0x12   0x43B5             BICS     R5,R5,R6
   \       0x14   0x4329             ORRS     R1,R1,R5
   \       0x16   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \       0x1A   0x4319             ORRS     R1,R3,R1
   \       0x1C   0x4321             ORRS     R1,R4,R1
   \       0x1E   0x6041             STR      R1,[R0, #+4]
   6344          }
   \       0x20   0xBD70             POP      {R4-R6,PC}       ;; return
   6345          
   6346          /**
   6347            * @brief  Manage the enabling of Interrupts.
   6348            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6349            *                the configuration information for the specified I2C.
   6350            * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
   6351            * @retval None
   6352            */

   \                                 In section .text, align 2, keep-with-next
   6353          static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
   6354          {
   \                     I2C_Enable_IRQ: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   6355            uint32_t tmpisr = 0U;
   6356          
   6357            if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
   6358                (hi2c->XferISR == I2C_Slave_ISR_DMA))
   \        0x2   0x6B43             LDR      R3,[R0, #+52]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x....             LDR.N    R6,??DataTable44_5
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x42B3             CMP      R3,R6
   \        0xC   0xBF1C             ITT      NE 
   \        0xE   0x....             LDRNE.N  R7,??DataTable44_6
   \       0x10   0x42BB             CMPNE    R3,R7
   \       0x12   0xD111             BNE.N    ??I2C_Enable_IRQ_0
   6359            {
   6360              if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \       0x14   0x0749             LSLS     R1,R1,#+29
   6361              {
   6362                /* Enable ERR, STOP, NACK and ADDR interrupts */
   6363                tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6364              }
   6365          
   6366              if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
   \       0x16   0xF004 0x0311      AND      R3,R4,#0x11
   6367              {
   6368                /* Enable ERR and NACK interrupts */
   6369                tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
   6370              }
   6371          
   6372              if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   \       0x1A   0xF004 0x0412      AND      R4,R4,#0x12
   \       0x1E   0xBF48             IT       MI 
   \       0x20   0x22B8             MOVMI    R2,#+184
   \       0x22   0x2B11             CMP      R3,#+17
   \       0x24   0xBF08             IT       EQ 
   \       0x26   0xF042 0x0290      ORREQ    R2,R2,#0x90
   \       0x2A   0x2C12             CMP      R4,#+18
   \       0x2C   0xD115             BNE.N    ??I2C_Enable_IRQ_1
   \       0x2E   0xF042 0x0220      ORR      R2,R2,#0x20
   6373              {
   6374                /* Enable STOP interrupts */
   6375                tmpisr |= I2C_IT_STOPI;
   6376              }
   6377          
   6378              if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
   6379              {
   6380                /* Enable TC interrupts */
   6381                tmpisr |= I2C_IT_TCI;
   \       0x32   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x36   0xE010             B.N      ??I2C_Enable_IRQ_1
   6382              }
   6383            }
   6384            else
   6385            {
   6386              if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \                     ??I2C_Enable_IRQ_0: (+1)
   \       0x38   0x074B             LSLS     R3,R1,#+29
   6387              {
   6388                /* Enable ERR, STOP, NACK, and ADDR interrupts */
   6389                tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6390              }
   6391          
   6392              if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
   6393              {
   6394                /* Enable ERR, TC, STOP, NACK and RXI interrupts */
   6395                tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
   6396              }
   6397          
   6398              if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
   6399              {
   6400                /* Enable ERR, TC, STOP, NACK and TXI interrupts */
   6401                tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
   6402              }
   6403          
   6404              if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   \       0x3A   0xF004 0x0412      AND      R4,R4,#0x12
   \       0x3E   0xBF48             IT       MI 
   \       0x40   0x22B8             MOVMI    R2,#+184
   \       0x42   0x07CD             LSLS     R5,R1,#+31
   \       0x44   0xBF48             IT       MI 
   \       0x46   0xF042 0x02F2      ORRMI    R2,R2,#0xF2
   \       0x4A   0x0789             LSLS     R1,R1,#+30
   \       0x4C   0xBF48             IT       MI 
   \       0x4E   0xF042 0x02F4      ORRMI    R2,R2,#0xF4
   \       0x52   0x2C12             CMP      R4,#+18
   \       0x54   0xBF08             IT       EQ 
   \       0x56   0xF042 0x0220      ORREQ    R2,R2,#0x20
   6405              {
   6406                /* Enable STOP interrupts */
   6407                tmpisr |= I2C_IT_STOPI;
   6408              }
   6409            }
   6410          
   6411            /* Enable interrupts only at the end */
   6412            /* to avoid the risk of I2C interrupt handle execution before */
   6413            /* all interrupts requested done */
   6414            __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
   \                     ??I2C_Enable_IRQ_1: (+1)
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0x430A             ORRS     R2,R2,R1
   \       0x60   0x6002             STR      R2,[R0, #+0]
   6415          }
   \       0x62   0xBDF0             POP      {R4-R7,PC}       ;; return
   6416          
   6417          /**
   6418            * @brief  Manage the disabling of Interrupts.
   6419            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6420            *                the configuration information for the specified I2C.
   6421            * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
   6422            * @retval None
   6423            */

   \                                 In section .text, align 2, keep-with-next
   6424          static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
   6425          {
   6426            uint32_t tmpisr = 0U;
   \                     I2C_Disable_IRQ: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   6427          
   6428            if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
   \        0x2   0x07CB             LSLS     R3,R1,#+31
   \        0x4   0xB510             PUSH     {R4,LR}
   \        0x6   0xD507             BPL.N    ??I2C_Disable_IRQ_0
   6429            {
   6430              /* Disable TC and TXI interrupts */
   6431              tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
   6432          
   6433              if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x8   0xF890 0x4041      LDRB     R4,[R0, #+65]
   \        0xC   0x2242             MOVS     R2,#+66
   \        0xE   0xF004 0x0428      AND      R4,R4,#0x28
   \       0x12   0x2C28             CMP      R4,#+40
   \       0x14   0xBF18             IT       NE 
   \       0x16   0x22F2             MOVNE    R2,#+242
   6434              {
   6435                /* Disable NACK and STOP interrupts */
   6436                tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6437              }
   6438            }
   6439          
   6440            if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
   \                     ??I2C_Disable_IRQ_0: (+1)
   \       0x18   0x078B             LSLS     R3,R1,#+30
   \       0x1A   0xD509             BPL.N    ??I2C_Disable_IRQ_1
   6441            {
   6442              /* Disable TC and RXI interrupts */
   6443              tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
   6444          
   6445              if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
   \       0x1C   0xF890 0x4041      LDRB     R4,[R0, #+65]
   \       0x20   0xF042 0x0244      ORR      R2,R2,#0x44
   \       0x24   0xF004 0x0428      AND      R4,R4,#0x28
   \       0x28   0x2C28             CMP      R4,#+40
   \       0x2A   0xBF18             IT       NE 
   \       0x2C   0xF042 0x02B0      ORRNE    R2,R2,#0xB0
   6446              {
   6447                /* Disable NACK and STOP interrupts */
   6448                tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6449              }
   6450            }
   6451          
   6452            if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \                     ??I2C_Disable_IRQ_1: (+1)
   \       0x30   0x074B             LSLS     R3,R1,#+29
   6453            {
   6454              /* Disable ADDR, NACK and STOP interrupts */
   6455              tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6456            }
   6457          
   6458            if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
   \       0x32   0xF001 0x0411      AND      R4,R1,#0x11
   6459            {
   6460              /* Enable ERR and NACK interrupts */
   6461              tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
   6462            }
   6463          
   6464            if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   6465            {
   6466              /* Enable STOP interrupts */
   6467              tmpisr |= I2C_IT_STOPI;
   6468            }
   6469          
   6470            if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
   6471            {
   6472              /* Enable TC interrupts */
   6473              tmpisr |= I2C_IT_TCI;
   6474            }
   6475          
   6476            /* Disable interrupts only at the end */
   6477            /* to avoid a breaking situation like at "t" time */
   6478            /* all disable interrupts request are not done */
   6479            __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0xF001 0x0112      AND      R1,R1,#0x12
   \       0x3C   0xBF48             IT       MI 
   \       0x3E   0xF042 0x02B8      ORRMI    R2,R2,#0xB8
   \       0x42   0x2C11             CMP      R4,#+17
   \       0x44   0xBF08             IT       EQ 
   \       0x46   0xF042 0x0290      ORREQ    R2,R2,#0x90
   \       0x4A   0x2912             CMP      R1,#+18
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xBF04             ITT      EQ 
   \       0x50   0xF042 0x0220      ORREQ    R2,R2,#0x20
   \       0x54   0xF042 0x0240      ORREQ    R2,R2,#0x40
   \       0x58   0xEA21 0x0202      BIC      R2,R1,R2
   \       0x5C   0x6002             STR      R2,[R0, #+0]
   6480          }
   \       0x5E   0xBD10             POP      {R4,PC}          ;; return
   6481          
   6482          /**
   6483            * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
   6484            * @param  hi2c I2C handle.
   6485            * @retval None
   6486            */

   \                                 In section .text, align 2, keep-with-next
   6487          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
   6488          {
   6489            /* if user set XferOptions to I2C_OTHER_FRAME            */
   6490            /* it request implicitly to generate a restart condition */
   6491            /* set XferOptions to I2C_FIRST_FRAME                    */
   6492            if (hi2c->XferOptions == I2C_OTHER_FRAME)
   \                     I2C_ConvertOtherXferOptions: (+1)
   \        0x0   0x6AC1             LDR      R1,[R0, #+44]
   \        0x2   0x29AA             CMP      R1,#+170
   \        0x4   0xBF08             IT       EQ 
   \        0x6   0x2200             MOVEQ    R2,#+0
   6493            {
   6494              hi2c->XferOptions = I2C_FIRST_FRAME;
   \        0x8   0xD005             BEQ.N    ??I2C_ConvertOtherXferOptions_0
   6495            }
   6496            /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
   6497            /* it request implicitly to generate a restart condition    */
   6498            /* then generate a stop condition at the end of transfer    */
   6499            /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
   6500            else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
   \        0xA   0x6AC1             LDR      R1,[R0, #+44]
   \        0xC   0xF5B1 0x4F2A      CMP      R1,#+43520
   \       0x10   0xD102             BNE.N    ??I2C_ConvertOtherXferOptions_1
   6501            {
   6502              hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
   \       0x12   0xF04F 0x7200      MOV      R2,#+33554432
   \                     ??I2C_ConvertOtherXferOptions_0: (+1)
   \       0x16   0x62C2             STR      R2,[R0, #+44]
   6503            }
   6504            else
   6505            {
   6506              /* Nothing to do */
   6507            }
   6508          }
   \                     ??I2C_ConvertOtherXferOptions_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x8000'2400        DC32     0x80002400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFE00'E800        DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x8000'2400        DC32     0x80002400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \        0x0   0x8000'4000        DC32     0x80004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \        0x0   0xFE00'E800        DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_3:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_4:
   \        0x0   0x03FF'63FF        DC32     0x3ff63ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_5:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_6:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_DMA
   6509          
   6510          /**
   6511            * @}
   6512            */
   6513          
   6514          #endif /* HAL_I2C_MODULE_ENABLED */
   6515          /**
   6516            * @}
   6517            */
   6518          
   6519          /**
   6520            * @}
   6521            */
   6522          
   6523          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2C_AbortCpltCallback
       0   HAL_I2C_AddrCallback
      16   HAL_I2C_DeInit
        16   -> HAL_I2C_MspDeInit
       8   HAL_I2C_DisableListen_IT
         8   -> I2C_Disable_IRQ
      16   HAL_I2C_ER_IRQHandler
         0   -> I2C_ITError
       0   HAL_I2C_EV_IRQHandler
         0   -- Indirect call
       8   HAL_I2C_EnableListen_IT
         8   -> I2C_Enable_IRQ
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
      16   HAL_I2C_Init
        16   -> HAL_I2C_MspInit
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_ListenCpltCallback
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      24   HAL_I2C_Master_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
      32   HAL_I2C_Master_Receive
        32   -> HAL_GetTick
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      32   HAL_I2C_Master_Receive_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      24   HAL_I2C_Master_Receive_IT
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
      40   HAL_I2C_Master_Seq_Receive_DMA
        40   -> HAL_DMA_Start_IT
        40   -> I2C_ConvertOtherXferOptions
        40   -> I2C_Enable_IRQ
        40   -> I2C_TransferConfig
      32   HAL_I2C_Master_Seq_Receive_IT
        32   -> I2C_ConvertOtherXferOptions
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      40   HAL_I2C_Master_Seq_Transmit_DMA
        40   -> HAL_DMA_Start_IT
        40   -> I2C_ConvertOtherXferOptions
        40   -> I2C_Enable_IRQ
        40   -> I2C_TransferConfig
      32   HAL_I2C_Master_Seq_Transmit_IT
        32   -> I2C_ConvertOtherXferOptions
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      32   HAL_I2C_Master_Transmit
        32   -> HAL_GetTick
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      32   HAL_I2C_Master_Transmit_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      24   HAL_I2C_Master_Transmit_IT
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      48   HAL_I2C_Mem_Read
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryRead
        48   -> I2C_TransferConfig
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnSTOPFlagUntilTimeout
      40   HAL_I2C_Mem_Read_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryRead
        40   -> I2C_TransferConfig
      40   HAL_I2C_Mem_Read_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryRead
        40   -> I2C_TransferConfig
      48   HAL_I2C_Mem_Write
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryWrite
        48   -> I2C_TransferConfig
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnSTOPFlagUntilTimeout
        48   -> I2C_WaitOnTXISFlagUntilTimeout
      40   HAL_I2C_Mem_Write_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_TransferConfig
      40   HAL_I2C_Mem_Write_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_TransferConfig
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Slave_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Receive_IT
        24   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Seq_Receive_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Disable_IRQ
        32   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Seq_Receive_IT
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Seq_Transmit_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Disable_IRQ
        32   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Seq_Transmit_IT
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      24   HAL_I2C_Slave_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Transmit_IT
        24   -> I2C_Enable_IRQ
       0   I2C_ConvertOtherXferOptions
       0   I2C_DMAAbort
         0   -> HAL_I2C_AbortCpltCallback
         0   -> HAL_I2C_ErrorCallback
      16   I2C_DMAError
        16   -> HAL_DMA_GetError
         0   -> I2C_ITError
       8   I2C_DMAMasterReceiveCplt
         8   -> HAL_DMA_Start_IT
         0   -> I2C_Enable_IRQ
         0   -> I2C_ITError
       8   I2C_DMAMasterTransmitCplt
         8   -> HAL_DMA_Start_IT
         0   -> I2C_Enable_IRQ
         0   -> I2C_ITError
       8   I2C_DMASlaveReceiveCplt
         0   -> I2C_ITSlaveSeqCplt
       0   I2C_DMASlaveTransmitCplt
         0   -> I2C_ITSlaveSeqCplt
       8   I2C_Disable_IRQ
      20   I2C_Enable_IRQ
       0   I2C_Flush_TXDR
      24   I2C_ITAddrCplt
         0   -> HAL_I2C_AddrCallback
        24   -> I2C_Disable_IRQ
      16   I2C_ITError
         0   -- Indirect call
        16   -> HAL_DMA_Abort_IT
         0   -> HAL_I2C_AbortCpltCallback
         0   -> HAL_I2C_ErrorCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITListenCplt
         0   -> HAL_I2C_ListenCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITMasterCplt
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MasterTxCpltCallback
         0   -> HAL_I2C_MemRxCpltCallback
         0   -> HAL_I2C_MemTxCpltCallback
        16   -> I2C_Disable_IRQ
        16   -> I2C_Flush_TXDR
         0   -> I2C_ITError
      16   I2C_ITMasterSeqCplt
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MasterTxCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITSlaveCplt
         0   -> HAL_I2C_ListenCpltCallback
         0   -> HAL_I2C_SlaveRxCpltCallback
         0   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_Disable_IRQ
        16   -> I2C_Flush_TXDR
        16   -> I2C_ITError
         0   -> I2C_ITListenCplt
        16   -> I2C_ITSlaveSeqCplt
      16   I2C_ITSlaveSeqCplt
         0   -> HAL_I2C_SlaveRxCpltCallback
         0   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_IsAcknowledgeFailed
        16   -> HAL_GetTick
        16   -> I2C_Flush_TXDR
      24   I2C_Master_ISR_DMA
        24   -> I2C_Enable_IRQ
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITError
        24   -> I2C_ITMasterCplt
        24   -> I2C_ITMasterSeqCplt
        24   -> I2C_TransferConfig
      24   I2C_Master_ISR_IT
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITError
        24   -> I2C_ITMasterCplt
        24   -> I2C_ITMasterSeqCplt
        24   -> I2C_TransferConfig
      32   I2C_RequestMemoryRead
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      24   I2C_Slave_ISR_DMA
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITAddrCplt
        24   -> I2C_ITError
        24   -> I2C_ITListenCplt
        24   -> I2C_ITSlaveCplt
        24   -> I2C_ITSlaveSeqCplt
      24   I2C_Slave_ISR_IT
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITAddrCplt
        24   -> I2C_ITError
        24   -> I2C_ITListenCplt
        24   -> I2C_ITSlaveCplt
        24   -> I2C_ITSlaveSeqCplt
      16   I2C_TransferConfig
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXISFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable32
       4  ??DataTable37
       4  ??DataTable38
       4  ??DataTable41
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       8  ??Subroutine95_0
       8  ??Subroutine96_0
       8  ??Subroutine97_0
       6  ??Subroutine98_0
      14  ?Subroutine0
       6  ?Subroutine1
      68  ?Subroutine10
      66  ?Subroutine11
      46  ?Subroutine12
      38  ?Subroutine13
      38  ?Subroutine14
      38  ?Subroutine15
      20  ?Subroutine16
      18  ?Subroutine17
      16  ?Subroutine18
      14  ?Subroutine19
       6  ?Subroutine2
       6  ?Subroutine20
       8  ?Subroutine21
      14  ?Subroutine22
      16  ?Subroutine23
      20  ?Subroutine24
      12  ?Subroutine25
      12  ?Subroutine26
       8  ?Subroutine27
      56  ?Subroutine28
      22  ?Subroutine29
       6  ?Subroutine3
      20  ?Subroutine30
      14  ?Subroutine31
      14  ?Subroutine32
      12  ?Subroutine33
      10  ?Subroutine34
      12  ?Subroutine35
      18  ?Subroutine36
      14  ?Subroutine37
      24  ?Subroutine38
      24  ?Subroutine39
      12  ?Subroutine4
      10  ?Subroutine40
      12  ?Subroutine41
      12  ?Subroutine42
      32  ?Subroutine43
      18  ?Subroutine44
      14  ?Subroutine45
      34  ?Subroutine46
      12  ?Subroutine47
      12  ?Subroutine48
      32  ?Subroutine49
       8  ?Subroutine5
      18  ?Subroutine50
      18  ?Subroutine51
      18  ?Subroutine52
      12  ?Subroutine53
      20  ?Subroutine54
      32  ?Subroutine55
      16  ?Subroutine56
       8  ?Subroutine57
       8  ?Subroutine58
      20  ?Subroutine59
      10  ?Subroutine6
      10  ?Subroutine60
       8  ?Subroutine61
      48  ?Subroutine62
      18  ?Subroutine63
      20  ?Subroutine64
      20  ?Subroutine65
      20  ?Subroutine66
      20  ?Subroutine67
      20  ?Subroutine68
      24  ?Subroutine69
      10  ?Subroutine7
      18  ?Subroutine70
      20  ?Subroutine71
      30  ?Subroutine72
      14  ?Subroutine73
      10  ?Subroutine74
      12  ?Subroutine75
      12  ?Subroutine76
       8  ?Subroutine77
      30  ?Subroutine78
      10  ?Subroutine79
      10  ?Subroutine8
      22  ?Subroutine80
      18  ?Subroutine81
       8  ?Subroutine82
      12  ?Subroutine83
       8  ?Subroutine84
      40  ?Subroutine85
      12  ?Subroutine86
      12  ?Subroutine87
      12  ?Subroutine88
       8  ?Subroutine89
      18  ?Subroutine9
       8  ?Subroutine90
      20  ?Subroutine91
      10  ?Subroutine92
      10  ?Subroutine93
      12  ?Subroutine94
       2  HAL_I2C_AbortCpltCallback
       2  HAL_I2C_AddrCallback
      38  HAL_I2C_DeInit
      48  HAL_I2C_DisableListen_IT
      90  HAL_I2C_ER_IRQHandler
      16  HAL_I2C_EV_IRQHandler
      36  HAL_I2C_EnableListen_IT
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     160  HAL_I2C_Init
     278  HAL_I2C_IsDeviceReady
       2  HAL_I2C_ListenCpltCallback
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
      76  HAL_I2C_Master_Abort_IT
     150  HAL_I2C_Master_Receive
     180  HAL_I2C_Master_Receive_DMA
      52  HAL_I2C_Master_Receive_IT
     192  HAL_I2C_Master_Seq_Receive_DMA
      94  HAL_I2C_Master_Seq_Receive_IT
     188  HAL_I2C_Master_Seq_Transmit_DMA
      94  HAL_I2C_Master_Seq_Transmit_IT
     150  HAL_I2C_Master_Transmit
     178  HAL_I2C_Master_Transmit_DMA
      52  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     182  HAL_I2C_Mem_Read
     168  HAL_I2C_Mem_Read_DMA
     112  HAL_I2C_Mem_Read_IT
     174  HAL_I2C_Mem_Write
     164  HAL_I2C_Mem_Write_DMA
     108  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     216  HAL_I2C_Slave_Receive
     116  HAL_I2C_Slave_Receive_DMA
      34  HAL_I2C_Slave_Receive_IT
     182  HAL_I2C_Slave_Seq_Receive_DMA
     112  HAL_I2C_Slave_Seq_Receive_IT
     188  HAL_I2C_Slave_Seq_Transmit_DMA
     120  HAL_I2C_Slave_Seq_Transmit_IT
     222  HAL_I2C_Slave_Transmit
     114  HAL_I2C_Slave_Transmit_DMA
      34  HAL_I2C_Slave_Transmit_IT
      26  I2C_ConvertOtherXferOptions
      36  I2C_DMAAbort
      48  I2C_DMAError
      52  I2C_DMAMasterReceiveCplt
      52  I2C_DMAMasterTransmitCplt
      38  I2C_DMASlaveReceiveCplt
      28  I2C_DMASlaveTransmitCplt
      96  I2C_Disable_IRQ
     100  I2C_Enable_IRQ
      28  I2C_Flush_TXDR
     136  I2C_ITAddrCplt
     196  I2C_ITError
      86  I2C_ITListenCplt
     166  I2C_ITMasterCplt
      62  I2C_ITMasterSeqCplt
     230  I2C_ITSlaveCplt
      82  I2C_ITSlaveSeqCplt
     112  I2C_IsAcknowledgeFailed
     248  I2C_Master_ISR_DMA
     290  I2C_Master_ISR_IT
      56  I2C_RequestMemoryRead
      58  I2C_RequestMemoryWrite
     206  I2C_Slave_ISR_DMA
     276  I2C_Slave_ISR_IT
      34  I2C_TransferConfig
      66  I2C_WaitOnFlagUntilTimeout
     112  I2C_WaitOnRXNEFlagUntilTimeout
      48  I2C_WaitOnSTOPFlagUntilTimeout
      54  I2C_WaitOnTXISFlagUntilTimeout

 
 9 254 bytes in section .text
 
 9 230 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
